## 算法

+ 最长不重复子串：滑动窗口
+ LRU-k：双端队列+哈希表

## 实习

```
### 网易（杭州）网络有限公司分布式存储系统开发实习生

+ 参与开发 Curve Tools 由 C++ 版本向 Golang 版本的迁移，添加块存储相关命令。
+ 作为主要开发负责量化交易系统，系统由 Python 开发、交易资产为数字货币期货交易、支持 Binance 和OKEX 两个平台、主要支持高频轮询式策略。
+ 交易接口模块：使用 Request 模块为平台 Restful API 封装客户端，客户端接口统一，用户同一套策略可以运行于两个平台；封装 Python 原生有栈协程，实现接口好用、性能高的异步网络库。
+ 策略管理模块: 使用 Flask 框架 + multiprocessing 模块 + logging 模块实现通过网页进行多策略的监控和交互；其中日志模块在用户层面简洁统一好用。
+ (针对轮询式策略的) 回测模块: 接口和实盘交易接口相同，用户无需修改代码，接口内部对接市场模拟模块；通过 Sleep 函数实现策略代码和回测代码的跳转；通过减少运行热点时的系统调用进行调优，性能优化 3 倍。
```

## 项目

### Redis 的 Modern C++ 实现

```
C++17 实现，基于 CMake，[地址](https://github.com/zweix123/zedis)，约 3000 行
+ 封装 C 风格接口 (文件描述符、套接字和字节流)，通过 RAII 管理文件描述符和套接字正确关闭。
+ 主要以侵入式数据结构的实现内部数据结构: 基于拉链法实现渐进调整的可扩展哈希表，结合 AVL 树实现有序集，通过有序链表实现 TCP 连接定时器，通过堆实现键的 TTL。
+ 通过线程池实现键的异步销毁。
```

+ [C++相关](#C++)
+ Socket编程相关：
	+ OS内核会维护两个队列，TCP半连接队列和TCP全连接队列，如果全连接队列非空则返回给`accept()`函数一个套接字
	+ Linux中万物皆文件，每个文件都有inode，Socket文件的inode指向Socket结构体，里面有两个队列（链表），元素是`struct sk_buff`，这个结构体即描述网络中的**各个层**的数据包，是的，一个结构体维护各个层的（因为首部的大小是固定的，所以层层套娃、层层拨去就行）
	+ 并发：
		1. 多进程：问题：进程间上下文切换的花销很大
		2. 多线程：线程的切换虽然开销不大（也由操作系统负担），但开销仍然不小。
		3. 线程池：解决的是线程的频繁创建和销毁。

		这样的并发是有上限的。
	+ IO多路复用：一个进程维护多个Socket
		+ `select`：将已连接的Socket放在一个集合中，然后select将其拷贝到内核里，由内核检测是否有网络事件的发生（暴力的遍历），会修改Socket标记（可读或可写），然后把集合拷贝会用户态。用户态再遍历集合找。  
			这里的集合是BitsMap
			问题：两次遍历、两次拷贝，且集合允许最大值有限
		+ `poll`：较于select的区别是将固定大小的集合换成链表实现的动态数组  
			问题：但是Socket数量依然受到系统文件描述符限制

		+ `epoll`：使用红黑树跟踪进程所有待检测的文件描述符；使用事件驱动，维护一个链表记录就绪事件。
			+ 边缘触发：当有就绪事件发生是苏醒一次：必须一次读完
			+ 水平触发（默认）：当有就绪事件发生是不断苏醒

	+ 网络模式：上面仅仅是快速的拿到可读或者可写的Socket，下一个问题就是对Socket的读写。这个过程默认是阻塞的，如果设置成非阻塞的，就需要线程不断轮询尝试read。最理想的肯定是只有可read是才唤醒对应的线程去读，这就是IO多路复用。
		+ Reactor模式：对IO多路复用的封装

+ Redis：
	+ 服务数据存储在数据库中，数据库就要落盘，就慢，所以把Redis作为缓存层，就像OS中TLB
	+ 缓存雪崩：
		+ 为了让缓存和数据中的数据保持一致性，就给Redis中的数据设置过期时间，这样就不命中了，于是去数据库读并加载缓存
		+ 那么如果恰好大量缓存数据在同一时间过期了，或者Redis直接G了，于是多有的请求都到了数据库这里，就让其压力骤增
		+ 大量数据同时过期的解决：
			+ 均匀设置过期时间，即给时间加上一个随机数
			+ 互斥锁：对于未命中情况，锁一下，保证只有一个请求来加载缓存，这个锁也要TTL，放置它G了
			+ 后台更新缓存：解耦下，不用TTL了，有专门模块负责：缓存不使用TTL，而是使用内部的淘汰，这时就可能出现业务线程（见闻知意）需要数据而没有在缓存的情况
				1. 后台程序频繁更新检测
				2. 业务线程通过**消息队列**告知后台线程更新缓存

				缓存预热，即在项目开始前进行缓存，放置初期的大量miss
		+ Redis故障党纪
			+ 服务熔断或者请求限流
			+ 分布式
	+ 缓存击穿：
		+ 热点数据，比如秒杀时，一旦这个数据过期，对其的大量请求就到了数据库这里。
		+ 缓存雪崩问题的子集
	+ 缓存穿透：
		+ 和上面两个情况类似，不同点在于，这个数据不仅不在缓存中，而且不在数据库中。如果在数据库而不在缓存，还能更新缓存之后减小数据库压力。但是连数据库都没有，后续的请求就都会落到数据库上。
		+ 出现原因：
			+ 业务操作失误
			+ 黑客恶意攻击
		+ 解决方案
			+ 非法请求限制：即先Check下是否在（在请求到缓存和数据库之前）
			+ 缓存空值或者默认值
			+ 布隆过滤器：即先Check下是否存在（在数据库之前）
				+ 一个N位位图，N个哈希函数，分别求哈希然后取模，将对应位置设为1。我们发现这个应该很容易重叠，但是这仅仅意味着布隆过滤器说有不一定有，但是布隆过滤器说没有就肯定没有。我们的需要就是check是否不在。


### 动态语言解释器

```
将代码转换成字节码然后在虚拟机中运行，数据类型支持列表，语法支持闭包、类和垃圾回收。  
C 语言实现，由 make 构建，[地址](https://github.com/zweix123/zlang)，约 3000 行。

+ 扫描器按需扫描，编译器单遍编译，使用 Pratt 解析表达式，虚拟机为栈式虚拟机。
+ 通过 Tagged Union 实现多态，基于开放寻址法实现可扩展哈希表，驻留字符串优化名称访问速度，局部变量通过编译期确定 slot 位置优化读写速度，使用 upvalue 技术实现闭包，垃圾回收采用标记清除算法，通过三色标记自适应清除。
```

### 操作系统-MIT 6.s081

```
我并没有做、没有写在简历上，这里只是为了文章结构的统一
```

+ 进程和线程：
	+ 线程主要为了解决进程的通信问题和切换开销。

### 计算机网络-Stanford CS 144

```
项目基于 CMake，使用 C++20 实现。通过循环队列实现字节流缓存，实现对失序字节流的重排器，TCP 发送端维护滑动窗口实现超时重传。实现数据链路层和网络层的接口，即 IP 数据报和以太网帧的相互转换和正确发送，缓存 MAC 地址到 IP 地址的映射。实现 IP 的路由选择。
```

### 数据库-MIT 15445

```
我并没有做、没有写在简历上，这里只是为了文章结构的统一
```

+ SQL语法：
+ ACID
+ MVCC
+ 幻读

### 系统设计/分布式

+ CAP理论

## 技能

### C++

```
熟悉 Modern C++, 了解 C++ 并发编程；
```

+ `virual`关键字
	+ 虚构造，为什么需要虚构造

+ C++
	+ RAII
	+ 移动语义
	+ 只能指针
	+ STL底层原理
	+ 新特性
	+ 模板元编程
	+ 


### Other

```
熟悉 Python 语言, 开发有以 Human Readable 的 Object Printer 以及较多爬虫; 了解 Go 语言, 有相关开发经验 (实现 [B+ 树](https://github.com/zweix123/goZSQL_fail)、[单机区块链](https://github.com/zweix123/zcoin)、MapReduce 等)。

基本的前端知识和一定的产品思维，开发有[使用 Markdown 方言生成基于 Reveal.js 的 Web Slide 框架](https://github.com/zweix123/jyyslide-md)、[易用的简历生成器](https://github.com/zweix123/resume-template)
```
