效率真心高呀，神航内推完HR小姐姐就来了。

## 9.6-HR约笔试 | 9.7-笔试

询问HR得知不能公开笔试形式和内容。全是算法，挺有意思的。

## 9.22-一面

一个小时System拷打酣畅淋漓，面试官是秋招第二个按着简历一个一个问的，呜呜好感动。

+ 面试官设备出问题不能开摄像头，所以也没限制我是否开摄像头
+ 询问是否可以录屏，同意并叮嘱不能传播，于是进一步问是否可以写面经，答复可以。
+ 自我介绍

1. 你是怎么设计学习计划的，已经学了哪些，还计划学什么？
2. 解释器：
	+ 是课程作业还是什么课程？
3. Redis的Modern C++实现
	+ 哪些体现Modern？
		+ RAII管理资源，比如文件描述符和套接字
		+ 标准库，`Optional`，并发相关
		+ Redis的有序集使用侵入式数据结构实现，如果要Modern的话只能CTRP，这里本身就不好实现，而且对虚构需要异步，所以目前只能说有方向，但是没有实现。
		+ 项目结构借鉴了CS144和CMU15445的CMakeLists.txt
	+ 你是怎么实现，比如网络模块和存储模块的实现，和真实的Redis有哪些异同。
		+ 网络通信：
			+ 对C风格结构的封装，不仅的调用的封装，还有就是其安全的管理，比如对文件描述符的抽象、套接字的抽象，对每个TCP链接的抽象，对于`poll`的异步IO的字节缓冲流的抽象封装。
		+ 存储部分：主要是各种数据结构的实现
			+ 有序集是拉链法、渐进调整的哈希表和二叉平衡树AVL的结合。
				+ Redis使用跳表
			+ 有序链表实现定时器。
			+ 堆管理键的TLS
				+ 惰性删除和RAII的冲突
	+ 是单线程模型嘛？
		+ 在确定删除和进行删除有一个小异步。
4. 说说你对CS144的实现，从发起send，另一端recive，你的实现经过哪些网络层次，涉及哪些算法，或者哪些流的控制，或者说就是讲讲你的实现。
	+ 基础设施
		+ 之前将的对C风格接口或者系统调用的封装。
		+ 数据类
	+ 字节流：二倍大小循环队列实现字节流缓冲
	+ 使用链表维护不重叠区间的重排器。
	+ TCP的首发两端就是按照接口普通的模拟
	+ 我做的2023没有对TCP状态机的实现
	+ 其他就是零碎的比如将TCP数据流到IP数据包的包装，从IP地址到MAC的相互转换。
	>这里还忘了，我又共享屏幕，看的笔记想起来的。

	+ 性能测试是官方提供还是自己找相关的方法测试

5. 讲一讲你量化交易系统中的优化部分。
	+ 调整系统调用分布
	+ 小细节
		+ 对大`dict`的缓存

 6. xv6中也提到了对系统调用的优化，都指的那里？
	+ COW优化fork
	---

	+ 关于时间相关的系统调用
		+ 你在Redis中应该也有时间中的需求？包括精度相关的需要是什么？
				是的，但是仅仅是获得当前时间，也是通过C++标准库拿到的

		+ 你对操作系统关于获取时间的相关服务和接口有哪些了解？

	+ 面试官说：如果要测性能，获取时间本身操作的开销就影响很大，而且跟时间相关系统调用，Linux有很多对其的优化，比如不进入内核。因为看你简历有相关，比如“共享内存”，和Linux的优化很像。

+ 你在同火焰图分析量化交易系统时没有取得主要原因是什么？  
	你当时的火焰图是用什么生成的？  
	它采集和profile的原理是什么？不是获取运行时栈的信息，是采样时怎们知道哪段耗时？C++呢？

>坏了，我骄傲啥呢，看回放感觉这部分表现很糟糕呀。

+ Q1：
	```cpp
	struct SpinLock {
		void lock() {
			while (locked) {
				// do nothing
			}
			locked = true;
		}
		void unlock() {
			locked = false;
		}
		bool locked = false;
	};
	```

	以上自旋锁有哪些问题

	+ 首先是同步机制，这里对locked的读写就是有竟态的，应该有比如原子变量或者锁之类的。
	+ 另外就是自旋在这里就是空转，拜拜占用CPU，如果可以，应该有主动放权的相关操作

	所以使用什么内存序呢？

	>内存序我当时理解是内存模型，但是内存模型我也学的云里雾里的，后面会把笔记写在下面。
	
+ Q2：
	```cpp
	struct MultiLockGuard {
		MultiLockGuard(std::initialize_list<SpinLock*> ls) : locks(ls) {
			for (auto l: locks) l->lock;
		}
		~MultiLockGuard() {
			for (auto l: locks) {
				l->unlock();
			}
		}
		std::vector<SpinLock*> locks;
	};
	```

	上面代码有什么问题？

	+ 死锁：
		+ 一方面不能保证用户传入的锁集合是正确的，比如把一个锁两次放进list中，那就死锁了
		+ 另外就是放的顺序，比如一个的锁集合是`a, b`，另一个是`b, a`，也死锁了。

+ Q3：
	```cpp
	struct ThreadPool {
		ThreadPool(std::size_t num) {
			for (decltype(num) i = 0; i < num; ++ i) {
				workers.push_back(std::thread(poll, this));
			}
		}
		~ThreadPool() {
			stop.store(true, std::memory_order_seq_cst);
		}
		void push(std::packaged_task<int()>&& task) {
			taskqueue.push(std::move(task));
		}
		static void poll(ThreadPool* pool) {
			while (!poll->stop.load(std::memory_order_seq_cst)) {
				auto task = std::move(pool->taskqueue.front());
				pool->taskqueue.pop();
				task();
			}
		}
		std::atomic<bool> stop;
		std::vector<std::thread> workers;
		std::queue<std::package_task<int()>> taskqueue;
	};
	```

	上面代码有什么正确性问题和性能问题
	>这里对push和poll两个操作没有加锁，先忽略
	
	+ 这个`push_back(this)`这个事儿就得掂量掂量，比如用户使用智能指针维护线程池，而这个poll是静态的，很有可能poll拿到的ThreadPool的指针被其他智能指针释放了。有标准库解决这个问题（致记得这个东西，不记得具体名字，后面补充）
	+ 性能问题：初始化那里，通过`resize`初始化

	你写多线程写的多吗？比如有个接口叫做`join`知道么？它是否可以解决这个线程池的一些问题

	+ 线程池在析构这里，仅仅是通过原子变量去作为信号量，但是可能仍然有子线程在跑，但是线程池都已经析构了，这些子线程还跑什么呢？

	这里把this指针给到poll，然后poll本身还是一个线程池里的，那么这里是不是可能会有循环引用的问题？
	>这个东西我在复盘看了好几遍才明白

	怎么解决这个问题？
	>怎么解决这个问题？！？！完了完了我怎么开始胡言乱语了？

	原子变量的使用也有些问题

	还有没有性能问题，比如如果num很大，每次poll都有一个锁竞争，这里的竞争很大的，怎么办？  
	你在xv6时有没有相关问题，比如对锁的竞争降低？我印象里有就是将其拆分成多个锁，这样每个锁的竞争更少。

	>完了，我明白了，我对线程池根本就不懂呀。

+  Q4：
	```cpp
	int doFib(ThreadPool& p, int n) {
		if (n < 2) {
			return n;
		} else {
			std::packaged_task<int()> taskx([&]{doFib(p, n - 1); }); // wrap the function
			std::future<int> fx = taskx.get_future();  // get a future
			p.push(std::move(taskx));
			
			std::packaged_task<int()> tasky([&]{doFib(p, n - 2); }); // wrap the function
			std::future<int> fy = taskx.get_future();  // get a future
			p.push(std::move(tasky));

			fx.wait();
			fy.wait();

			int x, y;
			x = fx.get();
			y = fy.get();
			return x + y;

		}
	}

	int fib(int n) {
		ThreadPool p(100);
		return doFib(p, n);
	}
	```

	上面那里会死锁？

	这里的`wait`和`get`会等待子线程，但是如果线程池容量比较小，大量的线程的都会等待它的子结点的计算，但是线程池已经占满了，后面的几点不会被计算，死锁。

	怎么解决？

	给每个线程提供主动放权的操作
	>以为只在C++标准库以上的东西，面试官的意思是不在编程上的，而是对编译器进行修改。我依照考虑有更大的监视者来解决。

	相当于要提供一个接口类似有栈协程的主动放权。

	那你在xv6里也有一个用户级线程的实现
	+ 主要有两个
		+ 一个是提供两个接口让用户代码可以主动选择何时后调用
		+ 另一个就是用户级线程切换，在用户态把上下文相关环境切换。

+ 反问：
	>完了，我蒙圈了，没啥想问了

	弱弱的问了下面评。

	很多知识需要实践。

>完了完了，面试的时候脑子蒙了，复盘看有很多问题是会的，但是面试的时候确实没想到。而且确实有很多东西答得很烂呀。竟然面试通过了，谢谢面试官！
