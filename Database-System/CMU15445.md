>2023 Spring

# Project1

+ 就我个人而言，卡住的地方主要有三段
	+ 对BPM接口的功能的理解以及各个接口应该带来哪些数据结构怎样的变化，理清即可，从69到了91分，结论如下图：
			<img alt="BPM" src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Database-System/bpm.jpg" width = "90%">

	+ 一个类似`unique_ptr`功能类的实现，说来惭愧，之前并没有实现过移动相关标准函数，有了一个乌龙，比如我在移动构造的开始也调用`Drop`了，因为里面有检测，所以这句应该没有发挥作用，但是这里就是为了构造`this`，不可能需要`Drop`，然后还有就是在移动拷贝需要check下不能自己移动向自己，我这里没有check，所以会出现pin count错误的问题，但是这玩意不应该在编译器就error的嘛？不知道线上的测试样例是什么样子的。
	+ 最后就是死锁，即`FetchPageWrite`/`FetchPageRead`不能使用函数锁，是先锁住拿到页实例指针，然后就释放BPM的锁，然后在获取页实例的latch，否则就会死锁，这个是看前辈的攻略才对的。比如这样的样例，比如一个样例持有一个锁，另一个线程通过bpm去fetch同样的页，就在加页锁的时候等待了，而第一个也调用bpm的方法，就死锁了。

下面是我自己画的接口带来的数据结构变化的逻辑图，其实也挺费解的，因为是我对接口理解到一定程度后的总结，解说就不一定有了


## What is BPM?

+ Reference：
	+ https://cloud.tencent.com/developer/article/2114126

# Project2

主要是对B+Tree的实现，我个人算法实现依照教材《DataBase System Concepts 7th》，下面是对教材中相关内容的简单翻译和整理。

+ B Plus Tree首先是一种Balanced Tree
+ B Plus Tree有两种node类型
	+ noleaf node/internal node：
		+ 非root的internal node的child数量在 $\lceil \frac{n}{2} \rceil$ 和 $n$ 之间
		+ root的child数量在 $2$ 和 $n$ 之间
	+ leaf node：
		+ “child”数量在 $\lceil \frac{n - 1}{2} \rceil$ （相当于 $\lfloor \frac{n}{2} \rfloor$ ）和 $n - 1$ 之间。
			>leaf node的child就是recored

	上面的描述是符合Bustub中的B+Tree的，当然对应node的n使用对应node类型的max size，值得一提的是internal node中第一个invalid键和其对应的值作为的键值对也包含在size里。

+ 对于每个node（无论是internal还是leaf），设其max size为n，则其包含`n - 1`个key，`n`个pointer，如下：  
	<img alt="B+Tree Node Content" src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Database-System/B_Plus_Tree-node.png" width = "80%">

	+ 其中`K`严格单调递增（暂时不讨论相同Key）
	+ 在Internal node中
		+ pointer为childern node pointer
		+ 对于一个node pointer $P_{i}$ ，其指向的node的所有的key都满足，大于等于 $K_{i - 1}$，小于 $K_{i}$，即左闭右开区间。
	+ 在leaf node中
		+ 前`n -1`为正常的键值对，最后一个pointer不与任何键匹配（从图里发现），它指向的是其右边第一个叶子结点。

---

+ 联系：
	+ 我们知道了为什么internal node最多有n个child，而leaf node却最多有n - 1个“child”，这是因为即使是同样的n，并且确实使用同样的格式，但是leaf node的最后一个pointer有特殊的用法，所以不能用来指向child
	+ 上面的涉及也是合理的，因为这`n - 1`个key和`n`个pointer在不同结点表达的语义不同
		+ internal node：将值域通过`n - 1`个key划分成`n`个左闭右开区间
		+ leaf node：前`n - 1`个`<pointer, key>`对形成键值对。

+ 实现：上面的定义和在Bustub的实现还是有挺大的Gap的
	+ internal：
		+ Bustub对键值对的存储使用`std::pair<KeyType, ValueType> array_[]`，至少我对其最直觉的想象是`key[0], pointer[0], key[1], pointer[1], key[2], ...`的序列，然后还要求`key[0]`是invalid的，所以序列变成`pointer[0], key[1], pointer[1], key[2], ..., key[size - 1], pointer[size - 1]`，但是我们发现教材上的序列相当于`pointer[1], key[1], pointer[2], ..., key[n - 1], pointer[n - 1], pointer[n]`，这里索引对不上（我指的是Bustub中是第一个pointer单独一组，然后后面的一key一pointer一组，而教材中是第一个pointer和第一个key一组），即两者虽然pointer和key的先后顺序一致，但是具体的对应关系不一致。我本来有一个trick的做法，但是Bustub给我提供了图形化相关的辅助函数，还必须按照上面的方式写，即必须错配着写。或者想办法忽略这里的“成对”的关系，把握“分割”这个性质即可。
		+ 我们发现索引对不上。索性，15445为我们实现一些辅助函数，比如图形化相关的，这里就有对树的遍历。
	+ leaf：
		+ Bustub使用的是索引从0开始到`size - 1`的`pair`线性表，而有特殊作用的pointer使用额外的数据成员表示，这也解释了为什么leaf的内容数量最多到`leaf_max_size - 1`，是从概念出发的。

## Queries

+ 单点查询key的recored：函数`find`，伪代码如下：
	```Pascal
	function find(v)
	// Assumes no duplicate keys, 
	// and returns pointer to the record with search key value v if such a record exists,
	// and null otherwise.
		Set C = root node
		while (C is not a leaf node) begin
			Let i = smallest number such that v <= C.K[i]
			if there is not such number i then begin
				Let P_m = last non-null pointer in the node(C.P[...])  // 因为对于最后的一个pointer表示的child node的key大于当前结点所有的key
				Set C = P_m
			end
			else if (v == C.K[i]) then Set C = C.P[i + 1]  // 因为区间是左闭右开嘛, 所以如果和边界相等, 应该是右边的
			else Set C = C.P[i]  // v < C.K[i]
		end
		// C is a leaf node
		if for some i, K[i] == v
			then return P[i]
			else return null;  // No record with key value v exists
		end
	```

+ range queries区间查询：函数`findRange`，伪代码如下：
	```Pascal
	function findRange(lb, ub)  // [lb, ub]区间-------------------|
	// Return all records with search key value V such that lb <= V <= ub
		Set resultSet = {};
		Set C = root node
		while (C is not a leaf node) begin
			Let i = smallest number such taht lb <= C.K[i]
			if there is no such number i then begin
				Let P_m = last non-null pointer in the node(C.P[...])
				Set C = P_m
			end
			else if (lb == C.K[i]) then Set C = C.P[i + 1]
			else Set C = C.P[i]  // lb < C.K[i]
		end
		// 以上几乎和单点查询一致
		// C is a leaf node
		Let i be the least value such that K[i] >= lb  // i是C中大于等于左区间点的第一个键的索引
		if there is no such i
			then Set i = 1 + number of keys in C;  // To force move to next leaf
		Set done = false;
		while (not done) begin
			Let n = number of keys in C.
			if (i <= n and C.K[i] <= ub) then begin
				Add C.P[i] to resultSet
				Set i = i + 1
			end
			else if (i <= n and C.K[i] > ub)
				then Set done = true;
			else if (i > n and C.P[n + 1] is not null)
				then Set C = C.P[i + 1] and i = 1  // Move to next leaf
			else Set done = true;  // No more leaves to the right
		end
		return resultSet
	```

## Updates

对B Plus Tree的Updates可以be modeled as先删除再插入，所以只考虑插入和删除两个操作。而这两个操作就涉及node的split和coalese/combine的问题。

+ 插入insert：分成三个代码块（不一定是函数，下面删除也是）
	```pascal
	procedure insert(value K, pointer P)
	// 在树种插入键值对<K, P>
	// 注意这里P是一种抽象, 既可以是recored的pointer, 也可以是其他node的pointer, 这样的优势在下面会体现出来
		if (tree is empty) create an empty leaf node L, which is alse the root
		else Find the leaf node L that should contain key value K  // 这里的包含的意思应该是在范围内
			// 注意!教材中的做法没有检测重复键!
		if (L has less than n - 1 key values)  // 这里为什么要小于n - 1, 因为leaf node的size就是最多n - 1, 但是bustub不是, bustub可以到leaf_max_size;
			then insert_in_leaf(L, K, P)  // 位置充足, 直接插入
			else begin  // L has n - 1 key values already, split it
				Create node L_
				Copy L.P[1], ..., L.K[n - 1] to a block of memory T that can hold n(<pointer, key>) pairs
				// T可以容纳n对, 但是我们值移动n - 1个, 一方面原结点还剩一个pointer是用于迭代器的那个, 另一方面剩余的空间给新键
				insert_in_leaf(T, K, P)
				// 下面两句类似单向链表的结点插入
				Set L_.P[n] = L.P[n];
				Set L.P[n] = L_
				
				Erase L.P[1] through L.K[n - 1] from L  // 清空(或者说初始化)旧结点内容
				Copy T.P[1] through T.K[std::ceil(n / 2)] from T into L starting at L.P[1]
				Copy T.P[std::ceil(n / 2) + 1] through T.K[n] from T into L_ starting at L_.P[1]
				Let K_ be the smallest key in L_  // 还记得区间的开闭嘛? 所以应该取右边结点的最小key
				insert_in_parent(L, K_, L_)
			end

	// insert_in_laef的调用者保证node L空间足够再容纳一个<K, P>
	procedure insert_in_leaf(node L, value K, pointer P)  // L: leaf node, K: key, P: recored pointer
		if (K < L.K[1])  // 我猜这里缺一步. 就是L可能是空的
			then insert P, K into L just before L.P[1]
			else begin
				Let K[i] be the highest value in L that is less than or equal to K  //找到第一个键小于等于
				Insert P, K into L just after L.K[i]
			end

	procedure insert_in_parent(node N, value K_, node N_)  // N和N_是两个兄弟, 他们的间隔key是K_, K_应该是N_的最小key
		if (N is the root of the tree)  // 被拆分的N本来是根(N是本来的结点(但是已经重新初始化了), N_是存储多于内容、新开的结点)
			then begin
				Create a new node R containing N, K_, N_
				Make R the root of the tree
				return
			end
		Let P = parent(N)
		if (P has less than n pointers)
			then insert(K_, N_) in P just after N  // 注意这里不是递归调用procedure insert, 那个是直达leaf node的, 这里仅仅是表述动作, 不过可以保证的是这个动作是无递归的
			else begin  // Split P
				Copy P to a block of memory T that can hold P and (K_, N_)
				Insert(K_, N_) into T just after N  // 同样的, 这里的insert也表示动作而不是调用
				Erase all entries from P; 
				Create node P_
				// 这里和之前的拆分leaf node相比不需要维护兄弟之间类似单项链表的关系
				Copy T.P[1], ..., T.P[std::ceil((n + 1) / 2)] into P  // 注意这里是从1开始的, bustub可是从0开始
				Let K__ = T.K[std::ceil((n + 1) / 2)]
				Copy T.P[std::ceil((n + 1) / 2) + 1], ..., T.P[n + 1] into P_
				insert_in_parent(P, K__, P_)  // 递归向上
			end
	```
