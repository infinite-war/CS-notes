>2023 Spring

完成Lab过程的记录，能确保没有源码，且没有过分描述实现，严格遵守学术诚信。

我本质之前其实没有深入学习过数据库的理论知识，低年级是草草看过萨师煊先生的《数据库系统概念》，但是一方面当时对数据库整体概念不了解，理解根本不够，另一方面时间太久远了，四舍五入就是没学过。本次做实验前也没有系统学过（甚至都没有零星学过），唯一参考资料就是官方Handout，基本就是它让我实现什么需求，我就实现什么功能。C++基础有一些，实现的方式依靠直觉，所以性能一般。后面有机会系统学习下数据库理论知识然后优化下。

# Project1

正如程序就是数据结构+算法，一定要理清题目就是是想让我们做什么，以及一个行为会导致内部数据结构的哪些变化。

+ 就我个人而言，卡住的地方主要有三段
	+ 对BPM接口的功能的理解以及各个接口应该带来哪些数据结构怎样的变化，理清即可，从69到了91分，结论如下图：
		<img alt="BPM" src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Database-System/bpm.jpg" width = "90%">

	+ 一个类似`unique_ptr`功能类的实现，说来惭愧，之前并没有实现过移动相关标准函数，有了一个乌龙，比如我在移动构造的开始也调用`Drop`了，因为里面有检测，所以这句应该没有发挥作用，但是这里本来就是为了构造`this`，不可能需要`Drop`，然后还有就是在移动拷贝需要check下不能自己移动向自己，我这里没有check，所以会出现pin count错误的问题，但是这玩意不应该在编译器就error的嘛？不知道线上的测试样例是什么样子的。

	+ 最后就是死锁，即`FetchPageWrite`/`FetchPageRead`不能使用函数锁，是先锁住拿到页实例指针，然后就释放BPM的锁，然后再获取页实例的latch，否则就会死锁，这个是看前辈的攻略才对的。比如这样的样例，比如一个线程持有一个page latch，另一个线程通过bpm去fetch同样的页，就在加页锁的时候等待了，而第一个也调用bpm的方法，就死锁了。其实纳入这个想法，我的实现应该还有锅，或者说有的锁可以省略，这些也添加到上面的图里了，但是代码还没有改，而且有锅的地方也通过了测试，可能和测试样例中BPM的用法有关，具体的改bug和调优后面再说了。

## What is BPM?

+ Reference：
	+ [腾讯云【MySQL系列】深入浅出Buffer Pool](https://cloud.tencent.com/developer/article/2114126)
	+ [PolarDB 数据库内核月报 2023/08 MySQL · 源码分析 · 庖丁解 InnoDB 之 Buffer Pool](http://mysql.taobao.org/monthly/2023/08/01/)
 
# Project2

主要是对B+Tree的实现，我个人算法实现依照教材《DataBase System Concepts 7th》，下面是对教材中相关内容的简单翻译和整理，个人建议一定要理清伪代码的逻辑，而且教材和Bustub的实现中结点格式是不一样的，一定要定量的理清里面的关系。我基本相当于一遍过的，因为这里卡了两小下一个是对教材中 $swap\_variables$ 的含义理解错了，另一个是写代码有一行代码复制粘贴了两份。

同时我的实现也很直觉简单，因为Bustub提供的上下文类Content就有树的Header Page Write Guard，这相当于一个可以锁住整个树的写锁了，相当于我直接用的一个大锁，什么螃蟹锁，乐观锁，悲观锁啥的都没用。

+ B Plus Tree首先是一种Balanced Tree
+ B Plus Tree有两种node类型
	+ noleaf node/internal node：
		+ 非root的internal node的child数量在 $\lceil \frac{n}{2} \rceil$ 和 $n$ 之间（闭区间）
		+ root的child数量在 $2$ 和 $n$ 之间
	+ leaf node：
		+ “child”数量在 $\lceil \frac{n - 1}{2} \rceil$ （相当于 $\lfloor \frac{n}{2} \rfloor$ ）和 $n - 1$ 之间（闭区间）
			>leaf node的child就是recored

	我理解这里的最小数量也并不神秘，只要保证一个刚刚好溢出的node被尽可能均分后两个页可能的最小值。

	上面的描述是符合Bustub中的B+Tree的，当然对应node的n使用对应node类型的max size，值得一提的是internal node中第一个invalid键和其对应的值作为的键值对也包含在size里。

+ 对于每个node（无论是internal还是leaf），设其max size为n，则其包含`n - 1`个key，`n`个pointer，如下：  
	<img alt="B+Tree Node Content" src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Database-System/B_Plus_Tree-node.png" width = "80%">

	+ 其中`K`严格单调递增（暂时不讨论相同Key）
	+ 在Internal node中
		+ pointer为childern node pointer
		+ 对于一个node pointer $P_{i}$ ，其指向的node的所有的key都满足，大于等于 $K_{i - 1}$，小于 $K_{i}$，即左闭右开区间。
	+ 在leaf node中
		+ 前`n -1`为正常的键值对，最后一个pointer不与任何键匹配（从图里发现），它指向的是其右边第一个叶子结点。

---

+ 联系：
	+ 我们知道了为什么internal node最多有n个child，而leaf node却最多有n - 1个“child”，这是因为即使是同样的n，并且确实使用同样的格式，但是leaf node的最后一个pointer有特殊的用法，所以不能用来指向child
	+ 上面的设计也是合理的，因为这`n - 1`个key和`n`个pointer在不同结点表达的语义不同
		+ internal node：将值域通过`n - 1`个key划分成`n`个左闭右开区间
		+ leaf node：前`n - 1`个`<pointer, key>`对形成键值对。

+ 实现：上面的定义和在Bustub的实现还是有挺大的Gap的
	+ internal：
		+ Bustub对键值对的存储使用`std::pair<KeyType, ValueType> array_[]`，至少我对其最直觉的想象是`key[0], pointer[0], key[1], pointer[1], key[2], ...`的序列，然后还要求`key[0]`是invalid的，所以序列变成`pointer[0], key[1], pointer[1], key[2], ..., key[size - 1], pointer[size - 1]`，但是我们发现教材上的序列相当于`pointer[1], key[1], pointer[2], ..., key[n - 1], pointer[n - 1], pointer[n]`，这里索引对不上（我指的是Bustub中是第一个pointer单独一组，然后后面的一key一pointer一组，而教材中是第一个pointer和第一个key一组），即两者虽然pointer和key的先后顺序一致，但是具体的对应关系不一致。我本来有一个trick的做法，但是Bustub给我提供了图形化相关的辅助函数，还必须按照上面的方式写。我这里是忽略这里的“成对”的关系，把握“分割”这个性质即可，对应的点也会注释在下面的伪代码中。
	+ leaf：
		+ Bustub使用的是索引从0开始到`size - 1`的`pair`线性表，而有特殊作用的pointer使用额外的数据成员表示，这也解释了为什么leaf的内容数量最多到`leaf_max_size - 1`，是从概念出发的。

## Queries

+ 单点查询key的recored：函数`find`，伪代码如下：
	```Pascal
	function find(v)
	// Assumes no duplicate keys, 
	// and returns pointer to the record with search key value v if such a record exists,
	// and null otherwise.
		// 这里没有讨论树为空
		Set C = root node
		while (C is not a leaf node) begin
			Let i = smallest number such that v <= C.K[i]
			if there is not such number i then begin  // 即v大于C中所有的键
				Let P_m = last non-null pointer in the node  // 因为最后的一个pointer表示的child node的key大于等于结点的最后把一个key
			// 上面可行还是根据最后一个P是独立的, 即没有对应的K(看图), 但是在Bustub就使用最后一个键值对的值
				Set C = P_m
			end
			else if (v == C.K[i]) then Set C = C.P[i + 1]  // 因为区间是左闭右开嘛, 所以如果和边界相等, 应该是右边的
			else Set C = C.P[i]  // v < C.K[i]
			// 上面两句在Bustuh中的实现应该是不同的
		end
		// C is a leaf node
		if for some i, K[i] == v
			then return P[i]
			else return null;  // No record with key value v exists
		end
	```

+ range queries区间查询：函数`findRange`，伪代码如下：
	```Pascal
	function findRange(lb, ub)  // Return all records with search key value V such that lb <= V <= ub(闭区间)
		Set resultSet = {};
		Set C = root node
		while (C is not a leaf node) begin
			Let i = smallest number such taht lb <= C.K[i]
			if there is no such number i then begin
				Let P_m = last non-null pointer in the node
				Set C = P_m
			end
			else if (lb == C.K[i]) then Set C = C.P[i + 1]
			else Set C = C.P[i]  // lb < C.K[i]
		end
		// 上面代码思路和单点查询一致, 值得一提的是区间内的recored是C的一部分
		// C (must) be leaf node
		Let i be the least value such that K[i] >= lb  // i是C中大于等于左区间点的第一个键的索引
		if there is no such i
			then Set i = 1 + number of keys in C;  // To force move to next leaf
			// 此时i为指向下一个叶子结点的P的索引
			// 主要key的数量是n - 1, 此时其number + 1就是索引n
		Set done = false;
		while (not done) begin
			Let n = number of keys in C.
			// 如果上面的force move执行了, 则下面的分支不会进入, 再次强调leaf node中key的数量是n - 1
			if (i <= n and C.K[i] <= ub) then begin
				Add C.P[i] to resultSet
				Set i = i + 1
			end
			else if (i <= n and C.K[i] > ub)
				then Set done = true;
			// 别忘了这里的n是key number, 而key number是教材中的n - 1，所以下面没问题
			else if (i > n and C.P[n + 1] is not null)
				then Set C = C.P[i + 1] and i = 1  // Move to next leaf
			else Set done = true;  // No more leaves to the right
		end
		return resultSet
	```

## Updates

对B Plus Tree的Updates可以be modeled as先删除再插入，所以只考虑插入和删除两个操作。而这两个操作涉及node的split和coalese/combine。

### Insert

```pascal
procedure insert(value K, pointer P)
// 在树种插入键值对<K, P>
// 注意这里P是一种抽象, 既可以是recored的pointer, 也可以是其他node的pointer, 这样的优势在下面会体现出来
	if (tree is empty) create an empty leaf node L, which is alse the root
	else Find the leaf node L that should contain key value K
	// 检测是否有重复键, 教材是假设输入没有重复
	if (L has less than n - 1 key values)  // leaf node最多有n - 1个键值对
		then insert_in_leaf(L, K, P)       // 位置充足, 直接插入
		else begin  // L has n - 1 key values already, split it
			Create (new leaf) node L_
			Copy L.P[1], ..., L.K[n - 1] to a block of memory T that can hold n pairs
			insert_in_leaf(T, K, P)

			Set L_.P[n] = L.P[n];
			Set L.P[n] = L_
			
			Erase L.P[1] through L.K[n - 1] from L
			Copy T.P[1] through T.K[std::ceil(n / 2)] from T into L starting at L.P[1]        // std::ceil(n / 2)个
			Copy T.P[std::ceil(n / 2) + 1] through T.K[n] from T into L_ starting at L_.P[1]  //。 std::floor(n / 2)个
			Let K_ be the smallest key in L_  // 左闭右开区间, 所以划分两个结点的应该是右节点的最小键
			insert_in_parent(L, K_, L_)
		end

// function insert_in_leaf caller must ensure L hava space to store <K, P>
procedure insert_in_leaf(node L, value K, pointer P)  // L: leaf node, K: key, P: recored pointer
	// 教材没有检测L为空, 其实也不需要, 因为如果没有键则会在下面的循环中没有结果, 看实现吧
	if (K < L.K[1])
		then insert P, K into L just before L.P[1]
		else begin
			Let K[i] be the highest value in L that is less than or equal to K
			Insert P, K into L just after L.K[i]
		end

procedure insert_in_parent(node N, value K_, node N_)
	// N和N_会成为两个兄弟, 其中N本来就在B+Tree上, N_是在格外的空间创建, 他们的边界是K_, 它是N_的最小值, 左闭右开!
	if (N is the root of the tree)
		then begin
			Create a new (internal) node R containing N, K_, N_
			// textbook:               p[1] = N, k[1] = K_, p[2] = N_
			// Bustub: k[0] = INVALUE, p[0] = N, k[1] = K_, p[1] = N_
			Make R the root of the tree
			return
		end
	Let P = parent(N)
	if (P has less than n pointers)
		then insert(K_, N_) in P just after N  // 这里不是递归调用上面的procedure insert, 而是表示一个动作, 且这个动作是无递归的
		else begin  // Split P
			Copy P to a block of memory T that can hold P and <K_, N_>
			Insert(K_, N_) into T just after N  // 同上, 表示动作而非调用
			Erase all entries from P; 
			Create node P_

			Copy T.P[1], ..., T.P[std::ceil((n + 1) / 2)] into P
			Let K__ = T.K[std::ceil((n + 1) / 2)]
			Copy T.P[std::ceil((n + 1) / 2) + 1], ..., T.P[n + 1] into P_

			// P size : std::ceil((n + 1) / 2) > std::ceil(n / 2)
			// P_ size: std::floor((n + 1) / 2) == std::ceil(n / 2)
			// 注意这里的K__的选择, 它选择的是P的中的key么?不是, 反而是P_中的键?为什么
			// P[1], K[1], P[2], K[2], ..., P[bound] | K[bound], P[bound + 1], ... P[n + 1]
			// 同时类似leaf split, 我们看一下教材和Bustub的差异
// textbook:       P[1], K[1], P[2], K[2], ..., K[bound - 1], P[bound]     | K[bound]          , P[bound + 1], ... P[n + 1]
// Bustub:   K[0], P[0], K[1], P[1], K[2], ..., K[buoud - 1], P[bound - 1] | K[bound] = INVALUE, P[bound], ...,    P[n]
// 这里Bustub反而好实现, 即copy 0 ~ bound - 1键值对即可
			// 在Bustub中的实现要注意上面的问题

			insert_in_parent(P, K__, P_)  // 递归向上
		end
```

### Delete

删除确实要比插入复杂些，因为如果一个结点的键值对个数不能半满，就需要和sibling兄弟coalesce合并，但是兄弟可能键值对比较多，两者键值对个数加起来又超过一个结点能容纳的量，就需要redistribute
```pascal
procedure delete(value K, pointer P)
	// 树是否空?
	find the leaf node L that contains (K, P)
	// 键值对是否在该叶子中?
	// Bustub中Remove方法的参数只有一个K, 所有我这里只检测值是否存在
	delete_entry(L, K, P)  // 叶子, 键, 值

procedure delete_entry(node N, value K, pointer P)
	// 参数分别是当前结点, 可以是internal也可以是leaf, 但是其实从一开始这个结点就是确定的(废话)
	// 参数P在下面的代码中只在找sibling时需要
	delete(K, P) from N  // 同上, 表示动作而非调用, 我们已经在Delete的入口检测该键值对是否存在了
	
	if (N is the root and N has only one remaining child)  // leaf和internal都可以是根, 但是只有internal可能有孩子
	then make the child of N the new root of the tree and delete N
	else if (N has too few value/pointer) then begin  // 数量低于下限, 注意internal是孩子, leaf是键值对个数, 而是还有一个特殊的种类, 根, 根的下限是二
	// 整个代码块只有两个分支
	// -> 有一个儿子的根
	// -> 不足
	// 对于leaf
	//   是根: 任意键值对个数
	//   不是根: 不能低于下限
	// 对于internal:
	//   是根: 只有1个孩子, 特判; 有两个及以上儿子, 符合根的下限
	//   不是根, 不能低于下限
		Let N_ be the previous or next child of parent(N)
		Let K_ be the value between pointers N and N_ in parent(N)
		if (entries in N and N_ can fit in a single node)
			then begin  // coalesce nodes
				if (N is a predecessor of N_) then swap_variables(N, N_)
				// 注意!, 这里可以看下教材, swap_variables是指交换N和N_的指针, 即下文中两者互换了, 而不是交换内容
				// 即期望: N_ N
				// 所有都移动到左边N_
				if (N is not a leaf) then append K_ and all pointers and value in N to N_
				else append all(K[i], P[i]) pairs in N to N_; set N_.P[n] = N.P[n]
				delete_entry(parent(N), K_, N);
				delete node N
			end
		else begin  // Redistribution: borrow an entry from N_
		// 进入该分支条件: 不足半满, 且相邻两个不能放在一个, 而自己是刚好不足半满, 兄弟一定超过半满, 而不能合在一起, 所以肯定多的给少的一个, 多的那个也是满足半满的
			if (N_ is a predecessor of N) then begin  // 左右意味着多少, 我觉得没法用一份代码表示
			// N_和N的结点类型应该相同, 只是下面以N的类型表示
			// 注意下面都是从N_从拿一个放N中, 而不是按方向放的, 方向的意义是间隔的位置
				if (N is a nonleaf node) then begin  // internal
					let m be such that N_.P[m] is the last pointer in N_
					remove(N_.K[m - 1], N_.P[m]) from N_
					// 这里的数值关系结合上面的图, 总之就是去掉左边的最后一个“边界”
					insert(N_.P[m], K_) as the first pointer and value in N, by shifting other pointers and value right
					replace K_ in parent(N) by N_.K[m - 1]
				// 注意上面, 还是由于internal的键值的对应关系, 删除最后一个键和值, 然后插入的就值和一个新键
				// 我们看这个新键来自Parent的N_和N的间隔K_, 而删除的是N_.K[m - 1], 可以保证N_.K[m - 1] < K_, 
				// 所有原本是N_.K[m - 1]在左儿子, 然后K_在parnet, 现在将K_换到右儿子, N_.K[m - 1]换到Parent, 合理
				// 这里推荐画画图, 也挺好用的
				end
				else begin
					let m be such that (N_.P[m], N_.K[m]) is the last pointer/value pair in N_
					remove (N_.P[m], N_.K[m]) from N_
					insert(N_.P[m], N_.K[m]) as the first pointer and value in N, by shifting other pointers and values rigth
					replace K_ in parent(N) by N_.K[m]
				// 键的转换关系同上
					// 我们看一下如果镜像时候是什么样, 仅仅把握左闭右开区间即可
				end
			end
			else ...symmetric to the then case...
		end
	end
	// 我们可以想象else还有什么情况, 比如叶子是根, 然后pair个数到1
```

## What is B+Tree

+ Reference：
	+ [MySQL · 引擎特性 · B+树并发控制机制的前世今生](http://mysql.taobao.org/monthly/2018/09/01/)

# Project3

![bustub-project-structure](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Database-System/bustub-project-structure.svg)