我做的是2023Spring

## Project1

+ 就我个人而言，卡住的地方主要有三段
	+ 对BPM接口的理解已经各个接口应该带来哪些数据结构的变化，理清即可，从69到了91分
	+ 一个类似`unique_ptr`功能类的实现，说来惭愧，之前并没有实现过移动相关标准函数，有了一个乌龙，比如我在移动构造的开始也调用`Drop`了，因为里面有检测，所以这句应该没有发挥作用，但是这里就是为了构造`this`，不可能需要`Drop`，然后还有就是在移动拷贝需要check下不能自己移动向自己，我这里没有check，所以会出现pin count错误的问题，但是这玩意不应该在编译器就error的嘛？不知道线上的测试样例是什么样子的。
	+ 最后就是死锁，即`FetchPageWrite`/`FetchPageRead`不能使用函数锁，是先锁住拿到页实例指针，然后就释放BPM的锁，然后在获取页实例的latch，否则就会死锁，这个是看前辈的攻略才对的。比如这样的样例，比如一个样例持有一个锁，另一个线程通过bpm去fetch同样的页，就在加页锁的时候等待了，而第一个也调用bpm的方法，就死锁了。

下面是我自己画的接口带来的数据结构变化的逻辑图，其实也挺费解的，因为是我对接口理解到一定程度后的总结，解说就不一定有了
![bpm](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Database-System/bpm.jpg)


主要用于数据库底层的内存管理，包括控制 Page 的进出，分配多大的内存空间。这部分逻辑和内存的管理独立于传统意义上的 OS Caching Mechanism，是为了数据库能有比 OS 更加全面的内存管理机制而实现的底层数据结构(Oracle / PostgreSQL 中均有用到)，最主要的是，在极端的 AP 情况下，没有缓存池支持的数据库，非常容易发生 OOM (Out Of Memory) 的问题。