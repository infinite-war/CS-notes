./Linux/Linux_net_API.md:  int socket(int domain, int type, int protocol);
./Linux/Linux_net_API.md:     int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
./Linux/Linux_net_API.md:     int listen(int sockfd, int backlog);
./Linux/Linux_net_API.md:     int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
./Linux/Linux_net_API.md:   int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen);
./Linux/Linux_net_API.md:   int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
./Linux/Linux_net_API.md:   int main(int argc, char* argv[]) {
./Linux/Linux_net_API.md:     int WSACleanup(void);
./Linux/Linux_net_API.md:  SOCKER socket(int af, int type, int protocol);
./Linux/Linux_net_API.md:     int bind(SOCKET s, const struct sockaddr * name, int namelen);
./Linux/Linux_net_API.md:     int listen(SOCKET s, int backlog);
./Linux/Linux_net_API.md:     SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen);
./Linux/Linux_net_API.md:   int connect(SOCKET s, const struct sockaddr *name, int namelen);
./Linux/Linux_net_API.md:  int open(const char *path, int flag);
./Linux/Linux_net_API.md:  int close(int fd);
./Linux/Linux_net_API.md:  ssize_t write(int fd, const void * buf, size_t nbytes);
./Linux/Linux_net_API.md:  > + `size_t`是`unsigned int`类型
./Linux/Linux_net_API.md:  > + `ssize_t`是`signed int`类型
./Linux/Linux_net_API.md:  ssize_t read(int fd, void * buf, size_t nbytes);
./Linux/Linux_net_API.md:  int send(SOCKER s, const char* buf, int len, int flags);
./Linux/Linux_net_API.md:  int recv(SOCKET s, const char * buf, int len, int flags);
./Linux/Linux_net_API.md:  int closesocket(SOCKET s);
./Linux/Linux_net_API.md:int socket(int domain, int type, int protocol);
./Linux/Linux_net_API.md:  + IPv4协议族中面向连接的套接字`int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)` ipproto_tcp
./Linux/Linux_net_API.md:  + IPv4协议族中面向消息的套接字`int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_UDP)` 
./Linux/Linux_net_API.md:SOCKET socket(int af, int type, int portocol);
./Linux/Linux_net_API.md:int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
./Linux/Linux_net_API.md:      uint16_t sin_port;  // 16位TCP/UDP端口号
./Linux/Linux_net_API.md:    int_addr_t inet_addr(const char * string):
./Linux/shell.md:#### `printf`
./Linux/shell.md:格式：`printf format-string [arrguments...]`
./Linux/Linux_system_API.md:int pipe(int fd[2]);
./Linux/Linux_system_API.md:    write(fd[1], char*, int);
./Linux/Linux_system_API.md:    write(fd[0], char*, int);
./Linux/Linux_system_API.md:  int shmget(key_t key, size_t size, int shmflag);
./Linux/Linux_system_API.md:  void* chmat(int shmid, const void* shmaddr, int shmflag);
./Linux/Linux_system_API.md:  int shmdt(const void* shmaddr);
./Linux/GNU/gcc.md:#include <stdint.h>
./Linux/GNU/gcc.md:int8_t;
./Linux/GNU/gcc.md:int16_t;
./Computer-Network/4计网TCP层or运输层.md:  2. 每一条TCP连接只能有两个**端点**(endpoint)，每一条TCP连接只能是**点对点**的（一对一）
./Computer-Network/3计网IP层or网络层.md:+ 在TCP/TP体系中网络层常常被称为***网际层***(internet layer)，或IP层。
./Computer-Network/3计网IP层or网络层.md:+ 虚拟互连网络(internet)
./Computer-Network/3计网IP层or网络层.md:    1. 域内路由选择(interdomain routing)
./Computer-Network/3计网IP层or网络层.md:    2. 域间路由选择(intradomain routing)
./Computer-Network/2计网数据链路层.md:> 现使用点对点协议PPP(Point-to-Point Protocol)：用户计算机和ISP进行进行通信时使用的数据链路层协议。
./Computer-Network/0计网概论.md:  > + internet（互连网）是一个通用名词，它泛指由多个计算机互连而成的计算机网络。网络之间的通信协议是可以任意选择。
./Computer-Network/0计网概论.md:  + 服务访问点SAP(Service Access Point)：同一系统相邻实体进行交互的地方。本质是逻辑接口
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:+ 在栈中，变量的地址并不是“连续”的，存在**内存对齐**，比如我使用的x64位的计算机，一次可读取8个字节，这个时候，如果连续存储，可能出现一个int（4位），不够我读，一个char（1位）后的long long（8位），可能需要读两次再舍掉一部分，于是干脆一个变量以一次所能读取的字节数划分，速度更快
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:1. 其实暴力是好写的：`int get(int n, int d) { for (int ans = n; ; ++ n) if (ans % d == 0) return ans; }`
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:    int a = 1
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:+ 攻坚克难：`#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )`
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:>       for (unsigned int i = sizeof(T) * 8 - 1; i > 0; -- i)
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:>       * 2. sizeof返回值是unsigned int的，所以i也是unsigned int 的
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:>       int op = 0;
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:>       for (unsigned int i = sizeof(T) * 8 - 1; i > 0; -- i)
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:  #define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:      printf(#n " sizeof : %d\n", sizeof(n)); \
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:      printf(#n " sizeof(int) - 1 : %d\n", sizeof(int) - 1); \
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:      cout << vr(sizeof(int) - 1) << endl; \
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:      cout << vr((sizeof(n) + sizeof(int) - 1)) << endl; \
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:      printf(#n " ~(sizeof(int) - 1) : %d\n", ~(sizeof(int) - 1)); \
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:      cout << vr(~(sizeof(int) - 1)) << endl; \
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:      printf(#n " _INTSIZEOF(n) %d\n", _INTSIZEOF(n)); \
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:  则`int get(int n, int d) { return (n + d - 1) & ~(d - 1); }`
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:  	int n = x;
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:   debug<int>{1, 2, 3};
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:有这样的函数：`inline int read() { int x; scanf("%d"; &x); return x; } `
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:const int N = 3;
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:struct point {
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:void foo(point a, point b) {
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:    printf("%p\n%p\n", &a, &b);
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:int main() {
./blog/unorganized/zweix技术日记2022.04.08-关于C++函数参数入栈顺序和内存对齐.md:    foo(point(), point());
./Database-System/0数据库基础.md:2. 内模式（internal schema）：也称存储模式（storage），一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。
./Database-System/0数据库基础.md:     + 交(intersection)：|$\cap$ 合成新表
./Database-System/0数据库基础.md:  + 交(intersection)：关系$R$与关系$S$的交记作$R \cap S = \{t|t \in R \land t \notin S\}$其结果关系仍为$n$目关系，由既属于$R$又属于$S$的元组组成。
./Database-System/0数据库基础.md:关系模型中有三类完整性约束：实体完整性(entity integrity)、参照完整性(referential integrity)和用户定义的完整性(user-defined integrity)；前两者是必须的，被称为*关系的两个不变性*
./Database-System/3数据库并发.md:  + 保留点(savepoint)：指事务处理设置的临时占位符(placeholder)，可对其发布回退
./Math/Cryptology/密码学1密码学基础.md:  + 明文(plaintext/cleartext) $x$：
./Math/Cryptology/密码学1密码学基础.md:> int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
./Math/Cryptology/密码学1密码学基础.md:> void get(int n) {
./Math/Cryptology/密码学1密码学基础.md:> 	printf("%d : \n", n);
./Math/Cryptology/密码学1密码学基础.md:> 	for (int i = 0; i < n; ++ i) if (gcd(n, i) == 1) {
./Math/Cryptology/密码学1密码学基础.md:> 		vector<int> vis(n, 0);
./Math/Cryptology/密码学1密码学基础.md:> 		int res = 0;
./Math/Cryptology/密码学1密码学基础.md:> 		for (int t = i; ! vis[t]; t = (t * i) % n) ++ res, vis[t] = 1;
./Math/Cryptology/密码学1密码学基础.md:> 		printf("\tord(%d) = %d\n", i, res);
./Distributed-System/Introduction.md:    *   并发Concurrency带来的复杂性。many concurrent parts, complex interactions
./Complier/yacc&lex.md:  int main() {
./Complier/yacc&lex.md:  	yylex(); /*flex扫描器，使用匹配模式进行匹配，返回int*/
./Complier/yacc&lex.md:    + 历史原因flex在读取到EOF时需要调用`yywrap()`（`int yywrap() { return -1; }`），现使用`%option noyywrap`关闭
./Complier/yacc&lex.md:  | `yylex()` | Scanner入口，返回记号流（int）                               |
./Complier/yacc&lex.md:    for (int i = 1; i < argc; ++ i) {
./Complier/yacc&lex.md:    read x; { input an integer }
./Complier/yacc&lex.md:  int yylex(void);  //必须
./Complier/yacc&lex.md:      fprintf(stderr,"error:%s\n",str);
./Complier/yacc&lex.md:  int yywrap() { return 1; }
./Complier/yacc&lex.md:  int main() {
./Complier/yacc&lex.md:        atoi将yytext转换成int
./Complier/编译原理.md:    2. but an NFA can choose-an NFA can get into multiple states状态变成状态集合
./Complier/编译原理.md:        + Non-terminals at the interior nodes
./Complier/编译原理.md:    1. divide the productions into tow classes:enforces precedence of x over y
./Complier/编译原理.md:       3. 'Nearby' is not necessarily 'the intended' program
./Programing-Language/C++/4C++面向对象1封装-标准函数.md:      	int a;
./Programing-Language/C++/4C++面向对象1封装-标准函数.md:          int &b;
./Programing-Language/C++/4C++面向对象1封装-标准函数.md:          const int c;
./Programing-Language/C++/4C++面向对象1封装-标准函数.md:          ClassName(int a_, string s,int b_, int c_) : str(s), b(b_), c(c) { a = a_; }
./Programing-Language/C++/3C++语法.md:+ 顺序点(sequence point)：是程序执行过程中的一个点，在这里，进入下一步之前确保对所有的副作用都进行了评估
./Programing-Language/C++/3C++语法.md:  switch (integer-expression) {
./Programing-Language/C++/3C++语法.md:  + integer-expression必须是一个结果为整数值的表达式，
./Programing-Language/C++/3C++语法.md:    每个label（标签）必须是整数常量表达式：int、char、枚举量。且不能相同
./Programing-Language/C++/3C++语法.md:  + 语法：`int main() {}`：返回是告知OS程序运行情况，常用int，默认返回0（正常），若其他则异常
./Programing-Language/C++/3C++语法.md:  + 参数：`int main(int argc, char *argv[]) {}`：其中argc为argv长度（默认设置），argv[0]为程序名（参数从1开始）
./Programing-Language/C++/3C++语法.md:         type fName(const type *beg, const int *end) {}
./Programing-Language/C++/1C++概述.md:+ 随机数：ANSI C库提供`rand()`函数（头文件`cstdlib`）：返回0到某个值（取决于实现）之间的随机整数，他将一种算法用于一个初始中种子值来获得随机数（默认为0），并将随机值用于下一次函数调用的种子。因为随机算法是固定的，如果起始值是一样的，则生成的随机数是一样的（伪随机数），所以初始化种子要“随机化”，我们使用`time(0)`（头文件`ctime`）初始化种子，使随机更随机`srand(time(0));`  `int x = rand();`
./Programing-Language/C++/2C++数据3动态内存.md:2. `delete`：销毁对象、释放内存，参数是指针指向空间的第一个元素，空间回收但指针变量还在，成为dangling pointer空悬指针
./Programing-Language/C++/2C++数据3动态内存.md:> C++11的SL提供几种smart pointer智能指针来更容易、安全的管理动态对象
./Programing-Language/C++/现代C++.md:  int main() {
./Programing-Language/C++/C++库SL(C++11).md:  string类将`string::npos`定义为字符串的最大值，通常是`unsigned int`的最大值
./Programing-Language/C++/C++库SL(C++11).md:    语法：`int width()`返回字段宽度的当前设置；`int width(int i);`将字段宽度设置为i个宽度，并返回以前的字段宽度。
./Programing-Language/C++/C++库SL(C++11).md:    成员函数`precesion(int)`：总位数；影响范围：一直有效到更改
./Programing-Language/C++/C++库SL(C++11).md:         | `ios_base::shwopoint` | 显示末尾的小数点                      |
./Programing-Language/C++/C++库SL(C++11).md:         |                         | `ios_base::internal`   | 符号或计数前缀左对齐 |
./Programing-Language/C++/C++库SL(C++11).md:  2. 命令行：主函数参数`int main(int argc, char * argv[])`：argc为命令行字符串个数，argv为命令行该行的所有字符串，通常argv[0]是程序名
./Programing-Language/C++/C++库SL(C++11).md:int get(void);
./Programing-Language/C++/C++库SL(C++11).md:| 原型     | `istream & get(char *, int, char)`<br>`istream & get(char *, int)` | `istream & getline(har *, int, char)`<br/>`istream & getline(char *, int)` |
./Programing-Language/C++/C++库SL(C++11).md:3. `istream & ignore(int = 1, int = EOF);`：读取到最大字符数或文件末尾
./Programing-Language/C++/4C++面向对象1封装.md:             int maxx(int a, int b) { return a > b ? a : b; }
./Programing-Language/C++/4C++面向对象1封装.md:             int maxx(int a, int b);
./Programing-Language/C++/4C++面向对象1封装.md:         inline int ClassName::max(int a, int b) { return a > b ? a : b; }
./Programing-Language/C++/4C++面向对象1封装.md:        int sam;
./Programing-Language/C++/4C++面向对象1封装.md:int main() {
./Programing-Language/C++/4C++面向对象1封装.md:     `static const int N = 2e5 + 7;`类内使用直接使用`N`，类外使用限定名`ClassName::N`
./Programing-Language/C++/4C++面向对象1封装.md:+ 关于递增递减运算符：前置参数为空，后置参数为`int`，合理：因为前置this就是参数，后置才需要占位符
./Programing-Language/C++/4C++面向对象1封装.md:      ClassName(int a, double b = 1.0);
./Programing-Language/C++/4C++面向对象1封装.md:     `ClassName(int a); dvxdName = 1;`可以`dvxdName = 1.0`也可以
./Programing-Language/C++/4C++面向对象1封装.md:     `ClassName(int a); ClassName(double); dvxdName = 1.0`不可以。
./Programing-Language/C++/4C++面向对象1封装.md:        > 比如`operator int(); operator double();`时，`int a = dvxd;`允许，但是`cout << dvxd;`不允许，因为不知道对象是转换为int还是double。如果只有一个转换函数则可以。同时，对于上边的例子，`long a = dvxd;`也是不允许的。
./Programing-Language/C++/4C++面向对象1封装.md:     > int的转换是四舍五入，不是截断。
./Programing-Language/C++/4C++面向对象1封装.md:        ClassName::operator int() { return int (数据成员 + 0.5); }
./Programing-Language/C++/4C++面向对象1封装.md:        int ClassName::ClassName_to_Int() { return int (数据成员 + 0.5); }
./Programing-Language/C++/4C++面向对象1封装.md:        int sam = dvxd;  //就是非法的
./Programing-Language/C++/4C++面向对象1封装.md:        int sam = dvxd.ClassName_to_Int();
./Programing-Language/C++/4C++面向对象2继承.md:        int num;
./Programing-Language/C++/4C++面向对象2继承.md:        baseClass(int num_) { num = num_; }
./Programing-Language/C++/4C++面向对象2继承.md:        int num;
./Programing-Language/C++/4C++面向对象2继承.md:        drivedClass(int a, int b) : baseClass(b) { num = a; }				//调用基类的构造函数
./Programing-Language/C++/4C++面向对象2继承.md:        drivedClass(int a, const baseClass & b) : baseClass(b) { num = a;} 	   //调用基类的复制构造函数
./Programing-Language/C++/2C++数据4RTTI.md:2. delete：释放空间：参数指针指向的空间回收但是指针本身还在（空悬指针dangling pointer），对空指针是安全的
./Programing-Language/C++/2C++数据4RTTI.md:> C++11的SL提供2种smart pointer智能指针来更容易、安全的管理动态对象
./Programing-Language/C++/2C++数据4RTTI.md:  + 使用`make_shared<>()`函数是定义智能指针的好方法：`auto p = make_shared<int>(7);`
./Programing-Language/C++/5C++泛型.md:    `template <typename T, int n>;` n接受一个int型的参数，在模板中，n是接受的int型值的别称。
./Programing-Language/C++/5C++泛型.md:     `typedef std::array<int, 2e5 + 7> arrN;`
./Programing-Language/C++/5C++泛型.md:     模板别名<int> sam;  //sam是 mobjName<int, 123>的实例对象。
./Programing-Language/C++/5C++泛型.md:  	int a = 1, b = 2;
./Programing-Language/C++/5C++泛型.md:      swap<int>(a, b);  //显式实例化
./Programing-Language/C++/5C++泛型.md:    + `template <class T1, classT2> class ClassName {};`使用`template <class T1> class ClassName<T1, int> {};`来部分具体化，也可以是其他部分。注意如果全部具象化，类名前的部分尖括号就空了成现实具体化了。
./Programing-Language/C++/5C++泛型.md:    void show(ClassName<int> & a) {};
./Programing-Language/C++/5C++泛型.md:  ostream &print(ostream &os, const T &t) {
./Programing-Language/C++/5C++泛型.md:  ostream &print(ostream &os, const T &t, const Args&... rest) {  // 这里有类型参数包的扩展
./Programing-Language/C++/5C++泛型.md:  	return print(os, rest...);  // 这里是参数包的扩展
./Programing-Language/C++/C++库STL.md:+ 迭代器范围(iterator range)：由一对迭代器表示，分别指向同一个容器中的元素和尾元素之后的位置(one past the last element)——begin、end/first、last（会有歧义）——左闭合区间(left-inclusive interval)：$[begin, end)$
./Programing-Language/C++/C++库STL.md:    + 算术运算操作数是int：跳跃
./Programing-Language/C++/C++库STL.md:  for (int i = 1; i <= 9; ++ i) *it = i; //vec = {1..9}
./Programing-Language/C++/C++库STL.md:  istream_iterator<int> in_iter(cin), eof;
./Programing-Language/C++/C++库STL.md:  vector<int> vec(in_iter, eof);//2
./Programing-Language/C++/C++库STL.md:  cout << accumulate(istream_iterator<int>(cin),
./Programing-Language/C++/C++库STL.md:                     istream_iterator<int>( ), 
./Programing-Language/Rust/Grammer.md:+ interger整型：
./Programing-Language/Rust/Grammer.md:+ floating-point number浮点型：
./Programing-Language/Rust/Grammer.md:      println!("three");
./Programing-Language/Rust/Grammer.md:      println!("State quarter from {:?}!", state);
./Programing-Language/Rust/Grammer.md:>   > 在堆上allocating分配内存：memory allocator内存分配器 在堆的某处找到一块足够大的空间且标记并返回该地址的point指针
./Programing-Language/Rust/Grammer.md:> 类似其他语言的interfaces接口
./Programing-Language/Python/lib.md:    print(file + " is not exists")
./Programing-Language/Python/lib.md:print(res)
./Programing-Language/Python/Spider.md:    | `readinto(), getheaders(), getheader(name), fileno()` |              |
./Programing-Language/Python/Spider.md:    print(response.read().decode('utf-8'))
./Programing-Language/Python/grammar.md:  > 本质是Python解释器的交互模式——REPL(read-eval-print loop, 读取、求值、输出的循环)。
./Programing-Language/Python/grammar.md:+ `print()`：输出字符串（值也是字符串，但是不能直接拼接，需要`str(number)`将其转换为字符串）：自动添加回车
./Programing-Language/Python/grammar.md:  + 格式化字符串：`"内容%d内容%f内容"%int,float" `：对应关系如C，记得中间的%
./Programing-Language/Python/grammar.md:  + 不自动添加回车：`print(..., end = '')`
./Programing-Language/Python/grammar.md:  + `int(字符串)`：返回对应数字类型
./Programing-Language/Python/grammar.md:  + `random.radint(范围l, 范围r)`：返回随机数
./Programing-Language/Python/numpy-pandas-matplotlib.md:  + 整型：`int_、int8、int16、int32、int64`
./Programing-Language/Python/numpy-pandas-matplotlib.md:  + 无符号整型：`uint8、uint16、uint32、uint64`
./Programing-Language/Python/numpy-pandas-matplotlib.md:    + `trunc`（向0取整——截断）、`round`==`rint`（四舍六入五变偶）、`ceil`（向上取整）、`floor`（向下取整）
./Programing-Language/Python/numpy-pandas-matplotlib.md:  randint  # 给定形状区间内的随机数
./Programing-Language/C/C.md:   > + Macintosh（Mac）
./Programing-Language/C/C.md:  > #define int_ int *
./Programing-Language/C/C.md:  > int_ a, b, c;  //相当于int * a, b, c;这是只有a是指针，b和c是普通变量
./Programing-Language/C/C.md:  > typedef int* int_;
./Programing-Language/C/C.md:  > int_ a, b, c;  //int_就是声明指向int的指针，所以a，b，c都是指针
./Programing-Language/C/C.md:     + 无论是unsigned还是signed的char和short自动转换成int（有必要还会转换成unsigned int）。
./Programing-Language/C/C.md:+ 有附属关键字修饰的情况下基本整数类型int可省略。
./Programing-Language/C/C.md:| **`int`**       | 有符号               | 基本整数类型                   |
./Programing-Language/C/C.md:| **`short`**     | 不多于int，有符号    | 附属关键字（修饰基本整数类型） |
./Programing-Language/C/C.md:| **`long`**      | 不少于int，有符号    | 附属关键字（修饰基本整数类型） |
./Programing-Language/C/C.md:> 并不是short和long的大小是根据int确定的，实际上是int的大小被前两者限制。
./Programing-Language/C/C.md:| int            | 2 或 4 字节 |      | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
./Programing-Language/C/C.md:| unsigned int   | 2 或 4 字节 |      | 0 到 65,535 或 0 到 4,294,967,295                    |
./Programing-Language/C/C.md:+ 可移植类型：`stdint.h` 和 `inttypes.h`
./Programing-Language/C/C.md:  + 精确宽度整数类型 ：`int32_t`（32位有符号整数类型）
./Programing-Language/C/C.md:  + 最小宽度类型：`int_least8_t`（可容纳8位有符号整数值的类型中宽度最小的类型）
./Programing-Language/C/C.md:  + 最快最小宽度类型 ege：`int_fast8_t`（系统8位有符号值最快的整数类型的别名）
./Programing-Language/C/C.md:  + 最大整数类型：有符号`intmax_t`（可以储存任何有效的有符号整数位）、无符号`uintmax_t`。
./Programing-Language/C/C.md:  2. *指定初始化器*：`int arrays[] = { [下标] = 值, ……};` 。
./Programing-Language/C/C.md:+ 函数原型：`int sum(int r, int c, int arr[r][c]) {}`是允许的；数组实参传递的仍然是指针，可修改。
./Programing-Language/C/C.md:  `int sum(int * a) {}` 
./Programing-Language/C/C.md:  `int sum(int a[]) {}` 只能用于形式参数；提示不仅是指针，还是数组。
./Programing-Language/C/C.md:  另外，如果为了避免错误修改原数组：`int sum(const int a[]) {}` ，这里const关键字告诉编译器。
./Programing-Language/C/C.md:    对于ege：`int arr[x][y];`	//x, y表示具体的大于0的整数，这里为了广义的解释
./Programing-Language/C/C.md:    + `arr`是该数组首元素地址，但首元素是内含$y$个`int`元素的数组，所以`arr`是内含$y$个值的数组的地址。
./Programing-Language/C/C.md:    + `arr == &arr[0], arr[0] == &arr[0][0]` 但`arr`是$x$个`int`数组的首地址，`arr[0]`是$y$个`int`变量的首地址。
./Programing-Language/C/C.md:      对前者来说，$1$相当于$y$个`int`的地址和，都后者来说，$1$相当于$1$个`int`的地址和。
./Programing-Language/C/C.md:    对于上边的例子，应为` int (* pd)[y]; pd = arr;` 这里，`pd`是指向$y$个`int`值的指针（指向一块大地址的指针）
./Programing-Language/C/C.md:    不可以`int ** pd; pd = arr` ：`pd`是指向指针的指针，两者不一样。
./Programing-Language/C/C.md:  + 传递参数时除第一维之外的大小必须确定：`int (* pd)[y]` or `int pd[][y]` ，同样，第一维可以写，不过会被忽略，行数只能另外传递。
./Programing-Language/C/C.md:  + `printf("%s", sam);`
./Programing-Language/C/C.md:   	int num;
./Programing-Language/C/C.md:       int a[];
./Programing-Language/C/C.md:   pt = malloc(sizeof(struct sam) + n * sizeof(int));
./Programing-Language/C/C.md:  ​			但利用指针记录地址也是一个用法 `int * pd; pd = (int [2]) { 123, 456};`
./Programing-Language/C/C.md:     ​				`for (int n = 1; n < 3; n ++) { int n = 4; n ++; }`
./Programing-Language/C/C.md:      + `const int * pd = arr;` `pd`可以修改，但不能通过`pd`修改数组，而数组可以修改
./Programing-Language/C/C.md:      + `int * const pd = arr;` 此时pd不能指向其他地址。但可以修改地址的值
./Programing-Language/C/C.md:        即`const int * pd = arr` 与 `int const * pd = arr` 等价
./Programing-Language/C/C.md:        当然，也可以都限制`const int * const pd = arr;` 。
./Programing-Language/C/C.md:    int a[10];
./Programing-Language/C/C.md:  int * pa = a;
./Programing-Language/C/C.md:    for (int i = 1; i <= n; i ++) {
./Programing-Language/C/C.md:   >   再比如，调用`printf()` 函数，调用才是目的，打印只是“副作用”。
./Programing-Language/C/C.md:       `int MASK = num;` 将控制的位设置为1，其余为0.
./Programing-Language/C/C.md:  3. 位字段：是一个signed int 或 unsigned int 类型变量中的一组相邻的位（C99和C11新增了_Bool类型的位字段）。
./Programing-Language/C/C.md:     + 总位数不能超多unsigned int类型的大小；
./Programing-Language/C/C.md:       否则，会到下一个unsigned int类型的存储位置，一个字段不允许跨越两个unint之间的边界；编译器会自动移动跨界的字段，保持unint的边界对其，一旦发生这种情况，第一个unint中会会留下一个未命名的”洞“；可以使用未命名的字段宽度”填充“未命名的”洞“，再使用一个宽度为0的未命名字段迫使下一个字段与下一个整数对齐
./Programing-Language/C/C.md:       	unsigned int field1 : 1;
./Programing-Language/C/C.md:           unsigned int		: 2;
./Programing-Language/C/C.md:           unsigned int field2 : 1;
./Programing-Language/C/C.md:           unsigned int		: 0;
./Programing-Language/C/C.md:           unsigned int field3 : 1;
./Programing-Language/C/C.md:     + 字段存储在一个int的顺序取决的预计的实现。——位字段不易移植。
./Programing-Language/C/C.md:    再比如，调用`printf()` 函数，调用才是目的，打印只是“副作用”。
./Programing-Language/C/C.md:            #define PRINTF(x) printf("xxx%d", x);
./Programing-Language/C/C.md:            #define PRINTF(x) printf("xxx%d", ((x)*(x));
./Programing-Language/C/C.md:        #define PRINTF(x) printf("#xxx%d", ((x)*(x));
./Programing-Language/C/C.md:     ege:`#define PR(...) printf(__VA_ARGS__)` 使用时，利用字符串的串联功能和#运算符。
./Programing-Language/C/C.md:     int main() {
./Programing-Language/C/C.md:         printf("");
./Programing-Language/C/C.md:         printf("");
./Programing-Language/C/C.md:+ 主函数的返回类型：主函数必须要返回`int`类型，无返回值（`void`）并非所有编译器都支持
./Programing-Language/C/C.md:    程序主函数写法`int main(int argc, char *argv[])`或`int main(int argc, char **argv)`。
./Programing-Language/C/C.md:  + `printf(格式字符串,  待打印项1, 待打印项2, ……);`
./Programing-Language/C/C.md:  | int                  | %d（其他附属关键字作其前缀）                |
./Programing-Language/C/C.md:  | *         | `printf("%*d", width, num);` <br>后接两个变量，第一个控制宽度，第二个为输出的值 |
./Programing-Language/C/C.md:  + `printf()` 输出：把输出发送到*缓冲区*（中间存储区域），然后（当缓冲区满、遇到换行字符或者需要输入时）从缓冲区不断发送到屏幕或文件（刷新缓冲区）。另一种刷新缓冲区的方法是使用`fflush()`函数。
./Programing-Language/C/C.md:  + printf（）
./Programing-Language/C/C.md:    + 程序控制printf根据转换说明从栈中读取值
./Programing-Language/C/C.md:  + `printf()` 输出：返回打印字符的个数。
./Programing-Language/C/C.md:  + `printf()` 输出：
./Programing-Language/C/C.md:| 函数     | `scanf("%c", )`<br>                       | `printf()`   |
./Programing-Language/C/C.md:     int main(int argc, char *argv[]) {
./Programing-Language/C/C.md:     	int ch;
./Programing-Language/C/C.md:     		printf("Usage: %s filename\n", argv[0]);
./Programing-Language/C/C.md:             printf("Can't open %s\n", argv[1]);
./Programing-Language/C/C.md:3. 这两个函数与scanf（）和printf（）类似，区别在于前者需要用第一个参数指定待处理的文件
./Programing-Language/C/C.md:   + `fprintf()`
./Programing-Language/C/C.md:     返回：int类型的值
./Programing-Language/C/C.md:   + `fgetpos()`函数：`int fgetpos(FILE *stream, fpos_t * restruct pos)`
./Programing-Language/C/C.md:   + `fsetpos()`函数：`int fsetpos(FILE *stream, const fpos_t *pos)`
./Programing-Language/C/C.md:| 函数                                 | `scanf("%s", str);`以下一个空白字符作为字符串的结束<br>`scanf("%nums", str);`（指定宽度），则终止条件加上到长度。<br>不指定宽度也会有外溢的风险 | `printf("%s", 字符串地址);`<br>显示字符串                    |
./Programing-Language/C/C.md:  char * s_gets(char * st, int n) {
./Programing-Language/C/C.md:      int i = 0;
./Programing-Language/C/C.md:| int strlen(const char * str)                                 | 返回长度                                                     |
./Programing-Language/C/C.md:| char * strncat(char * str1, const char * str2, int len)      | strcat不能检测第一个参数长度是否足够，第三个参数指定最大添加字符数 |
./Programing-Language/C/C.md:| int strcmp(const char * str1, const char * str2)             | 返回按机器排序序列的差值（第一个参数减去第二个参数）         |
./Programing-Language/C/C.md:| int strncmp(……, ……, int seat)                                | 只比较第seat个参数的位置                                     |
./Programing-Language/C/C.md:| char *strncpy(char * str1, const char * str2, int len)       | strcpy不能检测空间是否足够<br />第三个参数指定最大长度，至结尾或最大长度时停止<br />如果到最大长度时停止，则目标字符串不含空字符，所以要人工添加 |
./Programing-Language/C/C.md:| sprintf(目标字符串地址，格式字符串，待写入项的列表) | 把多个元素组合一个字符串 |
./Programing-Language/C/C.md:       int n = 5, m = 6;
./Programing-Language/C/C.md:       int ar2[n][m];  //
./Programing-Language/C/C.md:       int (* p2)[6];  //
./Programing-Language/C/C.md:       int (* p3)[m];  //
./Programing-Language/C/C.md:       p2 = (int (*)[6]) malloc(n * 6 * sizeof(int));  //
./Programing-Language/C/C.md:       p3 = (int (*)[m]) malloc(n * m * sizeof(int));  //
./Programing-Language/Golang/基本语法.md:    func add(x int, y int) int {
./Programing-Language/Golang/基本语法.md:    func add(x, y int) int {
./Programing-Language/Golang/基本语法.md:    int  int8  int16  int32  int64
./Programing-Language/Golang/基本语法.md:    uint uint8 uint16 uint32 uint64 uintptr
./Programing-Language/Golang/基本语法.md:    byte // uint8 的别名
./Programing-Language/Golang/基本语法.md:    rune // int32 的别名
./Programing-Language/Golang/基本语法.md:    *   `int, uint, uintptr`大小跟随系统，同系统宽度
./Programing-Language/Golang/基本语法.md:        `byte`的本质是`uint8`，即一个字节，为了适配ASCII  
./Programing-Language/Golang/基本语法.md:        `rune`的本质是`int32`，即四个字节，为了对应Unicode  
./Programing-Language/Golang/基本语法.md:        +   字符常量`'c'`是int32，即可以有中文字符（这在C/C++这种以ASCII为基本编码的语言中是不可以的）  
./Programing-Language/Golang/基本语法.md:        +   对于一个string类型的变量，使用`[]`运算符通过得到是`uint`，即中文不能这样访问  
./Programing-Language/Golang/基本语法.md:            但for each中的每个value就是一个Unicode码点，即`int32`类型，可以直接输出中文
./Programing-Language/Golang/基本语法.md:    var a, b, c int
./Programing-Language/Golang/基本语法.md:    var i, j int = 1, 2
./Programing-Language/Golang/基本语法.md:var i int = 1
./Programing-Language/Golang/基本语法.md:var p *int = &i      // 重定向
./Programing-Language/Golang/基本语法.md:type Point struct {
./Programing-Language/Golang/基本语法.md:    X, Y int
./Programing-Language/Golang/基本语法.md:point = Point{1, 2}
./Programing-Language/Golang/基本语法.md:point.X  // 结构体字段
./Programing-Language/Golang/基本语法.md:    point1 = Point{1, 2}
./Programing-Language/Golang/基本语法.md:    point2 = Point{X: 1}  // point2.Y init 0
./Programing-Language/Golang/基本语法.md:    point3 = Point{}
./Programing-Language/Golang/基本语法.md:    p = &Point{}  // 直接创造结构体指针
./Programing-Language/Golang/基本语法.md:var a [10]int
./Programing-Language/Golang/基本语法.md:    *   复制操作：`func copy(dst, src []T) int`
./Programing-Language/Golang/基本语法.md:    fmt.Println(v.Abs())
./Programing-Language/Golang/基本语法.md:type 接口名 interface {
./Programing-Language/Golang/基本语法.md:*   空接口`interface{}`，是一个类型
./Programing-Language/Golang/基本语法.md:	+ fmt：定义接口`Stringer`，很多print都使用该接口作为参数，可以实现方法来用字符串描述自己的类型
./Programing-Language/Golang/基本语法.md:		type Stringer interface {
./Programing-Language/Golang/基本语法.md:		type error interface {
./Programing-Language/Golang/lib/http.md:type Handler interface {
./Programing-Language/Golang/lib/http.md:*   `http.RedirectHandler(url string, code int) Handler`：跳转
./Programing-Language/Golang/lib/http.md:    > type FileSystem interface {
./Programing-Language/Golang/lib/http.md:            RawPath     string    // encoded path hint (see EscapedPath method)
./Programing-Language/Golang/lib/http.md:            RawFragment string    // encoded fragment hint (see EscapedFragment method)
./Programing-Language/Golang/lib/http.md:        type ReadCloser interface {
./Programing-Language/Golang/lib/http.md:            Reader  // a interface
./Programing-Language/Golang/lib/http.md:            Closer  // a interface too
./Programing-Language/Golang/lib/http.md:        type Reader interface {
./Programing-Language/Golang/lib/http.md:            Read(p []byte) (n int, err error)
./Programing-Language/Golang/lib/http.md:        type Closer interface {
./Programing-Language/Golang/lib/http.md:            // print(string(body))
./Programing-Language/Golang/lib/http.md:+   方法`WriteHeader(HTTP状态码 int)`：作为HTTP响应的状态码
./Programing-Language/Golang/lib/misc.md:	fmt.Println(strings.Join(os.Args[1:], " "))
./Programing-Language/Golang/lib/misc.md:            ID     int    `json:"id"`
./Programing-Language/Golang/lib/misc.md:	+ `map[string]interface`存储任意JSON对象
./Programing-Language/Golang/lib/misc.md:	+ `[]interface{}`存储任意的Json数组
./Algorithm/Template.md:const int MOD = 1e9 + 7;
./Algorithm/Template.md:int fpow(int d, ill n, int mod) {
./Algorithm/Template.md:    int res = 1 % mod; d %= mod;  // mod可能等于1吗?
./Algorithm/Template.md:  vector<int> operator + (vector<int> &A, vector<int> &B) {
./Algorithm/Template.md:      vector<int> C;
./Algorithm/Template.md:      int t = 0;
./Algorithm/Template.md:      for (int i = 0; i < (int)A.size(); i ++ ) {
./Algorithm/Template.md:          if (i < (int)B.size()) t += B[i];
./Algorithm/Template.md:  vector<int> operator - (vector<int> &A, vector<int> &B) {
./Algorithm/Template.md:      vector<int> C;
./Algorithm/Template.md:      for (int i = 0, t = 0; i < A.size(); i ++ ) {
./Algorithm/Template.md:  vector<int> mul(vector<int> &A, int b) {
./Algorithm/Template.md:      vector<int> C;
./Algorithm/Template.md:      int t = 0;
./Algorithm/Template.md:      for (int i = 0; i < A.size() || t; i ++ ) {
./Algorithm/Template.md:  vector<int> div(vector<int> &A, int b, int &r) {
./Algorithm/Template.md:      vector<int> C;
./Algorithm/Template.md:      for (int i = A.size() - 1; i >= 0; i -- ) {
./Algorithm/Template.md:typedef pair<int, int> pii;
./Algorithm/Template.md:    int st = -2e9, ed = -2e9;
./Algorithm/Template.md:  const int BEGIN = 0;  // 离散后的整数的起始大小
./Algorithm/Template.md:  void discretize(T *a, int l, int r) {
./Algorithm/Template.md:      for (int i = l; i <= r; ++ i) dct.push_back(a[i]);
./Algorithm/Template.md:      for (int i = l; i <= r; ++ i)
./Algorithm/经典题目.md:ill work(int a[], int n) {  // 索引1 ~ n
./Algorithm/经典题目.md:    for (int i = 1; i <= n; ++ i) pre[i] = pre[i - 1] + a[i];
./Algorithm/经典题目.md:    c[1] = 0; for (int i = 2; i <= n; ++ i) c[i] = pre[i - 1] - (i - 1) * avg;
./Algorithm/经典题目.md:    for (int i = 1; i <= n; ++ i) res += abs(c[n + 1 >> 1] - c[i]);
./Algorithm/经典题目.md:const int dx[]  = {-1, 0, 1, 0};
./Algorithm/经典题目.md:const int dy[]  = {0, 1, 0, -1};
./Algorithm/经典题目.md:int f(string& str) {  //评估函数，使用曼哈顿距离
./Algorithm/经典题目.md:    int res = 0;
./Algorithm/经典题目.md:    for (int i = 0; i < 9; ++ i) if (str[i] != 'x') {
./Algorithm/经典题目.md:        int x = i, y = str[i] - 48 - 1;
./Algorithm/经典题目.md:unordered_map<string, int> dis;                  //记录状态的初始距离
./Algorithm/经典题目.md:    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> heap;
./Algorithm/经典题目.md:        int dist = dis[source];
./Algorithm/经典题目.md:        int x, y;  //空格位置
./Algorithm/经典题目.md:        for (int i = 0; i < 9; ++ i) if (source[i] == 'x') {
./Algorithm/经典题目.md:        for (int xx, yy, i = 0; i < 4; ++ i) {
./Algorithm/经典题目.md:int pj() {    
./Algorithm/经典题目.md:    int sum = 0;
./Algorithm/经典题目.md:    for (int i = 0; i < 9; ++ i) if (st[i] != 'x') {
./Algorithm/经典题目.md:        for (int j = i + 1; j < 9; ++ j) if (st[j] != 'x') {
./Algorithm/经典题目.md:int main() {   
./Algorithm/经典题目.md:    for (int i = 1; i <= 9; ++ i) {
./Algorithm/经典题目.md:const int N = 2000 + 7;
./Algorithm/经典题目.md:const int M = 1e6 + 7;
./Algorithm/经典题目.md:const int INF = 0x3f3f3f3f;
./Algorithm/经典题目.md:int n, m;
./Algorithm/经典题目.md:int a[N], b[N], c[N], d[N];
./Algorithm/经典题目.md:int f[M];
./Algorithm/经典题目.md:int main() {
./Algorithm/经典题目.md:	for (int i = 1; i <= n; ++ i) scanf("%d%d", &a[i], &b[i]);
./Algorithm/经典题目.md:	for (int i = 1; i <= m; ++ i) scanf("%d%d", &c[i], &d[i]);
./Algorithm/经典题目.md:	for (int i = 1; i <= n; ++ i) for (int j = 1; j <= m; ++ j) {
./Algorithm/经典题目.md:	int ans = INF, maxn = 0;
./Algorithm/经典题目.md:	for (int i = M - 1; i >= 0; -- i) {
./Algorithm/经典题目.md:	printf("%d\n", ans);
./Algorithm/String/字符串2后缀数组和后缀自动机.md:	int n, m;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:    int sa[N], rk[N], height[N];
./Algorithm/String/字符串2后缀数组和后缀自动机.md:    int x[N], y[N], c[N];  // 两个关键字和桶
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        for (int i = 1; i <= n; ++ i) c[x[i] = s[i]] ++;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        for (int i = 2; i <= m; ++ i) c[i] += c[i - 1];
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        for (int i = n; i >= 1; -- i) sa[c[x[i]] --] = i;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        for (int k = 1; k <= n; k <<= 1) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            int cnt = 0;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            for (int i = n - k + 1; i <= n; ++ i) y[++ cnt] = i;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            for (int i = 1; i <= n; ++ i) if (sa[i] > k) y[++ cnt] = sa[i] - k;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            for (int i = 1; i <= m; ++ i) c[i] = 0;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            for (int i = 1; i <= n; ++ i) c[x[i]] ++;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            for (int i = 2; i <= m; ++ i) c[i] += c[i - 1];
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            for (int i = n; i >= 1; -- i) sa[c[x[y[i]]] --] = y[i], y[i] = 0;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            for (int i = 2; i <= n; ++ i)
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        for (int i = 1; i <= n; ++ i) rk[sa[i]] = i;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        for (int i = 1, k = 0; i <= n; ++ i) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            int j = sa[rk[i] - 1];
./Algorithm/String/字符串2后缀数组和后缀自动机.md:	int sz[N << 1];  // 和SAM中的结点索引对应，表示结点i代表的endpos集合中元素的个数，在extend中特判前缀初始化为1
./Algorithm/String/字符串2后缀数组和后缀自动机.md:    int tot, last;  // tot表示SAM结点个数，last与构造算法有关
./Algorithm/String/字符串2后缀数组和后缀自动机.md:		int max_len;  // 结点所表示的所有子串的最长子串的长度
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        int fa;  // 特殊边
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        int to[26];   // 普通边  // 这里默认是字母
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        int endi;  // 表示这一系列有公共后缀的子串的最后一个字符（一定在一个位置）在原串中的位置 
./Algorithm/String/字符串2后缀数组和后缀自动机.md:        for (int i = 1; str[i]; ++ i) extend(str[i] - 'a', i);  // 这里默认是字母
./Algorithm/String/字符串2后缀数组和后缀自动机.md:	void extend(int c, int id) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:		int p = last, np = last = ++ tot;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:            int q = node[p].to[c];
./Algorithm/String/字符串2后缀数组和后缀自动机.md:                int nq = ++ tot;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:	vector<int> g[N << 1];
./Algorithm/String/字符串2后缀数组和后缀自动机.md:    int dfs(int node) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:		for (int i = 2; i <= tot; ++ i) g[node[i].fa].push_back(i);
./Algorithm/String/字符串2后缀数组和后缀自动机.md:vector<int> g[N << 1];
./Algorithm/String/字符串2后缀数组和后缀自动机.md:int dfs(int node) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:    for (int i = 2; i <= sam.tot; ++ i) add(sam.node[i].fa, i);
./Algorithm/String/字符串2后缀数组和后缀自动机.md:for (int i = sam.txt; i >= 1; -- i) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:    int node = i, fa = sam.node[node].fa;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:int node = i, father = sam.node[i].fa;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:  int ans[N << 1], maxn[N << 1];  // ans表示所有串在状态i的匹配最大长度，maxn是处理的当前串的
./Algorithm/String/字符串2后缀数组和后缀自动机.md:  void dfs(int node) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:      for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:  int solve() {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:      for (int i = 1; i <= sam.tot; ++ i) ans[i] = sam.node[i].max_len;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:      for (int i = 2; i <= sam.tot; ++ i) add(sam.node[i].fa, i);
./Algorithm/String/字符串2后缀数组和后缀自动机.md:          int x = 1, t = 0;
./Algorithm/String/字符串2后缀数组和后缀自动机.md:          for (int j = 1; str[j]; ++ j) {
./Algorithm/String/字符串2后缀数组和后缀自动机.md:              int c = str[j] - 'a';
./Algorithm/String/字符串2后缀数组和后缀自动机.md:          for (int j = 1; j <= sam.tot; ++ j) ans[j] = min(ans[j], maxn[j]);
./Algorithm/String/字符串3回文串相关算法.md:    char s[N]; int n;  // 原字符串 
./Algorithm/String/字符串3回文串相关算法.md:    int ch[N][26], fail[N], len[N], sz;  // PAM基本信息, 以索引为统一指标
./Algorithm/String/字符串3回文串相关算法.md:    int node;  // 辅助变量, 数据结构外可将其认为是PAM的最后结点(在线维护)
./Algorithm/String/字符串3回文串相关算法.md:    int cnt[N];  // 额外信息: 结点表示的回文串在原串出现的次数 
./Algorithm/String/字符串3回文串相关算法.md:    int getnew(int l) {
./Algorithm/String/字符串3回文串相关算法.md:    int getfail(int x) {
./Algorithm/String/字符串3回文串相关算法.md:        int x = getfail(node);
./Algorithm/String/字符串3回文串相关算法.md:        	int y = getnew(len[x] + 2);
./Algorithm/String/字符串3回文串相关算法.md:    	for (int i = sz; i >= 0; -- i) cnt[fail[i]] += cnt[i];
./Algorithm/String/字符串3回文串相关算法.md:  cs int N=1e5+5;
./Algorithm/String/字符串3回文串相关算法.md:  	char s[N<<1];int l=N,r=N-1,llast,rlast;
./Algorithm/String/字符串3回文串相关算法.md:  	int son[N][26],len[N],fa[N],now;
./Algorithm/String/字符串3回文串相关算法.md:  	int dep[N];ll ans;
./Algorithm/String/字符串3回文串相关算法.md:  		for(int re i=l;i<=r;++i)s[i]='\0';
./Algorithm/String/字符串3回文串相关算法.md:  		for(int re i=0;i<=now;++i){
./Algorithm/String/字符串3回文串相关算法.md:  		int p=rlast;
./Algorithm/String/字符串3回文串相关算法.md:  			int k=fa[p];
./Algorithm/String/字符串3回文串相关算法.md:  		int p=llast;
./Algorithm/String/字符串3回文串相关算法.md:  			int k=fa[p];
./Algorithm/String/字符串3回文串相关算法.md:  	int T;
./Algorithm/String/字符串3回文串相关算法.md:  			int t;
./Algorithm/String/字符串3回文串相关算法.md:  template<int alpha>
./Algorithm/String/字符串3回文串相关算法.md:  		int len;
./Algorithm/String/字符串3回文串相关算法.md:  		int rightmost_occurence, second_rightmost_occurence;
./Algorithm/String/字符串3回文串相关算法.md:  		int fail_cnt;
./Algorithm/String/字符串3回文串相关算法.md:  		void UpdateOccurence(int occurence)
./Algorithm/String/字符串3回文串相关算法.md:  	int node_cnt;
./Algorithm/String/字符串3回文串相关算法.md:  	Node* NewNode(int len = 0)
./Algorithm/String/字符串3回文串相关算法.md:  	int start;
./Algorithm/String/字符串3回文串相关算法.md:  	std::vector<int> data;
./Algorithm/String/字符串3回文串相关算法.md:  	int size;
./Algorithm/String/字符串3回文串相关算法.md:  	Node* GetFail(Node* it, int pos)
./Algorithm/String/字符串3回文串相关算法.md:  	Node* Push(int x)
./Algorithm/String/字符串3回文串相关算法.md:  		int pos = data.size();
./Algorithm/String/字符串3回文串相关算法.md:  		int occurence = pos - cur->len + 1;
./Algorithm/String/字符串3回文串相关算法.md:  		assert(start < (int)data.size());
./Algorithm/String/字符串3回文串相关算法.md:  		if (longest_prefix_palindrome->len == (int)data.size() - start)
./Algorithm/String/字符串3回文串相关算法.md:  		if (start != (int)data.size() - 1)
./Algorithm/String/字符串3回文串相关算法.md:  			int occurence = start + longest_prefix_palindrome->len - it->len;
./Algorithm/String/字符串3回文串相关算法.md:  			int x = data[start];
./Algorithm/String/字符串3回文串相关算法.md:  	int NumOfPalindromes()
./Algorithm/String/字符串3回文串相关算法.md:  	int q;
./Algorithm/String/字符串3回文串相关算法.md:  	constexpr int alpha = 26;
./Algorithm/String/字符串3回文串相关算法.md:  int main()
./Algorithm/String/字符串0Trie树.md:      int n = s.size();
./Algorithm/String/字符串0Trie树.md:      int i = 0, j = 1;
./Algorithm/String/字符串0Trie树.md:          int k = 0;
./Algorithm/String/字符串0Trie树.md:      return ts.substr((int)min(i, j), n);
./Algorithm/String/字符串0Trie树.md:    int trie[MAXN][26], cnt[MAXN], idx;  // MAXN = 字符串的个数 * 字符串长度 * 26
./Algorithm/String/字符串0Trie树.md:        int node = 0;
./Algorithm/String/字符串0Trie树.md:            int son = c - 'a';
./Algorithm/String/字符串0Trie树.md:    int query(string &str) {
./Algorithm/String/字符串0Trie树.md:        int node = 0;
./Algorithm/String/字符串0Trie树.md:            int son = c - 'a';
./Algorithm/String/字符串0Trie树.md:    int trie[MAXN * D][2], val[MAXN * D], idx;  // MAXN = 数的个数 * 2, D为数的二进制表示长度
./Algorithm/String/字符串0Trie树.md:    void insert(int x, int id) {  // 数和这个数在集合中的索引
./Algorithm/String/字符串0Trie树.md:        int node = 0;
./Algorithm/String/字符串0Trie树.md:        for (int son, i = D; i >= 0; -- i) {
./Algorithm/String/字符串0Trie树.md:    pair<int, int> get(int x) {  // 输入一个数，返回这个数在Trie维护的数集的最大异或值和对应的数的索引
./Algorithm/String/字符串0Trie树.md:        int node = 0, res = 0;
./Algorithm/String/字符串0Trie树.md:        for (int son, i = D; i >= 0; -- i) {
./Algorithm/String/字符串最小表示法和杂项.md:      int n = s.size();
./Algorithm/String/字符串最小表示法和杂项.md:      int i = 0, j = 1;
./Algorithm/String/字符串最小表示法和杂项.md:          int k = 0;
./Algorithm/String/字符串最小表示法和杂项.md:      return ts.substr((int)min(i, j), n);
./Algorithm/String/字符串最小表示法和杂项.md:    int trie[MAXN][26], cnt[MAXN], idx;  // MAXN = 字符串的个数 * 字符串长度 * 26
./Algorithm/String/字符串最小表示法和杂项.md:        int node = 0;
./Algorithm/String/字符串最小表示法和杂项.md:            int son = c - 'a';
./Algorithm/String/字符串最小表示法和杂项.md:    int query(string &str) {
./Algorithm/String/字符串最小表示法和杂项.md:        int node = 0;
./Algorithm/String/字符串最小表示法和杂项.md:            int son = c - 'a';
./Algorithm/String/字符串最小表示法和杂项.md:    int trie[MAXN * D][2], val[MAXN * D], idx;  // MAXN = 数的个数 * 2, D为数的二进制表示长度
./Algorithm/String/字符串最小表示法和杂项.md:    void insert(int x, int id) {  // 数和这个数在集合中的索引
./Algorithm/String/字符串最小表示法和杂项.md:        int node = 0;
./Algorithm/String/字符串最小表示法和杂项.md:        for (int son, i = D; i >= 0; -- i) {
./Algorithm/String/字符串最小表示法和杂项.md:    pair<int, int> get(int x) {  // 输入一个数，返回这个数在Trie维护的数集的最大异或值和对应的数的索引
./Algorithm/String/字符串最小表示法和杂项.md:        int node = 0, res = 0;
./Algorithm/String/字符串最小表示法和杂项.md:        for (int son, i = D; i >= 0; -- i) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:		for (int i = 1; s[i]; ++ i) f[i] = (f[i - 1] * p % mod + (ull)s[i]) % mod;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    ull fpow(int n) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    ull get(int l, int r) { return (f[r] - f[l - 1] * fpow(r - l + 1) % mod) % mod; }
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   int head[N], lext[M], val[M], idx;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   void add(int x, int y) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   void insert(int x) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:       int k = (x % N + N) % N;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   bool find(int x) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:       int k = (x % N + N) % N;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:       for (int e = head[k]; e; e = lext[e]) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   const int MAXN = 10000007;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   int f[MAXN], id[MAXN];
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   ill get_hs(int x, int y) 
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   int find(int x, int y) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   	int key = (hs % MAXN + MAXN) % MAXN;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:   int key = find(data[i].x, data[i].y);
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    int n; char *p;  // 模式串存储在类外
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    int nfa[N];
./Algorithm/String/字符串1哈希KMP和AC自动机.md:		int k = 0;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        for (int i = 1; i < n; ++ i) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        int k = 0;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        for (int i = 0; s[i]; ++ i) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:      int n; char *p;  // 模式串存储在类外
./Algorithm/String/字符串1哈希KMP和AC自动机.md:      int nfa[N];
./Algorithm/String/字符串1哈希KMP和AC自动机.md:          for (int i = 2, j = 0; i <= n; ++ i) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:  		for (int i = 1, j = 0; s[i]; ++ i) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md://const int N = ;  // 模式串个数
./Algorithm/String/字符串1哈希KMP和AC自动机.md://const int M = ;  // 模式串长度
./Algorithm/String/字符串1哈希KMP和AC自动机.md://const int MAXN = ;  // 匹配串长
./Algorithm/String/字符串1哈希KMP和AC自动机.md:int trie[N * M][26], cnt[N * M], idx;  // 数组模拟结果体和指针，cnt表示这样的串有多少个
./Algorithm/String/字符串1哈希KMP和AC自动机.md:void insert(char *s, int st) {  // 索引从0开始
./Algorithm/String/字符串1哈希KMP和AC自动机.md:	int node = 0;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:	for (int son, i = st; s[i]; ++ i) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:int nfa[N * M];  // trie树上的自动机
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    queue<int> qu;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    for (int i = 0; i < 26; ++ i) if (trie[0][i]) qu.push(trie[0][i]);
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        int node = qu.front(); qu.pop();
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        for (int son, e = 0; e < 26; ++ e) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:            int j = nfa[node], i = e;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:int match(char *str, int st) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    int res = 0;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    for (int i, j = 0, _ = st; str[_]; ++ _) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        for (int t = j; t; t = nfa[t]) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md://const int N = ;  // 模式串个数
./Algorithm/String/字符串1哈希KMP和AC自动机.md://const int M = ;  // 模式串长度
./Algorithm/String/字符串1哈希KMP和AC自动机.md://const int MAXN = ;  // 匹配串长度
./Algorithm/String/字符串1哈希KMP和AC自动机.md:int trie[N * M][26], cnt[N * M], idx;  // 数组模拟结果体和指针，cnt表示这样的串有多少个
./Algorithm/String/字符串1哈希KMP和AC自动机.md:void insert(char *s, int st) {  // 索引从st开始
./Algorithm/String/字符串1哈希KMP和AC自动机.md:	int node = 0;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:	for (int son, i = st; s[i]; ++ i) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:int nfa[N * M];  // trie树上的自动机
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    queue<int> qu;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    for (int i = 0; i < 26; ++ i) if (trie[0][i]) qu.push(trie[0][i]);
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        int node = qu.front(); qu.pop();
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        for (int son, e = 0; e < 26; ++ e) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:int match(char *str, int st) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    int res = 0;
./Algorithm/String/字符串1哈希KMP和AC自动机.md:    for (int i, j = 0, _ = st; str[_]; ++ _) {
./Algorithm/String/字符串1哈希KMP和AC自动机.md:        for (int t = j; t; t = nfa[t]) {
./Algorithm/String/字符串Problem.md:int solve() {
./Algorithm/String/字符串Problem.md:    for (int i = 0; i < n; ++ i) {  // 这里是递推，本质是想要1~n
./Algorithm/String/字符串Problem.md:        for (int j = 0; j < kmp.n; ++ j) {  // j = m的状态不可取
./Algorithm/String/字符串Problem.md:                int u = j;
./Algorithm/String/字符串Problem.md:    int res = 0;
./Algorithm/String/字符串Problem.md:    for (int i = 0; i < kmp.n; ++ i) res = 1LL * (res + f[n][i]) % MOD;
./Algorithm/String/字符串Problem.md:int solve() {
./Algorithm/String/字符串Problem.md:    for (int i = 0; i < len; i ++ ) {
./Algorithm/String/字符串Problem.md:		for (int node = 0; node <= idx; node ++ ) {
./Algorithm/String/字符串Problem.md:            for (int son, e = 0; e < 4; e ++ ){
./Algorithm/String/字符串Problem.md:                int op = (get(str[i + 1]) != e);
./Algorithm/String/字符串Problem.md:    int res = INF;
./Algorithm/String/字符串Problem.md:    for (int i = 0; i <= idx; ++ i) res = min(res, f[len][i]);
./Algorithm/String/字符串Problem.md:    for (int j = 0; j < m; ++ j) {
./Algorithm/String/字符串Problem.md:            int k = j;
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   int fa[N];
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   for (int i = 1; i <= n; ++ i) fa[i] = i;
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   int fa[N], size[N];
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   for (int i = 1; i <= n; ++ i) fa[i] = i, size[i] = 1;
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   int p[N], d[N];  //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   for (int i = 1; i <= n; i ++ ) p[i] = i, d[i] = 0;
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:   int find(int x) {
./Algorithm/Senior-Data-Structure/高级数据结构_并查集.md:       	int u = find(p[x]);
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:void build(int k, int l, int r) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:int sg[N << 2];  // 一个独立的量表示线段树
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:void function(int k, int l, int r, int x, int y...) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    int l, r;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    int vl;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:void build(int k, int l, int r) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:void function(int k, int x, int y) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    vector<int> ag;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    SegTree(int n) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    void build(int k, int l, int r)...
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        int l, r;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:	Seg(int n) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    void build(int k, int l, int r) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        int mid = l + r >> 1;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    void pushup(int k) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    void pushdown(int k) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        int mid = vec[k].l + vec[k].r >> 1;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    void change_point(int k, int x, type val) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        int mid = vec[k].l + vec[k].r >> 1;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        if (x <= mid) change_point(lson, x, val);
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        else change_point(rson, x, val);
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    type query_point(int k, int x) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        int mid = vec[k].l + vec[k].r >> 1;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        if (x <= mid) return query_point(lson, x);
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        else return query_point(rson, x);
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    void change_section(int k, int x, int y, type val) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        int mid = vec[k].l + vec[k].r >> 1;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    type query_section(int k, int x, int y) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:        int mid = vec[k].l + vec[k].r >> 1;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md://const int M = ;  // 数位长度上限
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:int find0(int k, int seat) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:	int t = find0(k << 1, seat);  // 先找近的 
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:int find1(int k, int seat) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:	int t = find1(k << 1, seat);
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:int find_max(int k) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:void sub(int i) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:void add(int i) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md://const int MAXN = q * log(N);
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:int sum[MAXN], lson[MAXN], rson[MAXN], cnt;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:void pushup(int k) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:void change(int &k, int l, int r, int x, int val) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    int mid = l + r >> 1;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:type ask(int k, int l, int r, int x, int y) {
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    int mid = l + r >> 1;
./Algorithm/Senior-Data-Structure/高级数据结构_线段树.md:    int res = 0;
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:vector<int> g[N];  // 虚树  // 压入结点时清空
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:inline void add_new(int x, int y) { g[x].push_back(y); g[y].push_back(x); }
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int dfn[N], cnt;  // 预处理dfs序
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int a[N], k;  // 关键字序列，索引从1到k
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int st[N], tp;  // 由于要维护次大值，所以用数组模板单调栈
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:void build(int root = 1) {
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:    sort(a + 1, a + k + 1, [](int x, int y){ return dfn[x] < dfn[y]; } );
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:    for (int i = 1; i <= k; ++ i) if (a[i] != root) {
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:        int z = lca(a[i], st[tp]);
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:    for (int i = 1; i < top; ++ i) add(st[i], st[i + 1]);
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int fa[N];     //fa[node]表示node的父节点
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int dep[N];    //dep[node]表示node的深度
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int sz[N];     //sz[node]表示node的子树大小
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int dfn[N];    //dfn[node]表示node的dfs序
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int rnk[N];    //rnk[num]表示num这个dfs序对应的结点
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int cnt;
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int point[N];  //point[node]表示node的重儿子
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int top[N];    //top[node]表示node所在重链的顶端
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:void dfs1(int node) {
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:	point[node] = -1;
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:		if (point[node] == -1 || sz[son] > sz[point[node]]) point[node] = son;
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:void dfs2(int node, int tp) {
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:    if (point[node] == -1) return ;  // 叶子
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:    dfs2(point[node], tp);  // 优先进行重儿子
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:        if (son == point[node] || son == fa[node]) continue;
./Algorithm/Senior-Data-Structure/高级数据结构_树上结构.md:int lca(int x, int y) {
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:const int N = 1e5 + 7;
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:const int M = sqrt(N) + 7;
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:    int n, len;  // n序列长度 len块的个数
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:    int get(int i) { return i / len; }
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:    void init(int n, int *a) {
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:    	for (int i = 1; i <= n; ++ i) {
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:    void change(int l, int r, int d) {
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:            for (int i = l; i <= r; ++ i) w[i] += d, sum[get(i)] += d;
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:        int i = l, j = r;
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:        for (int k = get(i); k <= get(j); ++ k) sum[k] += len * d, lz[k] += d;
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:    ill query(int l, int r) {
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:            for (int i = l; i <= r; ++ i) res += w[i] + lz[get(i)];
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:        int i = l, j = r;
./Algorithm/Senior-Data-Structure/高级数据结构_从分块到莫队.md:        for (int k = get(i); k <= get(j); ++ k) res += sum[k];
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    int n;
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    inline int lowbit(int x) { return x & (-x); }
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    Fwt(int n_) : n(n_) { w.resize(n + 1, 0); }
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    void change(int x, int val) { for (; x <= n; x += lowbit(x)) w[x] += val; }
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    T query(int x) {
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    void change_section(int l, int r, int val) { change(l, val); change(r + 1, -val); }
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:int n, m, fwt[N][M];
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:void change(int x, int y, int val) {
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    for (int i = x; i <= n; i += lowbit(i))
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:        for (int j = y; j <= m; j += lowbit(j))  //这里双重循环，不能用参变量直接来了
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:int query(int x, int y) {
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    int res = 0;
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:    for (int i = x; i; i -= lowbit(i))
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:        for (int j = y; j; j -= lowbit(j))
./Algorithm/Senior-Data-Structure/高级数据结构_树状数组.md:int query(int lx, int ly, int rx, int ry) {
./Algorithm/Simple-Algorithm.md:  + 枚举子集：`for (int s = i; s; s = s - 1 & i)`
./Algorithm/Simple-Algorithm.md:    枚举真子集：`for (int s = i - 1 & i; s; s = s - 1 & i)`
./Algorithm/Simple-Algorithm.md:  vector<int> split(int n) {
./Algorithm/Simple-Algorithm.md:      vector<int> res;
./Algorithm/Simple-Algorithm.md:      for (int i = 1; i <= n; i <<= 1) {
./Algorithm/Simple-Algorithm.md:int l, r, ans = ;
./Algorithm/Simple-Algorithm.md:    int mid = l + r >> 1;
./Algorithm/Simple-Algorithm.md:const int N = ;
./Algorithm/Simple-Algorithm.md:const int LOG = ceil(log(N) / log(2)) + 1;
./Algorithm/Simple-Algorithm.md:int f[N][LOG];
./Algorithm/Simple-Algorithm.md:void ST_pre(int a[], int l, int r) {
./Algorithm/Simple-Algorithm.md:    for (int j = 0; j < LOG; ++ j) 
./Algorithm/Simple-Algorithm.md:        for (int i = l; i + (1 << j) - 1 <= r; ++ i) {
./Algorithm/Simple-Algorithm.md:int query(int l, int r) {
./Algorithm/Simple-Algorithm.md:    int len = r - l + 1;
./Algorithm/Simple-Algorithm.md:    int k = log(len) / log(2);
./Algorithm/Simple-Algorithm.md:    //lg2[N]; lg2[1] = 0; for (int i = 2; i < N; ++ i) lg2[i] = lg2[i >> 1] + 1;
./Algorithm/Simple-Algorithm.md:  for (int l = st, r; l <= ed; ++ l) {
./Algorithm/Simple-Algorithm.md:  for (int l = st, r = st; r <= ed; ++ r) {
./Algorithm/Simple-Algorithm.md:for (int i = 1; i <= n; ++ i) {
./Algorithm/Simple-Algorithm.md:+ 数组模拟：`int t = 0; ++ tt; tt > 0`
./Algorithm/Simple-Algorithm.md:for (int i = 0; i <= n; ++ i) {
./Algorithm/Simple-Algorithm.md:+ 数组模拟：`int hh = 0, tt = -1; ++ tt; hh <= tt`
./Algorithm/Simple-Algorithm.md:deque<int> win;
./Algorithm/Simple-Algorithm.md:for (int i = 1; i <= n; ++ i) {
./Algorithm/Simple-Algorithm.md:priority_queue<int> down;  //大根堆，堆顶最大，在下面
./Algorithm/Simple-Algorithm.md:priority_queue<int, vector<int>, greater<int> > up;  //小根堆，堆顶最小，在上面
./Algorithm/启发式合并.md:  int a[N];  //每个点的点权
./Algorithm/启发式合并.md:  int ans[N];  //记录每个子树的答案
./Algorithm/启发式合并.md:  int res, sum[N];  //维护的全局对象，res表示当前子树的答案，sum表示当前子树的信息
./Algorithm/启发式合并.md:  int tar;  //tar表示处理的当前子树的重儿子（当前子树的儿子的重儿子也要计算的）
./Algorithm/启发式合并.md:  void change(int node, int father, int val) {
./Algorithm/启发式合并.md:  void dfs(int node, int father, bool keep) {  //keep:当前子树的信息是否保留
./Algorithm/启发式合并.md:    for (int i = 0; i < N; ++ i) v[i] = rnd();  // v[i]表示用v[i]来表示i这个数字
./Algorithm/启发式合并.md:  int pre[N], dep[N];
./Algorithm/启发式合并.md:  map<pair<ill, ill>, int> mp[N];
./Algorithm/启发式合并.md:  void dfs(int node, int father) {
./Algorithm/启发式合并.md:  	for (int son : g[node]) {
./Algorithm/启发式合并.md:  void dfs(int node, int father) {
./Algorithm/启发式合并.md:      for (int son : g[node]) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:int cmp(double a, double b) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:struct Point {
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point operator - (const Point& t) const { return Point{x - t.x, y - t.y}; }
./Algorithm/Math/数学4计算几何_二维计算几何.md:    friend double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }
./Algorithm/Math/数学4计算几何_二维计算几何.md:    friend double area(const Point& a, const Point& b, const Point& c)  // a, b, c分别是三角形从左下逆时针的三个点
./Algorithm/Math/数学4计算几何_二维计算几何.md:    bool operator < (const Point& t) const {
./Algorithm/Math/数学4计算几何_二维计算几何.md:    friend double len(const Point& a, const Point& b) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:int n; Point point[N];  // 索引从1到n
./Algorithm/Math/数学4计算几何_二维计算几何.md:int st[N], top;  // 数组模拟栈, 最后栈中即为凸包上的点的索引(排序后的)(逆时针存储), 首尾都是起点
./Algorithm/Math/数学4计算几何_二维计算几何.md:    sort(point + 1, point + n + 1);
./Algorithm/Math/数学4计算几何_二维计算几何.md:    for (int i = 1; i <= n; ++ i) {  // 先求下凸包
./Algorithm/Math/数学4计算几何_二维计算几何.md:        while (top >= 2 && area(point[st[top - 1]], point[st[top]], point[i]) <= 0) { // 这里可以套一个sign
./Algorithm/Math/数学4计算几何_二维计算几何.md:            if (area(point[st[top - 1]], point[st[top]], point[i]) < 0) vis[st[top --]] = false;  // 边界特判
./Algorithm/Math/数学4计算几何_二维计算几何.md:    for (int i = n; i >= 1; -- i) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:        while (top >= 2 && area(point[st[top - 1]], point[st[top]], point[i]) <= 0) -- top;  //sign
./Algorithm/Math/数学4计算几何_二维计算几何.md:    if (st[top] == st[top - 1]) res = 2 * len(point[1], point[n]);  // 特判一条线的情况
./Algorithm/Math/数学4计算几何_二维计算几何.md:    else for (int i = 2; i <= top; ++ i) res += len(point[st[i - 1]], point[st[i]]);
./Algorithm/Math/数学4计算几何_二维计算几何.md:Point get_line_intersection(Point p, Point v, Point q, Point w) {  // 先确认两直线不平行或重合
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point u = p - q;
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point st, ed;
./Algorithm/Math/数学4计算几何_二维计算几何.md:    friend Point get_line_intersection(const Line& a, const Line& b) { 
./Algorithm/Math/数学4计算几何_二维计算几何.md:        return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st); 
./Algorithm/Math/数学4计算几何_二维计算几何.md:        auto o = get_line_intersection(a, b);
./Algorithm/Math/数学4计算几何_二维计算几何.md:Line line[N]; int cnt;
./Algorithm/Math/数学4计算几何_二维计算几何.md:int q[N];
./Algorithm/Math/数学4计算几何_二维计算几何.md:double half_plane_intersection() {
./Algorithm/Math/数学4计算几何_二维计算几何.md:    int hh = 0, tt = -1;
./Algorithm/Math/数学4计算几何_二维计算几何.md:    for (int i = 1; i <= cnt; ++ i) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:    vector<Point> vec;
./Algorithm/Math/数学4计算几何_二维计算几何.md:    for (int i = hh; i < tt; ++ i) vec.push_back(get_line_intersection(line[q[i]], line[q[i + 1]]));
./Algorithm/Math/数学4计算几何_二维计算几何.md:    for (int i = 1; i + 1 < vec.size(); ++ i) res += area(vec[0], vec[i], vec[i + 1]);
./Algorithm/Math/数学4计算几何_二维计算几何.md:const int N = 1e5 + 7;
./Algorithm/Math/数学4计算几何_二维计算几何.md:int sign(double x) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:int dcmp(double x, double y) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:struct Point {
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point operator + (const Point& t) const { return Point{x + t.x, y + t.y}; }
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point operator - (const Point& t) const { return Point{x - t.x, y - t.y}; }
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point operator * (double k) const { return Point{x * k, y * k}; }
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point operator / (double k) const { return Point{x / k, y / k}; }
./Algorithm/Math/数学4计算几何_二维计算几何.md:    friend double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point rotate(double angle) { return Point{x * cos(angle) + y * sin(angle), -x * sin(angle) + y * cos(angle)}; }  
./Algorithm/Math/数学4计算几何_二维计算几何.md:double len(const Point& a, const Point& b) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:Point get_line_intersection(Point p, Point v, Point q, Point w) {  // 先确认两直线不平行或重合
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point u = p - q;
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point p, v;
./Algorithm/Math/数学4计算几何_二维计算几何.md:Line get_midline(Point a, Point b) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:    return Line{Point{(a + b) / 2}, (b - a).rotate(PI / 2)};
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Point p; double r;
./Algorithm/Math/数学4计算几何_二维计算几何.md:Circle get_circle(Point a, Point b, Point c) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:    auto p = get_line_intersection(u.p, u.v, v.p, v.v);
./Algorithm/Math/数学4计算几何_二维计算几何.md:int n;
./Algorithm/Math/数学4计算几何_二维计算几何.md:Point point[N];
./Algorithm/Math/数学4计算几何_二维计算几何.md:    random_shuffle(point + 1, point + n + 1);
./Algorithm/Math/数学4计算几何_二维计算几何.md:    Circle c = Circle{point[1], 0};
./Algorithm/Math/数学4计算几何_二维计算几何.md:    for (int i = 2; i <= n; ++ i) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:        if (dcmp(c.r, len(c.p, point[i])) < 0) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:            c = Circle{point[i], 0};
./Algorithm/Math/数学4计算几何_二维计算几何.md:            for (int j = 1; j < i; ++ j) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:                if (dcmp(c.r, len(c.p, point[j])) < 0) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:                    c = Circle{(point[i] + point[j]) / 2, len(point[i], point[j]) / 2};
./Algorithm/Math/数学4计算几何_二维计算几何.md:                    for (int k = 1; k < j; ++ k) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:                        if (dcmp(c.r, len(c.p, point[k])) < 0) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:                            c = get_circle(point[i], point[j], point[k]);
./Algorithm/Math/数学4计算几何_二维计算几何.md:int rotating_calipers() {  // 返回距离
./Algorithm/Math/数学4计算几何_二维计算几何.md:    if (top <= 2) return len(point[1], point[n]);  // 特判一条线
./Algorithm/Math/数学4计算几何_二维计算几何.md:    int res = 0;
./Algorithm/Math/数学4计算几何_二维计算几何.md:    for (int i = 1, j = 3; i <= top; ++ i) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:        auto d = point[st[i]], e = point[st[i + 1]];  // 这里不需要%n, 因为虽然top减减了, 但是top + 1位置仍然有值, 就是起点
./Algorithm/Math/数学4计算几何_二维计算几何.md:        while (area(d, e, point[st[j]]) < area(d, e, point[st[j + 1]])) j = (j + 1 - 1) % top + 1;  // 这里栈是1~top
./Algorithm/Math/数学4计算几何_二维计算几何.md:        res = max(res, max(len(d, point[st[j]]), len(e, point[st[j]])));
./Algorithm/Math/数学4计算几何_二维计算几何.md:double project(Point a, Point b, Point c) {  // 求ab在ac上的投影长度
./Algorithm/Math/数学4计算几何_二维计算几何.md:Point norm(const Point& p) {  // 得到p的单位向量
./Algorithm/Math/数学4计算几何_二维计算几何.md:Point ans[N];
./Algorithm/Math/数学4计算几何_二维计算几何.md:    for (int i = 1, a = 3, b = 2, c = 3; i <= top; ++ i) {
./Algorithm/Math/数学4计算几何_二维计算几何.md:        auto d = point[st[i]], e = point[st[i + 1]];
./Algorithm/Math/数学4计算几何_二维计算几何.md:        while (cmp(area(d, e, point[st[a]]), area(d, e, point[st[a + 1]])) < 0) a = a % top + 1;
./Algorithm/Math/数学4计算几何_二维计算几何.md:        while (cmp(project(d, e, point[st[b]]), project(d, e, point[st[b + 1]])) < 0) b = b % top + 1;
./Algorithm/Math/数学4计算几何_二维计算几何.md:        while (cmp(project(d, e, point[st[c]]), project(d, e, point[st[c + 1]])) > 0) c = c % top + 1;
./Algorithm/Math/数学4计算几何_二维计算几何.md:        auto x = point[st[a]], y = point[st[b]], z = point[st[c]];
./Algorithm/Math/数学4计算几何_二维计算几何.md:  for (int i = 1; i <= 个数; ++ i, ++ ite) {  // ite初始化为起始位置
./Algorithm/Math/数学杂项BSGS.md:int bsgs(int a, int b, int p) {
./Algorithm/Math/数学杂项BSGS.md:    int k = sqrt(p) + 1;
./Algorithm/Math/数学杂项BSGS.md:    std::unordered_map<int, int> hash;
./Algorithm/Math/数学杂项BSGS.md:    for (int i = 0, j = b % p; i < k; ++ i) {
./Algorithm/Math/数学杂项BSGS.md:    int ak = fpow(a, k, p);
./Algorithm/Math/数学杂项BSGS.md:    for (int i = 1, j = ak % p; i <= k; ++ i) {
./Algorithm/Math/数学杂项BSGS.md:    int a, p;
./Algorithm/Math/数学杂项BSGS.md:    const int K = 46347;  // 每次查询的复杂度
./Algorithm/Math/数学杂项BSGS.md:    std::unordered_map<int, int> hash;
./Algorithm/Math/数学杂项BSGS.md:    void init(int aa, int pp) {
./Algorithm/Math/数学杂项BSGS.md:        int K_ = p / K + 1;
./Algorithm/Math/数学杂项BSGS.md:        int ak = fpow(a, K, p);
./Algorithm/Math/数学杂项BSGS.md:        for (int i = 1, j = ak; i <= K_; ++ i) {
./Algorithm/Math/数学杂项BSGS.md:    int query(int b) {
./Algorithm/Math/数学杂项BSGS.md:        int res = p + 1;
./Algorithm/Math/数学杂项BSGS.md:        for (int i = 0, j = b; i <= K; ++ i) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:  int sign(double x) {  // 符号函数
./Algorithm/Math/数学4计算几何_计算几何基础.md:  int cmp(double x, double y) {  // 比较函数
./Algorithm/Math/数学4计算几何_计算几何基础.md:struct Point {
./Algorithm/Math/数学4计算几何_计算几何基础.md:    Point operator + (const Point& t) const { return Point{x + t.x, y + t.y}; }  // 移动
./Algorithm/Math/数学4计算几何_计算几何基础.md:    Point operator - (const Point& t) const { return Point{x - t.x, y - t.y}; }  // A-B=BA
./Algorithm/Math/数学4计算几何_计算几何基础.md:    friend double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }
./Algorithm/Math/数学4计算几何_计算几何基础.md:    friend double cross(const Point& a, const Point& b) { return a.x * b.y - b.x * a.y; }
./Algorithm/Math/数学4计算几何_计算几何基础.md:    friend double get_length(const Point& a) { return sqrt(dot(a, a)); }  // 取模
./Algorithm/Math/数学4计算几何_计算几何基础.md:    friend double get_angle(const Point& a, const Point& b) { return acos(dot(a, b) / get_length(a) / get_length(b)); }  // 向量夹角
./Algorithm/Math/数学4计算几何_计算几何基础.md:    friend double area(Point a, Point b, Point c) { return cross(b - a, c - a); }  // 这里的Point是三个点
./Algorithm/Math/数学4计算几何_计算几何基础.md:    Point rotate(double angle) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:        return Point{x * cos(angle) + y * sin(angle), -x * sin(angle) + y * cos(angle)};
./Algorithm/Math/数学4计算几何_计算几何基础.md:     Point get_line_intersection(Point p, Vector v, Point q, Vector w) {  // 先确认两直线不平行或重合
./Algorithm/Math/数学4计算几何_计算几何基础.md:     Point get_line_intersection(Line a, Line b) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:         return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);
./Algorithm/Math/数学4计算几何_计算几何基础.md:     double distance_to_line(Point p, Point a, Point b) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:     double distance_to_segment(Point p, Point a, Point b) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:     Point get_line_projection(Point p, Point a, Point b) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:     bool on_segment(Point p, Point a, Point b) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:     bool segment_intersection(Point a1, Point a2, Point b1, Point b2) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:    double polygon_area(Point p[], int n) {  // 索引从0开始
./Algorithm/Math/数学4计算几何_计算几何基础.md:        for (int i = 1; i + 1 < n; ++ i) s += cross(p[i] - p[0], p[i + 1] - p[i]);
./Algorithm/Math/数学4计算几何_计算几何基础.md:struct Point {
./Algorithm/Math/数学4计算几何_计算几何基础.md:    friend double dot(const Point& a, const Point& b) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:    friend Point cross(const Point& a, const Point& b) {
./Algorithm/Math/数学4计算几何_计算几何基础.md:        return Point{a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - b.x * a.y};
./Algorithm/Math/数学4计算几何_三维计算几何.md:struct Point {
./Algorithm/Math/数学4计算几何_三维计算几何.md:Point point[N];
./Algorithm/Math/数学4计算几何_三维计算几何.md:	int id[3];  // 以索引来表示对应的点
./Algorithm/Math/数学4计算几何_三维计算几何.md:    Point norm() {  // 法向量
./Algorithm/Math/数学4计算几何_三维计算几何.md:        return cross((point[id[1]] - point[id[0]]), (point[id[2]] - point[id[0]]));
./Algorithm/Math/数学4计算几何_三维计算几何.md:    bool is_above(const Point& p) {  // 平面是有向的, 判断点p是否在平面上
./Algorithm/Math/数学4计算几何_三维计算几何.md:    	return dot(p - point[id[0]], norm()) >= 0;
./Algorithm/Math/数学4计算几何_三维计算几何.md:int n;
./Algorithm/Math/数学4计算几何_三维计算几何.md:Plane plane[N]; int cnt;  // 凸包存于plane[1...cnt]
./Algorithm/Math/数学4计算几何_三维计算几何.md:Plane np[N]; int tot;  // 辅助变量
./Algorithm/Math/数学4计算几何_三维计算几何.md:    for (int i = 4; i <= n; ++ i) {
./Algorithm/Math/数学4计算几何_三维计算几何.md:        int tot = 0;
./Algorithm/Math/数学4计算几何_三维计算几何.md:        for (int j = 1; j <= cnt; ++ j) {
./Algorithm/Math/数学4计算几何_三维计算几何.md:            bool t = plane[j].is_above(point[i]);
./Algorithm/Math/数学4计算几何_三维计算几何.md:            for (int k = 0; k < 3; ++ k)
./Algorithm/Math/数学4计算几何_三维计算几何.md:        for (int j = 1; j <= cnt; ++ j) {
./Algorithm/Math/数学4计算几何_三维计算几何.md:            for (int k = 0; k < 3; ++ k) {
./Algorithm/Math/数学4计算几何_三维计算几何.md:                int a = plane[j].id[k], b = plane[j].id[(k + 1) % 3];
./Algorithm/Math/数学4计算几何_三维计算几何.md:        for (int j = 1; j <= cnt; ++ j) plane[j] = np[j];
./Algorithm/Math/数学1数论2同余理论.md:> int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
./Algorithm/Math/数学1数论2同余理论.md:int exgcd(int a, int b, int &x, int &y) {
./Algorithm/Math/数学1数论2同余理论.md:int inverse(int a, int p) {
./Algorithm/Math/数学1数论2同余理论.md:    int x, y;
./Algorithm/Math/数学1数论2同余理论.md:int fpow(int d, int n, int p) {...}
./Algorithm/Math/数学1数论2同余理论.md:int inverse(int a, int p) {  //这里认为a和p已经互素
./Algorithm/Math/数学1数论2同余理论.md:int n, a[N], p[N];  //1 ~ n
./Algorithm/Math/数学1数论2同余理论.md:    ill P = 1; for (int i = 1; i <= n; ++ i) P *= p[i];
./Algorithm/Math/数学1数论2同余理论.md:    for (int i = 1; i <= n; ++ i) {
./Algorithm/Math/数学1数论2同余理论.md:        int t = P / p[i], t_1, useless;
./Algorithm/Math/数学1数论1整除理论.md:void f(int num) {
./Algorithm/Math/数学1数论1整除理论.md:    for (int i = 2; i <= num / i; ++ i) if (num % i == 0) {
./Algorithm/Math/数学1数论1整除理论.md:        int sum = 0;
./Algorithm/Math/数学1数论1整除理论.md:void f(int num) {
./Algorithm/Math/数学1数论1整除理论.md:    for (int i = 1; i * i <= num; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:bool pj(int num) {
./Algorithm/Math/数学1数论1整除理论.md:    for (int i = 2; i <= sqrt(num); ++ i) if (num % i == 0) return false;
./Algorithm/Math/数学1数论1整除理论.md:这里的循环边界没有采用`i * i <= num`是因为可能爆`int`
./Algorithm/Math/数学1数论1整除理论.md:  int is_prime(int x) {
./Algorithm/Math/数学1数论1整除理论.md:      int n = floor(sqrt(x) + 0.5);  // 1. 避免重复计算；2. 避免浮点误差
./Algorithm/Math/数学1数论1整除理论.md:      for (int i = 2; i <= n; ++ i) if (x % i == 0) return 0;
./Algorithm/Math/数学1数论1整除理论.md:  bool is_prime(int x) {
./Algorithm/Math/数学1数论1整除理论.md:      for (int i = 2; i <= x / i; ++ i) if (x % i == 0) return false;
./Algorithm/Math/数学1数论1整除理论.md:int is_prime(int x) {
./Algorithm/Math/数学1数论1整除理论.md:	for (int i = 5; i <= sqrt(x); i += 6) 
./Algorithm/Math/数学1数论1整除理论.md:int primes[N], cnt;
./Algorithm/Math/数学1数论1整除理论.md:    int limit = N;
./Algorithm/Math/数学1数论1整除理论.md:    for (int i = 2; i < limit; ++ i) if (! st[i]) {
./Algorithm/Math/数学1数论1整除理论.md:        for (int j = 2 * i; j < limit; j += i) st[j] = true;
./Algorithm/Math/数学1数论1整除理论.md:int prime[N], cnt; bool vis[N];
./Algorithm/Math/数学1数论1整除理论.md:void pre_prime(int n) {
./Algorithm/Math/数学1数论1整除理论.md:	for (int i = 2; i <= n; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:		for (int j = 1; j <= cnt && i * prime[j] <= n; ++ j) {
./Algorithm/Math/数学1数论1整除理论.md:int cnt;
./Algorithm/Math/数学1数论1整除理论.md:void pre(int limit) {
./Algorithm/Math/数学1数论1整除理论.md:    for (int i = 2; i <= limit; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:        for (int j = 0; j < cnt && i * primes[j] <= limit; ++ j) {
./Algorithm/Math/数学1数论1整除理论.md:    for (int i = 0; i < cnt; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:    for (int i = 0; i <= r - l; ++ i)
./Algorithm/Math/数学1数论1整除理论.md:  int n;  // = input();
./Algorithm/Math/数学1数论1整除理论.md:  int get_num(int num) {
./Algorithm/Math/数学1数论1整除理论.md:  int get_sum(int num) {
./Algorithm/Math/数学1数论1整除理论.md:+ `int`范围内，约数个数最多的那个数的约数个数是1600个（小于$\sqrt{int}$）
./Algorithm/Math/数学1数论1整除理论.md:  `int`范围内，指因数个数最多的那个数的约数个数是9个（考虑指数的前缀和）
./Algorithm/Math/数学1数论1整除理论.md:  1. 暴力$\sqrt{n}$：`for (int i = 1; i * i <= n; ++ i) if (n % i == 0) work(i)`
./Algorithm/Math/数学1数论1整除理论.md:       void dfs(int u, int num) {
./Algorithm/Math/数学1数论1整除理论.md:           int p = 第u个质因数;
./Algorithm/Math/数学1数论1整除理论.md:           for (int i = 0; i <= 第u个质因数的次数; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:   vector<int> get_divisors(int x) {
./Algorithm/Math/数学1数论1整除理论.md:       vector<int> res;
./Algorithm/Math/数学1数论1整除理论.md:       for (int i = 1; i <= x / i; ++ i) if (x % i == 0) {
./Algorithm/Math/数学1数论1整除理论.md:      vector<pair<int, int> > divide(int x) {
./Algorithm/Math/数学1数论1整除理论.md:          vector<pair<int, int> > res;
./Algorithm/Math/数学1数论1整除理论.md:          for (int i = 2; i <= x / i; ++ i) if (x % i == 0) {  //此处已经保证能够整除
./Algorithm/Math/数学1数论1整除理论.md:              int sum = 0;
./Algorithm/Math/数学1数论1整除理论.md:        int t = num;
./Algorithm/Math/数学1数论1整除理论.md:        for (int i = 0; i < cnt && primes[i] <= t / primes[i]; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:        	int p = primes[i];
./Algorithm/Math/数学1数论1整除理论.md:        		int s = 0;
./Algorithm/Math/数学1数论1整除理论.md:         int fac[N];  // fac[i]表示i的最小质因数因子，同时如果i是素数则在第二层循环调整，此处取自己
./Algorithm/Math/数学1数论1整除理论.md:         void pre(int limit = N - 1) {
./Algorithm/Math/数学1数论1整除理论.md:             for (int i = 2; i <= limit; ++ i) if (! fac[i]) {
./Algorithm/Math/数学1数论1整除理论.md:                 for (int j = i; j <= limit; j += i) fac[j] = i;
./Algorithm/Math/数学1数论1整除理论.md:         vector<int> divide(int x) {
./Algorithm/Math/数学1数论1整除理论.md:             vector<int> res;
./Algorithm/Math/数学1数论1整除理论.md:     for (int i = 0; i < cnt; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:     	int p = primes[i];
./Algorithm/Math/数学1数论1整除理论.md:         int s = 0;
./Algorithm/Math/数学1数论1整除理论.md:     	for (int j = n; j; j /= p) s += j / p;
./Algorithm/Math/数学1数论1整除理论.md:  int n, a[N];
./Algorithm/Math/数学1数论1整除理论.md:  int cnt[N], ans[N];
./Algorithm/Math/数学1数论1整除理论.md:  int main() {
./Algorithm/Math/数学1数论1整除理论.md:      for (int i = 1; i <= n; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:      for (int i = 1; i < N; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:          for (int j = i; j < N; j += i)
./Algorithm/Math/数学1数论1整除理论.md:      for (int i = 1; i <= n; ++ i) printf("%d\n", ans[a[i]] - 1);  //减去自己
./Algorithm/Math/数学1数论1整除理论.md:  int primes[] = {...}, cnt = sizeof(primes) / sizeof(int);  // [0, cnt)是有限的小质因数
./Algorithm/Math/数学1数论1整除理论.md:  int ans, maxn = 0;  //分别记录答案和答案的约数个数
./Algorithm/Math/数学1数论1整除理论.md:  void dfs(int u, int last, int num, int sum) {  // u表示枚举到哪个质数，last表示上一个质数的指数（指数降序），num表示当前的数字，sum表示当前的数的约数个数
./Algorithm/Math/数学1数论1整除理论.md:      for (int i = 1; i <= last; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:  //dfs(1, 最高次幂30, 1, 1);  ans即是，maxn是其约数个数，int内最多1600
./Algorithm/Math/数学1数论1整除理论.md:  int coprime(int r, int x, int l = 1) {  // 区间[1, r]中与x互质的数的个数
./Algorithm/Math/数学1数论1整除理论.md:  	vector<int> f;
./Algorithm/Math/数学1数论1整除理论.md:  	for (int j = 1; j <= cnt && prime[j] <= x / prime[j]; ++ j) {
./Algorithm/Math/数学1数论1整除理论.md:  	int sum = 0;
./Algorithm/Math/数学1数论1整除理论.md:  	for (int I = 1; I < (1 << f.size()); ++ I) {
./Algorithm/Math/数学1数论1整除理论.md:  		int mul = 1, popcount = 0;
./Algorithm/Math/数学1数论1整除理论.md:  		for (int i = 0; i < f.size(); ++ i) if (I >> i & 1) {
./Algorithm/Math/数学1数论1整除理论.md:  int primes[N], cnt;
./Algorithm/Math/数学1数论1整除理论.md:  int phi[N];
./Algorithm/Math/数学1数论1整除理论.md:  void init(int n = N - 1) {
./Algorithm/Math/数学1数论1整除理论.md:      for (int i = 2; i <= n; ++ i) {
./Algorithm/Math/数学1数论1整除理论.md:          for (int j = 0; j < cnt && i * primes[j] <= n; ++ j) {
./Algorithm/Math/数学0线代.md://const int LEN = ;  // 矩阵的长宽
./Algorithm/Math/数学0线代.md:    int n, m, w[LEN][LEN];
./Algorithm/Math/数学0线代.md:    void ide(int len) {  // 用于初始化为单位矩阵  // 此时矩阵已经是一个方阵
./Algorithm/Math/数学0线代.md:        for (int i = 0; i < n; ++ i) w[i][i] = 1;
./Algorithm/Math/数学0线代.md:        for (int i = 0; i < n; i++) 
./Algorithm/Math/数学0线代.md:            for (int j = 0; j < b.m; j++)   // 要求m == b.n
./Algorithm/Math/数学0线代.md:                for (int k = 0; k < m; k++)
./Algorithm/Math/数学0线代.md:Mat fpow(Mat d, int n) {  // 方阵：d^n
./Algorithm/Math/数学0线代.md://const int N = ;  //
./Algorithm/Math/数学0线代.md:int gauss(double a[][N + 1], int n) {  // a是一个增广矩阵（列比行多1），行坐标是(0, n - 1)，列坐标是(0, n)
./Algorithm/Math/数学0线代.md:    int c, r;
./Algorithm/Math/数学0线代.md:        int t = r;
./Algorithm/Math/数学0线代.md:        for (int i = r; i < n; ++ i)  // 找主元：找到绝对值最大的行
./Algorithm/Math/数学0线代.md:        for (int i = c; i <= n; ++ i) std::swap(a[t][i], a[r][i]);  // 交换：将绝对值最大的行换到最顶端
./Algorithm/Math/数学0线代.md:        for (int i = n; i >= c; -- i) a[r][i] /= a[r][c];  //归一化：将当前行的首位变成1
./Algorithm/Math/数学0线代.md:        for (int i = r + 1; i < n; ++ i) if (std::fabs(a[i][c]) > eps) {  // 消元：用当前行将下面所有的列消成0
./Algorithm/Math/数学0线代.md:            for (int j = n; j >= c; -- j) a[i][j] -= a[r][j] * a[i][c];
./Algorithm/Math/数学0线代.md:        for (int i = r; i < n; ++ i) if (std::fabs(a[i][n]) > eps) return 2;  // 无解
./Algorithm/Math/数学0线代.md:    for (int i = n - 1; i >= 0; -- i)  // 转化成对角矩阵
./Algorithm/Math/数学0线代.md:        for (int j = i + 1; j < n; ++ j)
./Algorithm/Math/数学5多项式&生成函数.md:int rev[N], bit, tot;  // rev某个预处理数组，bit：结果多项式度补充到2的多少次幂，tot = 1 << bit
./Algorithm/Math/数学5多项式&生成函数.md:void fft(Complex a[], int inv) {
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i < tot; i ++ )
./Algorithm/Math/数学5多项式&生成函数.md:    for (int mid = 1; mid < tot; mid <<= 1) {
./Algorithm/Math/数学5多项式&生成函数.md:        for (int i = 0; i < tot; i += mid * 2) {
./Algorithm/Math/数学5多项式&生成函数.md:            for (int j = 0; j < mid; j ++, wk = wk * w1) {
./Algorithm/Math/数学5多项式&生成函数.md:int main()
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i <= n; i ++ ) scanf("%lf", &a[i].x);
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i <= m; i ++ ) scanf("%lf", &b[i].x);
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i < tot; i ++ )
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i < tot; i ++ ) a[i] = a[i] * b[i];
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i <= n + m; i ++ )
./Algorithm/Math/数学5多项式&生成函数.md:        printf("%d ", (int)(a[i].x / tot + 0.5));
./Algorithm/Math/数学5多项式&生成函数.md:const int N = 3e6 + 7;
./Algorithm/Math/数学5多项式&生成函数.md:const int g = 3;  // MOD的一个原根;
./Algorithm/Math/数学5多项式&生成函数.md:const int gi = 332748118;  // g在MOD下的逆元;
./Algorithm/Math/数学5多项式&生成函数.md:const int MOD = 998244353;  // 就是mod;
./Algorithm/Math/数学5多项式&生成函数.md:int rev[N], bit, tot;
./Algorithm/Math/数学5多项式&生成函数.md:void ntt(T a[], int type) {
./Algorithm/Math/数学5多项式&生成函数.md:	for (int i = 0; i < tot; ++ i)
./Algorithm/Math/数学5多项式&生成函数.md:	for (int mid = 1; mid < tot; mid <<= 1) {
./Algorithm/Math/数学5多项式&生成函数.md:		for (int i = 0; i < tot; i += mid * 2) {
./Algorithm/Math/数学5多项式&生成函数.md:			for (int j = 0; j < mid; ++ j, g0 = g0 * gn % MOD) {
./Algorithm/Math/数学5多项式&生成函数.md:int n, m;
./Algorithm/Math/数学5多项式&生成函数.md:int main() { 
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i <= n; ++i) scanf("%d", &a[i]);  // 输入第一个多项式系数 
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i <= m; ++i) scanf("%d", &b[i]);  // 输入第二个多项式系数 
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i < tot; i ++ )
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i <= tot; ++ i)
./Algorithm/Math/数学5多项式&生成函数.md:    for (int i = 0; i <= n + m; ++i)       //输出
./Algorithm/Math/数学5多项式&生成函数.md:        printf("%lld ", a[i] * inv % MOD); //除以len在模mod意义下即为乘以inv
./Algorithm/Math/数学杂项线性基.md:const int MAXN = 63;
./Algorithm/Math/数学杂项线性基.md:		for (int i = MAXN - 1; i >= 0; -- i) if (x >> i & 1) {
./Algorithm/Math/数学杂项线性基.md:        for (int i = MAXN - 1; i >= 0; -- i) if (x >> i & 1) {
./Algorithm/Math/数学杂项线性基.md:        for (int i = MAXN - 1; i >= 0; -- i) if ((res^a[i]) > res) res^=a[i];
./Algorithm/Math/数学杂项线性基.md:        for (int i = 0; i < MAXN; ++ i) insert(other.a[i]);
./Algorithm/Math/数学2组合数学.md:    for (int i = 0; i < N; ++ i)
./Algorithm/Math/数学2组合数学.md:        for (int j = 0; j <= i && j < M; ++ j)
./Algorithm/Math/数学2组合数学.md:  int fact[N], infact[N];
./Algorithm/Math/数学2组合数学.md:      for (int i = 1; i < N; i ++ )
./Algorithm/Math/数学2组合数学.md:  int C(int n, int m) {
./Algorithm/Math/数学2组合数学.md:  int P(int n, int m) {
./Algorithm/Math/数学2组合数学.md:int C(int a, int b, int p) {
./Algorithm/Math/数学2组合数学.md:    for (int i = a, j = 1; j <= b; -- i, ++ j) {
./Algorithm/Math/数学2组合数学.md:int lucas(ill a, ill b, int p) {
./Algorithm/Math/数学2组合数学.md:int primes[N], cnt;
./Algorithm/Math/数学2组合数学.md:void pre_prime(int n) {
./Algorithm/Math/数学2组合数学.md:    for (int i = 2; i <= n; ++ i) {
./Algorithm/Math/数学2组合数学.md:        for (int j = 0; primes[j] <= n / i; ++ j) {
./Algorithm/Math/数学2组合数学.md:int get(int n, int p) {  // 求n!中p的次数
./Algorithm/Math/数学2组合数学.md:    int res = 0;
./Algorithm/Math/数学2组合数学.md:vector<int> operator * (vector<int> &a, int b) {  // 重载*为高精度乘低精度
./Algorithm/Math/数学2组合数学.md:    vector<int> c;
./Algorithm/Math/数学2组合数学.md:    int t = 0;
./Algorithm/Math/数学2组合数学.md:vector<int> C(int n, int m) {  // 
./Algorithm/Math/数学2组合数学.md:    vector<int> sum;
./Algorithm/Math/数学2组合数学.md:    for (int i = 0; i < cnt; ++ i) {
./Algorithm/Math/数学2组合数学.md:        int p = primes[i];
./Algorithm/Math/数学2组合数学.md:    vector<int> res;  //
./Algorithm/Math/数学2组合数学.md:    for (int i = 0; i < cnt; ++ i)
./Algorithm/Math/数学2组合数学.md:        for (int j = 0; j < sum[i]; ++ j)
./Algorithm/Math/数学2组合数学.md:  void solve(int N, int K, int MOD) {
./Algorithm/Math/数学2组合数学.md:      vector<int> f(N + 1, 0), s(N + 1, 0);
./Algorithm/Math/数学2组合数学.md:      for (int i = 1; i <= N; ++ i) {
./Algorithm/Math/数学2组合数学.md:  int n, ans = 0;  // n为集合个数（注意索引从1开始），ans维护答案
./Algorithm/Math/数学2组合数学.md:  for (int bit = 1; bit < (1 << n); ++ bit) {
./Algorithm/Math/数学2组合数学.md:      int sign = -1;
./Algorithm/Math/数学2组合数学.md:      for (int i = 0; i < n; ++ i) if (bit >> i & 1) {
./Algorithm/Math/数学2组合数学.md:    	int res = 当前条件限制下的答案
./Algorithm/Data-Structure-and-Sort/Sort.md:  void quick_sort(T q[], int l, int r) {
./Algorithm/Data-Structure-and-Sort/Sort.md:      int i = l - 1, j = r + 1, x = q[l + r >> 1];  //基准数
./Algorithm/Data-Structure-and-Sort/Sort.md:  void merge_sort(T q[], int l, int r) {
./Algorithm/Data-Structure-and-Sort/Sort.md:      int mid = l + r >> 1;
./Algorithm/Data-Structure-and-Sort/Sort.md:      int k = 0, i = l, j = mid + 1;
./Algorithm/Data-Structure-and-Sort/Sort.md:      for (int i = l, j = 0; i <= r; ++ i, ++ j) q[i] = tmp[j];
./Algorithm/Data-Structure-and-Sort/Tree.md:    void printTree() const;
./Algorithm/Data-Structure-and-Sort/Tree.md:    void printTree(BinaryNode *t) const;
./Algorithm/Data-Structure-and-Sort/Tree.md:    + internal path length内部路径长
./Algorithm/Data-Structure-and-Sort/LinearList.md:    explicit Vector(int initSize = 0) 
./Algorithm/Data-Structure-and-Sort/LinearList.md:            for (int k = 0; k < size(); ++ k)
./Algorithm/Data-Structure-and-Sort/LinearList.md:    void resize(int newSize) {
./Algorithm/Data-Structure-and-Sort/LinearList.md:    void reserve(int newCapacity) {
./Algorithm/Data-Structure-and-Sort/LinearList.md:        for (int k = 0; k < theSize; ++ k)
./Algorithm/Data-Structure-and-Sort/LinearList.md:    Object& operator [] (int index) {
./Algorithm/Data-Structure-and-Sort/LinearList.md:    const Object& operator [] (int index) const {
./Algorithm/Data-Structure-and-Sort/LinearList.md:    int size() const { return theSize; }
./Algorithm/Data-Structure-and-Sort/LinearList.md:    int capacity() const { return theCapacity; }
./Algorithm/Data-Structure-and-Sort/LinearList.md:    int theSize;
./Algorithm/Data-Structure-and-Sort/LinearList.md:    int theCapacity;
./Algorithm/Data-Structure-and-Sort/LinearList.md:        const_iterator& operator++ (int) {
./Algorithm/Data-Structure-and-Sort/LinearList.md:        iterator operator++ (int) {
./Algorithm/Data-Structure-and-Sort/LinearList.md:    int size() const { return theSize; }
./Algorithm/Data-Structure-and-Sort/LinearList.md:    int theSize;
./Algorithm/Data-Structure-and-Sort/misc.md:	matrix(int rows, int cols) : array(rows) {
./Algorithm/Data-Structure-and-Sort/misc.md:		for (int i = 0; i < rows; ++ i)
./Algorithm/Data-Structure-and-Sort/misc.md:    const std::vector<Object> & operator[] (int row) const {
./Algorithm/Data-Structure-and-Sort/misc.md:    std::vector<Object> & operator [] (int row) {
./Algorithm/Data-Structure-and-Sort/misc.md:    int numrows() const { return array.size(); }
./Algorithm/Data-Structure-and-Sort/misc.md:    int numcols() const { return numrows() ? array[0].size() : 0; }
./Algorithm/Graph/图论4联通分量.md:int dfn[N], low[N], idx;
./Algorithm/Graph/图论4联通分量.md:stack<int> st; bool vis[N];
./Algorithm/Graph/图论4联通分量.md:int id[N], scc;
./Algorithm/Graph/图论4联通分量.md:void tarjan(int node) {
./Algorithm/Graph/图论4联通分量.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论4联通分量.md:        int tar;
./Algorithm/Graph/图论4联通分量.md://for (int i = 1; i <= n; ++ i) if (! dfn[i]) tarjan(i);
./Algorithm/Graph/图论4联通分量.md:int dfn[N], low[N], idx;
./Algorithm/Graph/图论4联通分量.md:stack<int> st;
./Algorithm/Graph/图论4联通分量.md:int id[N], dcc;
./Algorithm/Graph/图论4联通分量.md:void tarjan(int node, int from) {  // from是来向的边，add要反向边异或
./Algorithm/Graph/图论4联通分量.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论4联通分量.md:        int tar;
./Algorithm/Graph/图论4联通分量.md:int dfn[N], low[N], idx;
./Algorithm/Graph/图论4联通分量.md:stack<int> st; bool vis[N];
./Algorithm/Graph/图论4联通分量.md:int id[N], dcc;
./Algorithm/Graph/图论4联通分量.md:void tarjan(int node, int father, int root) {
./Algorithm/Graph/图论4联通分量.md:    int num = 0;
./Algorithm/Graph/图论4联通分量.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论4联通分量.md:                int tar;
./Algorithm/Graph/图论4联通分量.md:        int tar;
./Algorithm/Graph/图论9网络流.md:int dis[N], pre[N];  // dis是从S走到每个点的路径的容量最小值
./Algorithm/Graph/图论9网络流.md:bool bfs(int S, int T) {
./Algorithm/Graph/图论9网络流.md:    queue<int> qu;
./Algorithm/Graph/图论9网络流.md:        int node = qu.front(); qu.pop();
./Algorithm/Graph/图论9网络流.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论9网络流.md:int EK(int S, int T) {
./Algorithm/Graph/图论9网络流.md:    int res = 0;
./Algorithm/Graph/图论9网络流.md:        for (int i = T; i != S; i = to[pre[i] ^ 1])
./Algorithm/Graph/图论9网络流.md:int S, T;
./Algorithm/Graph/图论9网络流.md:int dis[N], cur[N];  // cur表示当前弧
./Algorithm/Graph/图论9网络流.md:    queue<int> qu;
./Algorithm/Graph/图论9网络流.md:        int node = qu.front(); qu.pop();
./Algorithm/Graph/图论9网络流.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论9网络流.md:int find(int node, int limit) {
./Algorithm/Graph/图论9网络流.md:    int flow = 0;
./Algorithm/Graph/图论9网络流.md:    for (int e = cur[node]; e && flow < limit; e = lext[e]) {
./Algorithm/Graph/图论9网络流.md:        int son = to[e];
./Algorithm/Graph/图论9网络流.md:            int t = find(son, min(val[e], limit - flow));
./Algorithm/Graph/图论9网络流.md:int dinic() {
./Algorithm/Graph/图论9网络流.md:    int res = 0, flow;
./Algorithm/Graph/图论5二分图.md:int n, color[N];  // 0表示未染色，1和2表示染色
./Algorithm/Graph/图论5二分图.md:bool dfs(int node, int c) {
./Algorithm/Graph/图论5二分图.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论5二分图.md:	for (int i = 1; i <= n; ++ i) if (! color[i]) {
./Algorithm/Graph/图论5二分图.md:int n, m;  // n和m分别表示两集合的元素个数
./Algorithm/Graph/图论5二分图.md:int match[M];  // 记录当前右侧集合元素所对应的左侧集合元素
./Algorithm/Graph/图论5二分图.md:bool find(int i) {
./Algorithm/Graph/图论5二分图.md:    for (int j = 1; j <= m; ++ j) if (g[i][j]) {
./Algorithm/Graph/图论5二分图.md:int Hungrian() {  // 返回最大匹配数
./Algorithm/Graph/图论5二分图.md:    int res = 0;
./Algorithm/Graph/图论5二分图.md:    for (int i = 1; i <= n; ++ i) {
./Algorithm/Graph/图论2最小生成树.md:  int dis[N];
./Algorithm/Graph/图论2最小生成树.md:  int prim(int root) {
./Algorithm/Graph/图论2最小生成树.md:      int res = 0;
./Algorithm/Graph/图论2最小生成树.md:      for (int i = 0; i < n; ++ i) {  //处理n次
./Algorithm/Graph/图论2最小生成树.md:          int node = -1;
./Algorithm/Graph/图论2最小生成树.md:          for (int j = 1; j <= n; ++ j) if (! vis[j]) {
./Algorithm/Graph/图论2最小生成树.md:  		for (int j = 1; j <= n; ++ j) dis[j] = min(dis[j], g[node][j]);  // 更新其他点到树的最小距离
./Algorithm/Graph/图论2最小生成树.md:    int x, y, val;
./Algorithm/Graph/图论2最小生成树.md:int kruskal() {
./Algorithm/Graph/图论2最小生成树.md:	int res = 0, cnt = 0;
./Algorithm/Graph/图论2最小生成树.md:	for (int x, y, z, i = 1; i <= m; ++ i) {
./Algorithm/Graph/图论2最小生成树.md:    int cnt;
./Algorithm/Graph/图论2最小生成树.md:        int val, son[2];
./Algorithm/Graph/图论2最小生成树.md:    void add(int l, int r, int val) {
./Algorithm/Graph/图论2最小生成树.md:    int cnt = 0;
./Algorithm/Graph/图论2最小生成树.md:    for (int x, y, z, i = 1; i <= m; ++ i) {
./Algorithm/Graph/图论1最短路-最小环.md:int get_min_ring() {
./Algorithm/Graph/图论1最短路-最小环.md:    int res = INF;
./Algorithm/Graph/图论1最短路-最小环.md:    for (int k = 1; k <= n; ++ k) {
./Algorithm/Graph/图论1最短路-最小环.md:		for (int i = 1; i < k; ++ i)
./Algorithm/Graph/图论1最短路-最小环.md:            for (int j = i + 1; j < k; ++ j)
./Algorithm/Graph/图论1最短路-最小环.md:        for (int i = 1; i <= n; ++ i)
./Algorithm/Graph/图论1最短路-最小环.md:            for (int j = 1; j <= n; ++ j)
./Algorithm/Graph/图论1最短路-最小环.md:int dis[N][N];
./Algorithm/Graph/图论1最短路-最小环.md:void dijkstra(int st, int num_node) {
./Algorithm/Graph/图论1最短路-最小环.md:    for (int i = 1; i <= num_node; ++ i) dis[st][i] = INF;
./Algorithm/Graph/图论1最短路-最小环.md:    struct point {
./Algorithm/Graph/图论1最短路-最小环.md:        int x, d;
./Algorithm/Graph/图论1最短路-最小环.md:        bool operator < (const point& t) const { return d > t.d; }
./Algorithm/Graph/图论1最短路-最小环.md:    priority_queue<point> qu;
./Algorithm/Graph/图论1最短路-最小环.md:        int node = qu.top().x; qu.pop();
./Algorithm/Graph/图论1最短路-最小环.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论1最短路-最小环.md:void min_ring_pre(int num_node) {
./Algorithm/Graph/图论1最短路-最小环.md:    for (int i = 1; i <= num_node; ++ i) dijkstra(i, num_node);
./Algorithm/Graph/图论1最短路-最小环.md:int get_min_ring(int num_node) {
./Algorithm/Graph/图论1最短路-最小环.md:    int res = INF;
./Algorithm/Graph/图论1最短路-最小环.md:    for (int i = 1; i <= num_node; ++ i)
./Algorithm/Graph/图论1最短路-最小环.md:        for (int j = i + 1; j <= num_node; ++ j)
./Algorithm/Graph/图论1最短路.md:int n, g[N][N], vis[N], dis[N];
./Algorithm/Graph/图论1最短路.md:void dijsktra(int st) {
./Algorithm/Graph/图论1最短路.md:    for (int node, op = 1; op <= n; ++ op) {
./Algorithm/Graph/图论1最短路.md:        for (int i = 1; i <= n; ++ i) if (! vis[i]) {
./Algorithm/Graph/图论1最短路.md:        for (int i = 1; i <= n; ++ i) 
./Algorithm/Graph/图论1最短路.md:int dis[N], vis[N];
./Algorithm/Graph/图论1最短路.md:void dijkstra(int st) {
./Algorithm/Graph/图论1最短路.md:	struct point {
./Algorithm/Graph/图论1最短路.md:        int d, x;
./Algorithm/Graph/图论1最短路.md:        bool operator < (const point& t) const { return d > t.d; }  //小根堆
./Algorithm/Graph/图论1最短路.md:	priority_queue<point> qu;
./Algorithm/Graph/图论1最短路.md:    //priority_queue<pair<int, int>, vector<pair<int, int>>, greater<<pair, pair>>> heap
./Algorithm/Graph/图论1最短路.md:		int node = qu.top().x; qu.pop();
./Algorithm/Graph/图论1最短路.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论1最短路.md:for (int op = 1; op < n; op ++) {  //迭代n - 1次
./Algorithm/Graph/图论1最短路.md:	for (int i = 0; i < edges.size(); i ++) {  //遍历所有的边
./Algorithm/Graph/图论1最短路.md:int dis[N], vis[N];
./Algorithm/Graph/图论1最短路.md:void SPFA(int st) {
./Algorithm/Graph/图论1最短路.md:    queue<int> qu;
./Algorithm/Graph/图论1最短路.md:        int node = qu.front(); qu.pop(); vis[node] = 0;
./Algorithm/Graph/图论1最短路.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论1最短路.md:  int qu[N], hh = 0, tt = 0;
./Algorithm/Graph/图论1最短路.md:    queue<int> qu;
./Algorithm/Graph/图论1最短路.md:    for (int i = 1; i <= n; ++ i) {  // ！所有点入队
./Algorithm/Graph/图论1最短路.md:        int node = qu.front(); qu.pop();
./Algorithm/Graph/图论1最短路.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论1最短路.md:int n, d[N][N];
./Algorithm/Graph/图论1最短路.md://初始化：memset(d, 0x3f, sizeof d); for (int i = 1; i <= n; ++ i) d[i][i] = 0;
./Algorithm/Graph/图论1最短路.md:for (int k = 1; k <= n; ++ k)
./Algorithm/Graph/图论1最短路.md:    for (int i = 1; i <= n; ++ i)
./Algorithm/Graph/图论1最短路.md:        for (int j = 1; j <= n; ++ j)
./Algorithm/Graph/图论1最短路.md:			d[i][j] = min(d[i][j], d[i][k] + d[k][j]);  // 这里如果初始化INF，这里加法可能爆int  
./Algorithm/Graph/图论1最短路.md:  int a = ..., b = ...; // a和b是新关系中的两个，加入a < b，并且我们也按从小到大建边——a -> b
./Algorithm/Graph/图论1最短路.md:  for (int x = 1; x <= n; ++ x) {
./Algorithm/Graph/图论1最短路.md:      for (int y = 1; y <= n; ++ y) {
./Algorithm/Graph/图论3最近公共祖先.md:  const int LOG_N = 30;
./Algorithm/Graph/图论3最近公共祖先.md:  int dep[N], fa[N][LOG_N];
./Algorithm/Graph/图论3最近公共祖先.md:  void dfs_pre(int node = 1) {
./Algorithm/Graph/图论3最近公共祖先.md:      for (int i = 1; i < LOG_N; i ++) fa[node][i] = fa[fa[node][i - 1]][i - 1];
./Algorithm/Graph/图论3最近公共祖先.md:      for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论3最近公共祖先.md:  int lca(int x, int y) {
./Algorithm/Graph/图论3最近公共祖先.md:      for (int i = LOG_N - 1; i >= 0; i --) if (dep[fa[x][i]] >= dep[y]) x = fa[x][i];
./Algorithm/Graph/图论3最近公共祖先.md:      for (int i = LOG_N - 1; i >= 0; i --) if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
./Algorithm/Graph/图论3最近公共祖先.md:int lca[MAXN];  // 存储询问i的lca
./Algorithm/Graph/图论3最近公共祖先.md:    int to;  // 这个边的指向
./Algorithm/Graph/图论3最近公共祖先.md:    int id;  // 这个边所属的询问编号
./Algorithm/Graph/图论3最近公共祖先.md:// int fa[]; define find(); init fa <- i
./Algorithm/Graph/图论3最近公共祖先.md:int st[N];
./Algorithm/Graph/图论3最近公共祖先.md:void tarjan(int node) {
./Algorithm/Graph/图论3最近公共祖先.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Graph/图论3最近公共祖先.md:        int id = sam.id; son = sam.to;
./Algorithm/Graph/图论0拓扑图.md:    int hh = 0, tt = -1;
./Algorithm/Graph/图论0拓扑图.md:    for (int i = 1; i <= n; ++ i) if (! du[i]) qu[++ tt] = i;
./Algorithm/Graph/图论0拓扑图.md:        int node = qu[hh ++];
./Algorithm/Graph/图论0拓扑图.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划1状态机模型.md:   for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划1状态机模型.md:   for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划1状态机模型.md:       for (int j = 0; j <= k; ++ j) {
./Algorithm/Dynamic-Programming/动态规划1状态机模型.md:   for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:   int LIS(int n, T h[]) {  // 索引从1开始
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:       vector<int> f(n + 1, 0);
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:       int res = 0;
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:       for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:           for (int j = 1; j < i; ++ j) if (h[j] < h[i]) f[i] = max(f[i], f[j] + 1);
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:   int LIS(int n, T h[]) {  // 索引从1开始
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:       vector<int> f;
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:       for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  vector<int> LCS_pre(vector<int> &a, vector<int> &b) {
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  //	map<char, vector<int> > mp;
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  //	for (char c = 'a'; c <= 'z'; ++ c) mp.insert({c, vector<int>()});
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  	map<int, vector<int> > mp;
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  	for (int i = 0; i <= 9; ++ i) mp.insert({i, vector<int>()});
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  	for (int i = a.size(); i >= 0; -- i) mp[a[i]].push_back(i);
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  	vector<int> res;
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:      for (int j = 1; j <= n; ++ j) {
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:              for (int k = 0; k < j; ++ k) if (b[j] > b[k]) f[i][j] = max(f[i][j], f[i - 1][k] + 1);
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  //for (int i = 0; i <= n; ++ i) ans = max(ans, f[n][i]);
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:      int maxn = 1;
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:      for (int j  =1; j <= n; ++ j) {
./Algorithm/Dynamic-Programming/动态规划0线性DP.md:  //for (int i = 0; i <= n; ++ i) ans = max(ans, f[n][i]);
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:         int pj(int bits) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:             int cnt = 0;  //计数：连续的0的个数 
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:             for (int i = 0; i < n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:for (int j = 1; j <= m; ++ j) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:    for (int k = 0; k < 1 << n; ++ k) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:        for (int k_ = 0; k_ < 1 << n; ++ k_) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      int pj(int bit) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:          for (int i = 1; i < n; ++ i) if ((bit >> i & 1) & (bit >> (i - 1) & 1)) return 0;
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      vector<int> state;  //合法状态
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      vector<int> head[M];  //状态bit的合法相邻状态邻接表head[bit];
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      for (int i = 0; i < 1 << n; ++ i) if (pj(i)) state.push_back(i);
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:    for (int i = 1; i <= n + 1; ++ i) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:    	for (int j = 0; j <= k; ++ j) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:    				int c = cnt[a];  //cnt[a]表示位模式a中1的个数，可以预处理
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:    + 这里的检测一行有无相邻还有一个方法：`int pj(int x) { return !(x & x >> 1); }`优美，而且扩展到相邻两位
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:    for (int i = 0; i < 1 << m; ++ i) if (pj(i)) state[i].push_back(i);
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:    for (int i = 0; i < state.size(); ++ i) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:        for (int j = 0; j < state.size(); ++ j) if ((state[i] & state[j]) == 0) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:    for (int i = 1; i <= n + 1; ++ i) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:        for (int j = 0; j < state.size(); ++ j) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      int pj(int x) { return !((x & x >> 1) || (x & x >> 2)); }
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:   for (int i = 0; i < 1 << n; ++ i) {  //所有路径方案
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:       for (int j = 0; j < n; ++ j) if (i >> j & 1) {//路径上有j
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:   		int ii = i - (1 << j);
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:           for (int k = 0; k < n; ++ k) if (ii >> k & 1) {//路径上除了j还有k
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      for (int i = 0; i < n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      	for (int j = 0; j < n; ++ j) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      		for (int k = 0; k < n; ++ k) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      for (int a = 0; a + 1 < 1 << n; ++ a) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      	int t = -1;
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      	for (int i = 0; i < n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      	for (int i = 0; i < n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:      		int b = path[t][i] | a;
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:     for (int i = 1; i <= n; ++ i) g[i][i] = 0;
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:     for (int a = 1; a < 1 << n; ++ a) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:         for (int i = 0; i < n; ++ i) if (a >> i & 1) {  //在这个集合中的点
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:             for (int j = 0; j < n; ++ j) if (g[i][j] != INF) {  //从这个点开始扩展
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:     int get_cost(int now, int pre) {
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:         int buji = now ^ pre;
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:         int res = 0;
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:         for (int i = 0; i < n; ++ i) if (buji >> i & 1) {  //枚举在now中而不在pre中的点
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:             int tmp = INF;
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:             for (int j = 0; j < n; ++ j) if (pre >> j & 1) {  //找这些点到pre中的最小值
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:     for (int i = 0; i < n; ++ i) f[1 << i][0] = 0;  //起点花销为0
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:     for (int a = 1; a < 1 << n; ++ a) {  //0是空，预处理了
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:         for (int b = a - 1 & a; b; b = b - 1 & a) {  //枚举真子集
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:             int cost = get_cost(a, b);
./Algorithm/Dynamic-Programming/动态规划5状压DP.md:             for (int k = 1; k < n; ++ k)
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:+ 技巧：定义`int dp(int n)`表示区间$[0, n]$内具有某个性质的数的个数，则答案为$[X, Y] \Rightarrow dp(Y) - dp(X - 1)$
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:  const int N = 32 + 7;  //数位长度
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:  int f[N][N];           //计算左分支的f
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:  int dp(int n) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:  	vector<int> nums;
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:      int res = 0;  //记录答案
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:      int last = 0;  //记录高位右分支的某些信息
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:      for (int i = nums.size() - 1; i >= 0; -- i) {  //从高位开始
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:          int x = nums[i];
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:  int main() {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:      int l, r; while (cin >> l >> r); cout << dp(r) - dp(l - 1);
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:    for (int i = 0; i < N; ++ i) for (int j = 0; j <= i; ++ j) f[i][j] = f[i - 1][j] + f[i - 1][j - 1];
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:int dp(int n) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        int x...
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        for (int i = 1, j = 0; j <= 9; ++ j) f[i][j] = 1;
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        for (int i = 2; i < N; ++ i) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:            for (int j = 0; j <= 9; ++ j) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:                for (int k = j; k <= 9; ++ k) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:int dp(int n) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        int x...;
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:            for (int j = last; j < x; ++ j) res += f[i + 1][j];
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:    	for (int i = 1, j = 0; j <= 9; ++ j) f[i][j] = 1;
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        for (int i = 2; i < N; ++ i) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:            for (int j = 0; j <= 9; ++ j) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:                for (int k = 0; k <= 9; ++ k) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:int dp(int n) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:    int last = -2;  //保证第一位可以
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        int x...;
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        for (int j = (i == nums.size() - 1); j < x; ++ j) {  //如果在最高位，不能从0开始，那是前导零
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:    for (int i = 1; i <= nums.size(); ++ i) for (int j = 1; j <= 9; ++ j) res += f[i][j];
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:     int f[N][10][P_MAX];
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:         for (int i = 1, j = 0; j <= 9; ++ j) f[i][j][mod(j, P)] = 1;
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:         for (int i = 2; i < N; ++ i) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:             for (int j = 0; j <= 9; ++ j) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:                 for (int k = 0; k < P; ++ k) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:                     for (int j_ = 0; j_ <= 9; ++ j_) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:int dp(int n) {
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        int x...;
./Algorithm/Dynamic-Programming/动态规划4数位DP.md:        for (int j = 0; j < x; ++ j) {
./Algorithm/Dynamic-Programming/动态规划.md:   int n, m, g[N][M];  // 如上
./Algorithm/Dynamic-Programming/动态规划.md:   int f[N][M];
./Algorithm/Dynamic-Programming/动态规划.md:   int work() {
./Algorithm/Dynamic-Programming/动态规划.md:   	for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划.md:   	    for (int j = 1; j <= m; ++ j) {
./Algorithm/Dynamic-Programming/动态规划.md:   int n, m, g[N][M], f[N + M][N][N];
./Algorithm/Dynamic-Programming/动态规划.md:   int work() {
./Algorithm/Dynamic-Programming/动态规划.md:       for (int k = 2; k <= n + m; ++ k)
./Algorithm/Dynamic-Programming/动态规划.md:           for (int i1 = 1; i1 <= n; ++ i1) 
./Algorithm/Dynamic-Programming/动态规划.md:               for (int i2 = 1; i2 <= n; ++ i2) {
./Algorithm/Dynamic-Programming/动态规划.md:                   int j1 = k - i1, j2 = k - i2;
./Algorithm/Dynamic-Programming/动态规划.md:                   int t = g[i1][j1];
./Algorithm/Dynamic-Programming/动态规划.md:                   int &x = f[k][i1][i2];  // tips
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:      for (int len = 1; len <= n; ++ len) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:      	for (int i = 1; i + len - 1 <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:              int j = i + len - 1;
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:                  for (int k = i; k < j; ++ k) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  for (int i = 1; i <= n; ++ i) a[i + n] = a[i];
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  for (int i = 1; i <= n << 1; ++ i) pre[i] = pre[i - 1] + a[i];
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  for (int len = 1; len <= n; ++ len) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:      for (int l = 1, r; l + len - 1 <= n << 1; ++ l) {  //注意此处的n*2
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  			for (int k = l; k < r; ++ k) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + pre[r] - pre[l - 1]);
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  int ans = 0x3f3f3f3f;
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  for (int i = 1; i <= n; ++ i) ans = min(ans, f[i][i + n - 1]);
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:   for (int i = 1; i <= n; ++ i) a[i + n] = a[i];
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:   for (int len = 2; len <= n + 1; ++ len) {  //这里有不同，因为两个位置合在一起是一个矩阵，所以选取个数为1是len = 2
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:       for (int i = 1, j; (j = i + len - 1) <= n << 1; ++ i) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:   			for (int k = i + 1; k < j; ++ k) f[i][j] = min(f[i][j], f[i][k] + f[k][j] + a[i] * a[k] * a[j]);
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:   > 题目本来应该用高精度，但是__int128也能混过去
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:   for (int len = 3; len <= n; ++ len) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:   	for (int i = 1, j; i + len - 1 <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:   		for (int k = i + 1; k < j; ++ k) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:   			__int128 t = f[i][k] + f[k][j] + a[i] * a[j] * a[k];
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  int n, a[N];
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  int f[N][N];  //数组
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  int g[N][N];  //区间i到j的最优值的方案的根，用于dfs
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  for (int len = 1; len <= n; ++ len) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:      for (int i = 1, j; i + len - 1 <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:              for (int k = i; k <= j; ++ k) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  				int l = (k == i ? 1 : f[i][k - 1]);
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:                  int r = (k == j ? 1 : f[k + 1][j]);
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:                  int t = l * r + a[k];
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  void dfs(int l, int r) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:      int mid = g[l][r];
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  int n, m = 8;  //n为切的刀数，m为矩阵大小
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  int pre[N][N];
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:      for (int i = 1; i <= m; ++ i) for (int j = 1; j <= m; ++ j) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  double get(int x1, int y1, int x2, int y2) {  //求一个小块的方差，幸好方差各个部分独立，并且此问题均值全局
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:  double dfs(int k, int x1, int y1, int x2, int y2) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:      for (int i = x1; i < x2; ++ i) {
./Algorithm/Dynamic-Programming/动态规划3区间DP.md:      for (int i = y1; i < y2; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:  for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      for (int j = 0; j <= m; ++ j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:  for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      for (int j = m; j >= w[i]; -- j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      int ans = m;
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:    for (int j = m; j >= w[i]; -- j) cnt[j] += cnt[j - w[i]];
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:for (int i = 1; i <= n; ++ i) 
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:    for (int j1 = m1; j1 >= w1[i]; -- j1)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:        for (int j2 = m2; j2 >= w2[i]; -- j2)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:   for (int j = 0; j <= m; ++ j) cnt[j] = 1;
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:   for (int i = 1; i <= n; ++ i) 
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:       for (int j = m; j >= w[i]; -- j) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:   for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:       for (int j = m; j >= w[i]; -- j) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:   int res = 0; for (int j = 0; j <= m; ++ j) res = max(res, f[j]); //因为不知道最优方案会是多少体积
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:   int ans = 0; for (int j = 0; j <= m; ++ j) if (f[j] == res) ans += cnt[j];
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:int j = m;
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:for (int i = n; i >= 1; -- i) 
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:  for (int i = 1; i <= n; ++ i) 
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      for (int j = 0; j <= m; ++ j) 
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:          for (int k = 0; k * w <= j; ++ k)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:  for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      for (int j = 0; j <= m; ++ j) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:  for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      for (int j = w[i]; j <= m; ++ j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:    for (int j = w[i]; j <= m; ++ j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:  for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      for (int j = 0; j <= m; ++ j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:          for (int k = 0; k <= c[i]; ++ k) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:  for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      for (int j = m; j >= w[i]; -- j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:          for (int k = 1; k <= c[i] && k * w[i] <= j; ++ k)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:    for (int k = 1; k <= c[i]; k <<= 1) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:        for (int j = m; j >= k * w[i]; -- j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:        for (int j = m; j >= c[i] * w[i]; -- j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:int f[背包容量], g[背包容量];  // 拷贝数组<-滚动数组
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:int qq[背包容量], hh, tt;  // 数组模拟优先队列
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:    for (int j = 0; j < w[i]; ++ j) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:		for (int k = j; k <= m; k += w[i]) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:    for (int j = 0; j <= 背包容量; ++ j) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:        for (int k = 1; k <= 这组的物品个数; ++ k) {  // 枚举该组的每一个
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:  for (int i = 1; i <= n; ++ i)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:      for (int j = m; j >= 0; -- j)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:          for (int k = 1; k <= 这组的物品个数; ++ k)
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:   void dfs(int node) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:       for (int son : g[node]) {
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:           for (int j = m - w[node]; j >= 0; -- j) {  //枚举可用重量，相当于普通01背包的枚举容量
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:               for (int k = 0; k <= j; ++ k) // 枚举决策
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:       for (int j = m; j >= w[node]; -- j) f[node][j] = f[node][j - w[node]] + v[node];  // node必须选择
./Algorithm/Dynamic-Programming/动态规划0背包问题.md:       for (int j = 0; j < w[node]; ++ j) f[node][j] = 0;  // node必须选择
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    int d1[N], d2[N];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    void dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    //dfs(1, 1); for (int i = 1; i <= n; ++ i) ans = max(ans, d1[i] + d2[i]);
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    int ans;
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    int dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:        int res = 0;
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:        int d1 = 0, d2 = 0;
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:        for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:            int d = dfs(son, node) + val[e];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  int anslen, ansnum;
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  int d[N], num[N];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  void dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  	for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  		int t = d[son] + val[e];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  int n;  //树的大小
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  int tar = -1, num = INF;
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  int dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:      int res = 0;
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:      int sons = 1;
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:      for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:          int t = dfs(son, node);
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:int sz[N], fa[N], ans[N], hson[N];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:void dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    int res = ans[hson[node]];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    int tar = sz[node] >> 1;  // 删除重心，各子树大小不超结点数一半
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:int d1[N], d2[N], up[N];  //含义如分析
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:int p[N];  //p[father]表示father的d1[]来自哪个儿子
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:void dfs_d(int node, int father) {  //通过回溯完善down
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:void dfs_u(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:/*int ans = -1, big = INF;  //记录记录中心和它到其他节点的最远距离
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:  for (int i = 1; i <= n; ++ i) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:      int t = max(d1[i], up[i]);
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:int m;
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:int f[N][M];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:void dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:    for (int son, e = head[node]; e; e = lext[e]) {  //物品组
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:        for (int j = m; j >= 0; -- j) {   //体积
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:            for (int k = 0; k < j; ++ k) {   //方案
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:   int f[N][2];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:   void dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:       for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:   int f[N][2];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:   void dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:       for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:   int f[N][3];
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:   void dfs(int node, int father) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:       for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Dynamic-Programming/动态规划2树上DP.md:       for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Search/Search.md:    void dfs(int u = 1) {  // u为考虑a[u]要不要选
./Algorithm/Search/Search.md:    void dfs(int u = 1) {  // u为考虑b[u]这个位置选哪个
./Algorithm/Search/Search.md:        for (int i = 1; i <= n; ++ i) if (! vis[i]) {
./Algorithm/Search/Search.md:    int id[N] = {1};
./Algorithm/Search/Search.md:    void dfs(int u = 1) {  // u为考虑b[u]这个位置选哪个, 为保证不重不漏, 单调选择
./Algorithm/Search/Search.md:        for (int i = id[u - 1]; i <= n; ++ i) if (! vis[i]) {
./Algorithm/Search/Search.md:  int dis[N];
./Algorithm/Search/Search.md:  int pj(int tar) {
./Algorithm/Search/Search.md:      deque<int> dqu;
./Algorithm/Search/Search.md:          int node = dqu.front(); dqu.pop_front();
./Algorithm/Search/Search.md:          for (int son, e = head[node]; e; e = lext[e]) {
./Algorithm/Search/Search.md:              int len = val[e] > tar;
./Algorithm/Search/Search.md:int st, ed;  //起点和终点
./Algorithm/Search/Search.md:struct edge { int to, val; };
./Algorithm/Search/Search.md:int K;  //题目要求的K `if (st == ed) ++ K`
./Algorithm/Search/Search.md:int f[N];
./Algorithm/Search/Search.md:struct point {
./Algorithm/Search/Search.md:    int f, dis, x;  //分别是（到终点的）估计值、（到起点的）真实值、结点编号
./Algorithm/Search/Search.md:    bool operator < (const point & t) const {  // 评估函数
./Algorithm/Search/Search.md:int cnt[N];
./Algorithm/Search/Search.md:int astar() {
./Algorithm/Search/Search.md:    priority_queue<point> heap;
./Algorithm/Search/Search.md:        int node = heap.top().x, dist = heap.top().dis; heap.pop();
./Algorithm/Search/Search.md:            int son = e.to, val = e.val;
./Algorithm/C++.md:+ `__int128`：空间两倍于`long long`，需自定义IO，支持整数运算符
./Algorithm/C++.md:  int __builtin_clz(unsigned int);  // 前导0的个数
./Algorithm/C++.md:  int __buildin_ctz(unsigned int);  // 后缀0的个数
./Algorithm/C++.md:  int __builtin_ffs(unsigned int);  // 后缀0的个数+1(最后一个1的位置, 索引从1开始)
./Algorithm/C++.md:  int __buildin_popcount(unsigned int);  // 1的个数
./Algorithm/C++.md:      static uint64_t splitmix64(uint64_t x) {
./Algorithm/C++.md:      size_t operator()(uint64_t x) const {
./Algorithm/C++.md:          static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
./Algorithm/C++.md:  unordered_map<int, int, custom_hash> mp;
