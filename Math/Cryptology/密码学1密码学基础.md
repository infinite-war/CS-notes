# 概述

+ 密码学分支：

  ```mermaid
  graph LR;
  	root["密码编码学(cryptology)"]
  	lson["密码使用学(cryptograpth)"]
  	rson["密码分析学"]
  	
  	root --> lson
  	root --> rson
  	
  	sam1["对称密码(Symmetric Algotiyhm)"]
  	sam2["非对称密码(Asymmetric Algotirhm)<br>公钥算法(Public-Key Algorithm)"]
  	sam3["密码协议"]
  	
  	lson --> sam1
  	lson --> sam2
  	lson --> sam3
  	
  	new1["分组密码(Stream Ciphers)"]
  	new2["序列密码"]
  	
  	sam1 --> new1
  	sam1 --> new2
  ```

  > 1949年之前称为古典密码学，1976年提出公钥密码学，之后称现代密码学。

  + hp密码协议/密码体制：密码学算法的应用。

    > 实际的加密应用使用混合方案

  + 密码分析学：

    ```mermaid
    graph LR;
    	root["密码分析学"]
    	son1["古典/经典密码分析(Classical Cryptanalysis)"]
    	son2["实施攻击(Implementation Attack)"]
    	son3["社会工程(Socail Engineering Attack)"]
    	le1["数学分析法"]
    	le2["蛮力攻击法"]
    	
    	root --> son1
    	root --> son2
    	root --> son3
    	son1 --> le1
    	son1 --> le2
    ```

    + 经典密码分析：将密文恢复到明文/从密文中恢复出密钥

      1. 数学分析：发现加密方法内部结构
      2. 蛮力攻击：把加密算法作为黑盒，测试所有可能密钥

    + 实施攻击：对于从==旁道==获得的密钥，针对旁道/物理进行攻击

      > 旁道：处理器功耗、电磁辐射

    + 社会工程攻击：通过行贿、勒索、跟踪或刑侦等手段获得密钥

+ **Kerckhoffs原理**：即使除密钥外的整个系统的一切都是公开的， 这个密码体制也必须是安全的。

  ​                              尤其是即使攻击者知道系统的加密算法和解密算法，此系统也必须是安全的

  密码算法/体制  ：算法一般是公开的，虽然算法不公开更有利于保密，但是算法是未被测试的算法，把其公开更有利于对其分析

  1. 密码体制易被==逆向工程==破解

+ 密钥长度：

  + 只在只能暴力的情况下，才讨论密钥长度，
  + 数学分析法或者社会工程/实施攻击则不关心密钥长度
  + 不同算法要求的密钥长度不同

## 模运算

+ ：$x \mid y \text{表示}x\text{整除}y$

+ 定义：
  $$
  假设a, r, m \in Z \text（其中Z是所有整数的集合），并且m > 0。如果 m 除 a-r \\
  可记作：  \hfill \\
  a \equiv r \ mod \ m \\
  \hfill  其中 m 称为模数，r称为余数
  $$
  推导：
  $$
  存在 a \in Z，使得 \hfill \\
  a = q * m + r, 其中0 \le r < m \\
  由于a - r = q * m(m除a - r)，上述表达式可写作：\\
  a \equiv r \ mod \ m(r \in {0, 1, 2, ..., m - 1})
  $$
  
+ 性质：

  + 等价类：对于给定模数m，有一个数集的任何一个元素对其取余结果同，该数集内元素为一个等价类

  + 运算性质：分配律：加减法、乘法，没有除法

    + 乘法逆元：$a^{-1}$：不是指a的倒数，是逆元的特殊符号：$a \times a^{-1} \equiv 1 \ mod \ m$，要求$gcd(a, \ m) = 1$（如果不互素无解）

      > 用途：$(a / b)(mod \ m) = a * b^{-1}(mod \ m)$继而可使用分配律

+ 移位密码：
  $$
  e_k(x) = x + k \ mod \ m \\
  d_k(y) = y - k \ mod \ m
  $$

  + 密钥空间：m

+ 仿射密码：
  $$
  e_k(x) = y \equiv a * x + b \ mod \ m \\
  d_k(y) = x \equiv a ^ {-1} * (y - b) \ mod \ m\\
  k = (a, b), 且gcd(a, m) = 1
  $$

  + 密钥空间：$a ^ {-1}的取值范围 \times m$

# 对称密码学

+ 别名：对称密码、对称密钥(Symmetric-key)、秘密密钥(Secret-key)、单密钥(Single-key)方案/算法

+ 概念：

  + 明文(plaintext/cleartext) $x$：

  + 密文(ciphertext) $y$：

  + 密钥(key) $k$：

    > 加密：$e_k(x) \rightarrow y$、解密：$d_k(y) \rightarrow x$

    + 密钥空间(key space)：所有可能密钥组成的集合

+ 替换密码方法：加密文本：密钥：替换表；算法：替换文本。

  + 攻击方式：
    1. 蛮力攻击/穷尽密钥搜索：已知一段明文及其位置，遍历密钥空间，查看是否替换正确
    2. 字母频率分析：字母占比，不用字符组合占比，高频短词占比

+ 对称密码学：将每个明文映射为一个数位序列
  + 序列密码：单独加密每个位
    + 同步序列密码：仅取决于密钥
    + 异步序列密码：取决于密文和密钥
  + 分组密码：使用相同的密钥加密整个明文位分组

## 序列密码

+ 加密和解密的方案：加法模2——XOR运算：算法可逆+结果概率相同（异或的性质）

#### 随机数

+ 随机数生成器（RNG）：

  + 真随机数生成器（TRNG）：输出几乎不可复制，基于物理过程
  + （通用的）伪随机数生成器（PRNG）：从一个初始种子值通过计算得到序列
    + 线性同余生成器
      $$
      S_0 = seed \hfill \\ 
      S_{i = 1} \equiv AS_{i} + B \ mod \  m, \ i = 0, 1 \hfill
      $$
    
  + 加密安全的伪随机数发生器（CSPENG）：PRNG的特例
    + 给定连续位，不存在一个时间复杂度为多项式的算法使得成功预测下一位的概率超过50%

> + 无条件安全：密码体制在无限计算资源的情况下仍不能破译
>
>   计算安全：如果破解一个密码体制，**最好的已知**算法需要至少t个操作
>
>   + 比较：10k位，在无限资源下，$2^{10k}$台计算机，但已知宇宙不过$2^{266}$个原子，这种密钥是计算安全。
>
> + 一次一密(OTP)：无条件安全
>
>   + 通过真随机数生成器得到密钥序列  ——要有TRNG
>   + 只有合法的通信方才知道密钥序列  ——密钥如何传递
>   + 每个密钥序列位仅使用一次             ——与明文一样长的密钥

+ 利用PRNG构建密码流：不可行

  + 守：使用基于线性同余发生器的PRNG
    1. 密钥包含系数、常数，可能包含种子，模数是加密方案的一部分

  + 攻：知道明文的前若干位，同时显然知道密文，从而可计算密钥的前若干位，如果此若干位足够得到PRNG的前3组输出符号，即可组成包含两个等式的线性等式系统，从而得到密钥（系数和常数）

    > 可能有多解，但如果得到再多一组，就能保证唯一解

+ 利用CSPRNG构建密钥序列：可解决上述问题，关键仍是随机数的生成

### LFSR

线性反馈移位寄存器(LFSR)：一种密钥流生成器，本质仍是随机数的创造

+ 组成：若干时钟存储元件（触发器）和一个反馈路径组成

  + 度：存储元件的个数
  + 反馈为系统中某些触发器的XOR和

+ 数学描述：

  <img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/LFSR数学描述.jpg" style="zoom: 67%;" />

  <img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/LFSR数学描述2.jpg" style="zoom:67%;" />

  + 其中$p$是一种开关，将选择的数进行累异或，从而得到新位（之前的位右移，多余的位为新密钥位）
  + 最大序列长度：$2^m - 1$
  + 上述的反馈系数向量$(p_{m - 1}, ..., p_1, p_0)$可表示为$P(x) = x^m + p_{m - 1}x^(m - 1) + ... + p_1x + p_0$
    + 作用：本源多项式(primitive polynomial)：不可约分的多项式

+ 实际应用：密钥即为反馈系数向量

+ 攻击：获得一定的明文密文，尝试可能的LFSR的度，分别建立对应数目的线性等式系统（解此很快）；

  ​           若确定度的大小，反馈系数即可得。

#### Trivium

+ 密钥长度80位，基于三个反馈移位寄存器（长度分别为93+84+111=288）

### eSTREAM项目

## 分组密码

+ 数据加密标准(Data Encryption Standard, DES)：主流的分组密码，是研究最透彻的对称算法
+ 强加密算法：
  + 混淆(Confusion)：使密钥与密文之间的关系尽可能模糊的加密操作
  + 扩散(Diffusion)：为了隐藏明文的统计属性而将一个明文符号的影响扩散到多个密文符号的加密操作

+ 操作模式：加密模式：
  + 电子密码本模式(electronic code book mode, ECB)：将明文划分为定长等份（不足填充），对组进行加密，加密方式和解密方式可逆
    + 优点：分组可异步，噪音只影响单组，可并行处理
    + 缺点：加密高度确定，流量分析识别密文是否传输多次，分组独立
  + 密码分组链接模式(CBC)：
  + 输出反馈模式(OFB)：
  + 密码反馈模式(CFB)：
  + 计数器模式(CTR)：

### DES算法

+ 概念：

  + 使用56位密钥对64位长分组进行加密的密码
  + 对称密码——加密和解密使用相同的密钥
  + 迭代算法：对每组的加密过程包含**16轮**，每轮的**操作**完全相**同**，使用不同**子密钥**，子密钥从主密钥中推导出来
  + 算法流程：Feistel网络：<img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/Feistel网络.jpg" style="zoom: 67%;" />
  
    + $f$函数加密：<img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/f.jpg" style="zoom:66%;" />子密钥推导<img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/DES密钥移位.jpg" style="zoom:67%;" />

> 置换表：每个位置有个数字，即为这个位置的数字本来的位置

+ 对于明文64位和密钥64位：

  1. 对明文进行$\text{IP}$置换64位
  2. 对密钥进行$\text{PC}^{-1}$置换56位：密钥每8位在末尾设置奇偶校验位，在此消去，并置换

  + 16轮加密：

    1. 密钥56位的循环：

       1. 分成左右两部分CD组：分别进行移位（**移位位数与加密轮次有关**），结果作为下一轮的密钥
       2. 结果作为下一轮的密钥
       3. 结果做$\text{PC}^{-2}$置换得到子密钥48位进行加密

    2. 明文64位的处理：

       1. 分成左右两部分32位：

          + Left经过与$f$函数的输出结构异或成为下一轮Right
          + Right和子密钥一起进入$f$函数，同时本身成为下一轮Left，

       2. $f$函数：输入明文（Right32位和子密钥48位）

          1. 扩充$E(R_{i - 1})$48位：存在一位对两位的**扩散**

          2. 与子密钥异或48位

          3. 进入$S\text{-盒}$：非线性，算法的关键

             1. 48位分8组并编号6位
             2. 每组的6位：首尾形成二进制做对应S-盒的行，中间四位形成二进制做对应S-和的列
             3. 取出对应S-盒对应位置的**十进制数**
             4. 将十进制化为二进制4位

             合并32位

          4. 置换$\text{P}$32位

+ 攻击：
  + 穷尽密钥搜索攻击：因DES密钥空间小
  + 分析攻击：
+ 实现：
  1. 软件
  2. 硬件

#### DES替换

+ 3DES和DESX
+ 轻量级密码PRESENT

### AES算法

#### 伽罗瓦域

# 公钥密码学

+ ==**作用：密钥分发；数字签名（不可否认）**==

> 对称密码学的缺点：
>
> + 密钥分配问题：建立安全的密钥信道
> + 密钥数量问题：每个传输都需要一个密钥
> + 对用户的欺骗没有防御机制（不可否认性）：外界不能确定信息是否传递
>
> 非对称密码学可解决这些问题，代价就是速度相对慢

+ 单项函数：$f(x)$计算规模可接受、$f^{-1}(x)$计算规模极大
  + 整数分解：给定素数计算乘积容易，但给定乘积，还原则不容易
  + 离散对数：

+ 安全机制：

  + 密钥建立：在不安全信道上建立密钥

    > 相关协议：Diffie-Hellman密钥交换(DHKE)协议或RSA密钥传输协议

  + 不可否认性：可通过数字签名算法实现不可否认性和消息完整性

    > 相关算法：RSA、DSA或ECDSA

  + 身份标识：使用质询-响应协议与数字签名相结合的方法识别实体

  + 加密

+ 公钥算法分类：基于数论函数

  > 对称算法极多

  + 整数分解方案：基于事实：因式分解大整数是极困难的
  + 离散对数方案
  + 椭圆曲线（EC）方案

  安全等级（与对称密码比较）：<img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/公钥密码等级.jpg" style="zoom:60%;" />


## 数学基础

+ 欧拉定理：若整数a与整数N互素，则
  $$
  \mathop{\forall}\limits_{a : gcd(a, N) = 1} a^{\phi{(N)}} \equiv 1 (mod \ N)
  $$
  
+ 扩展欧几里得见数论笔记

## RSA密码体制

+ RSA密码：Rivest-Shamir-Adleman算法，最广泛的非对称密码方案

  + 应用：

    + 数据小片段的加密，尤其用于密钥传输
    + 数字签名

    不是取代对称密码，因为其速度更慢，所以用来传输对称密码的密钥

  + 单项函数：两个大素数相乘简单，对其成绩结果的因式分解很困难

+ RSA

  + RSA加密：$给定公钥(n, e) = k_{pub}和明文x，则加密函数为： \hfill \\ y = e_{k_{pub}}(x) \equiv x^e mod \ n \\ 其中x, y \in \mathbb{Z}_n \hfill $。
  + RSA解密：$给定私钥d  = k_{pr} 及密文y，则解密函数为： \hfill \\ x = d_{k_{pr}}(y) \equiv y^d mod \ n \\ 其中x, y \in \mathbb{Z}_n \hfill $。

  其中x、y、n、d都是长数字，

  + 值e称为加密指数/公开指数

    私钥d称为解密指数/保密指数

+ RSA密钥生成：

  输出：公钥：$K_{pub} = (n, e)$和私钥：$k_{pr} = (d)$

  1. 选择两个素数 $p$ 和 $q$
  
  2. 计算得到$n = p \times q$
  
     计算得到$\Phi(n) = (p - 1) \times (q - 1)$

  3. 选择满足条件的公开指数$e \in \{1, 2, ..., \Phi(n) - 1\} \ \and \ gcd(e, \Phi(n)) = 1$
  
  4. 计算满足条件的私钥$d$：$d \times e \equiv 1 \ mod \ \Phi(n)$
  
  + 4中私钥就是公钥的逆元
  + 3中保证公钥有逆元
  
+ 使用：选取合适的两个大素数，计算$n 和 \Phi$，选择合适的`e`，公布n和e，通过外界不知的$\Phi$计算外界不知的$d$，外界可以通过公钥进行加密和自己通信，只有自己可以通过私钥对密文进行解密；多人建立多个系统

### 计算加速

+ 取幂运算的加速

  > 快速乘




$$
我们将指数的十进制表示变成二进制 \hfill \\
res = base^{ide_{十进制}} = base^{(b_n \ b_{n - 1} \ ... \ b_{2} \ b_{1} \ b_{0})_{二进制} } \\
由于n^{a + b} = n^a + n^b \hfill \\
可将上述结果拆分为 \hfill \\
res = base^{b_n0...000} + base^{0b_{n - 1}...000} + base^{00...b_200} + base^{00...0b_10} + base^{00...00b_0} \\ 
我们发现从左到右每个数的计算可以在O(log_2^n)的时间复杂度内递推，同时如果二进位b_i为1则表示对结果res有贡献 \hfill \\
综上即可将时间复杂度O(n)的指数运算在O(log_2^n)的时间复杂度内计算出来 \hfill
$$




+ 中国剩余定理：
  $$
  x = y^d \ mod \ n = y^d \ mod \ p * q \\
  如果 \hfill \\ 
  x_1 = y^d \ mod \ p \\ 
  x_2 = y^d \ mod \ q \\
  $$

  $$
  \begin{align}
  x &= y^d * sam + y^d * sam \hfill \\
    &= y^d * sam * sam^{-1} + y^d * sam * sam^{-1} \hfill \\
    &= y^d * q * q^{-1}(mod \ p意义下的) + y^d * p * p^1(mod \ q意义下的)
  \end{align}
  $$

### 大素数

+ 素数的普遍性：$P(p为质数)\approx \frac{1}{ln(p)}$

#### 大素数判定

> 精确的$O(\sqrt{n})$算法在n非常大的时候仍然无法使用，下面提供一种$O(log_2n)$的**概率**算法

+ 费马小定理：$如果p是素数，1 \le a \le p - 1, 则 \hfill \\ a^{p - 1} \equiv 1 \ (mod \ p)$，那么对于其逆定理，是否是真命题呢？不成立，但大概率符合

  + 如果一个数符合费马小定理中的行为，那么它有概率（大于1/2）是素数

  + 卡迈尔克数$C$：这些合数在费马定理中的行为和素数一样，又称为**伪素数**（在前10亿个自然数出错的可能性是0.011）

    > 对于特定的a，有一些合数可以通过测试，又称它们为以a为底的伪素数

+ 二次检测定理：$如果p是素数，0 < x < p，则 \\ 如果x^2 = 1(mod \ p)成立，则x = 1或x = p - 1$，那么找一些x其取方模p都不是1，p是不是素数呢？不一定

+ Miller-Rabin素性判定：运用费马小定理和二次检测定理的概率算法

#### 大素数生成

### 攻击

#### 填充

> RSA的问题：
>
> 1. 加密函数是**确定**的——规律性
> 2. x = 0, x = 1, x = -1的产生的密文分别是0、1或-1
>
> + RSA具有一个不可取的属性：malleable延展性
>
>   > 延展性：攻击者可将密文转换为另一个密文，而新密文会导致对明文进行的变换变得可知
>
>   虽然攻击者不能破解，但能定向修改，比如扩大倍数

+ 填充padding：

------

1. 协议攻击：对RSA算法本身的攻击

2. 数学分析攻击：

   + 对数模进行因式分解

     > 情报机构可能已经实现了对1024位模数的数字进行因式分解，所以建议选择长度2048~4096位的RSA参数

3. 旁道攻击：

   1. 功率分析SPA：观察微处理器，RSA快速幂的负载特点是均匀乘方，遇1乘法，所以可以通过观察得知指数的01分布
      + 解决：遇到0执行一个虚拟变量的乘法

## Diffie-Hellman

> RSA基于大整数因式分解——一个单项函数
>
> Diffie-Hellman密钥交换基于**求解离散对数问题**(Discrete Logarithm Problem, DLP)

+ Diffie-Hellman密钥交换(DHKE)

  > + 公开文献中发布的第一个非对称方案
  > + 应用技术：安全外壳SSH、传输层安全TLS、Internet协议安全IPSec

+ DHKE协议：

  1. 握手协议：

     1. 选择一个大素数$p$
     2. 选择一个整数$\alpha \in \{2, 3, \dots, p - 2\}$
     3. 公开p和a

     域参数p和a

  2. 密钥交换：

     1. a：选择$a = k_{pr, A} \in \{2, \dots, p - 2\}$

        b：选择$b = k_{pr, B} \in \{2, \dots, p - 2\}$

     2. 计算：$A = k_{pub, A} \equiv \alpha^a mpd \ p$

        计算：$B = k_{pub, B} \equiv \alpha^b mpd \ p$

     3. 交换

     4. 计算：$k_{AB} = k_{pub, b}^{k_{pr}, A} = B^a mod \ p$

        计算：$k_{AB} = k_{pub, A}^{k_{pr}, B} = A^b mod \ p$

  密钥是两个互不知的两个数做指数，得到一个共知的密钥

  + 密钥选择为什么不选1和p-1
    1. 为什么不选1：幂不变，只需要知道另一个人的密钥即可破解
    2. 为什么不选p-1：由费马小定理$\alpha^{p - 1} \equiv 1 \ mod \ p$，效果同选1
  + 注意：$\alpha^{a \ b} \neq \alpha^a \times \alpha^b = \alpha^{a + b}$

### 数学基础

+ $\mathbb{Z}^{*}_p$内的指数运算（$p$是素数）是单项函数，并且该指数运算时可交换的：$k = (a^x)^y\equiv (a^y)^x mod \ p$


#### 群

+ 定义：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/群.jpg)
  + 操作符为乘法即为乘法群，操作符为加法即为加法群

+ 重要的群：乘法群==？==：$\mathbb{Z}^{*}_n$：

  ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/重要的群.jpg)

+ 有限群：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/有限群.jpg)

+ 元素的阶：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Math/Cryptology/元素的阶.jpg)

> 给一（乘法）群 求所有元素 的阶：
>
> 1. 求出所有元素：在0~n - 1中和n互素的数
> 2. 每个元素的阶：对算法递增**取幂模n**，阶 为 出现过的不同的数的个数（注意因为是取模，所以和循环）
>
> ```c++
> int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
> void get(int n) {
> 	printf("%d : \n", n);
> 	for (int i = 0; i < n; ++ i) if (gcd(n, i) == 1) {
> 		vector<int> vis(n, 0);
> 		int res = 0;
> 		for (int t = i; ! vis[t]; t = (t * i) % n) ++ res, vis[t] = 1;
> 		printf("\tord(%d) = %d\n", i, res);
> 	}
> }
> ```

+ $\alpha^x \equiv \beta \ mod \ p$：给定alpha，选x，做beta——快

  $x \equiv log_{\alpha}{\beta} \ mod \ p$：知道alpha，找到beta，求x不容易
