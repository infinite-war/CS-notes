

+ ==**作用：密钥分发；数字签名（不可否认）**==

> 对称密码学的缺点：
>
> + 密钥分配问题：建立安全的密钥信道
> + 密钥数量问题：每个传输都需要一个密钥
> + 对用户的欺骗没有防御机制（不可否认性）：外界不能确定信息是否传递
>
> 非对称密码学可解决这些问题，代价就是速度相对慢

+ 单项函数：$f(x)$计算规模可接受、$f^{-1}(x)$计算规模极大
  + 整数分解：给定素数计算乘积容易，但给定乘积，还原则不容易
  + 离散对数：

+ 安全机制：

  + 密钥建立：在不安全信道上建立密钥

    > 相关协议：Diffie-Hellman密钥交换(DHKE)协议或RSA密钥传输协议

  + 不可否认性：可通过数字签名算法实现不可否认性和消息完整性

    > 相关算法：RSA、DSA或ECDSA

  + 身份标识：使用质询-响应协议与数字签名相结合的方法识别实体

  + 加密

+ 公钥算法分类：基于数论函数

  > 对称算法极多

  + 整数分解方案：基于事实：因式分解大整数是极困难的
  + 离散对数方案
  + 椭圆曲线（EC）方案

  安全等级（与对称密码比较）：<img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Math/Cryptology/公钥密码等级.jpg" style="zoom:60%;" />


## 数学基础

+ 欧拉定理：若整数a与整数N互素，则
  $$
  \mathop{\forall}\limits_{a : gcd(a, N) = 1} a^{\phi{(N)}} \equiv 1 (mod \ N)
  $$
  
+ 扩展欧几里得见数论笔记

## RSA密码体制

+ RSA密码：Rivest-Shamir-Adleman算法，最广泛的非对称密码方案

  + 应用：

    + 数据小片段的加密，尤其用于密钥传输
    + 数字签名

    不是取代对称密码，因为其速度更慢，所以用来传输对称密码的密钥

  + 单项函数：两个大素数相乘简单，对其成绩结果的因式分解很困难

+ RSA

  + RSA加密：$给定公钥(n, e) = k_{pub}和明文x，则加密函数为： \hfill \\ y = e_{k_{pub}}(x) \equiv x^e mod \ n \\ 其中x, y \in \mathbb{Z}_n \hfill $。
  + RSA解密：$给定私钥d  = k_{pr} 及密文y，则解密函数为： \hfill \\ x = d_{k_{pr}}(y) \equiv y^d mod \ n \\ 其中x, y \in \mathbb{Z}_n \hfill $。

  其中x、y、n、d都是长数字，

  + 值e称为加密指数/公开指数

    私钥d称为解密指数/保密指数

+ RSA密钥生成：

  输出：公钥：$K_{pub} = (n, e)$和私钥：$k_{pr} = (d)$

  1. 选择两个素数 $p$ 和 $q$
  
  2. 计算得到$n = p \times q$
  
     计算得到$\Phi(n) = (p - 1) \times (q - 1)$

  3. 选择满足条件的公开指数$e \in \{1, 2, ..., \Phi(n) - 1\} \ \and \ gcd(e, \Phi(n)) = 1$
  
  4. 计算满足条件的私钥$d$：$d \times e \equiv 1 \ mod \ \Phi(n)$
  
  + 4中私钥就是公钥的逆元
  + 3中保证公钥有逆元
  
+ 使用：选取合适的两个大素数，计算$n 和 \Phi$，选择合适的`e`，公布n和e，通过外界不知的$\Phi$计算外界不知的$d$，外界可以通过公钥进行加密和自己通信，只有自己可以通过私钥对密文进行解密；多人建立多个系统

### 计算加速

+ 取幂运算的加速

  > 快速乘




$$
我们将指数的十进制表示变成二进制 \hfill \\
res = base^{ide_{十进制}} = base^{(b_n \ b_{n - 1} \ ... \ b_{2} \ b_{1} \ b_{0})_{二进制} } \\
由于n^{a + b} = n^a + n^b \hfill \\
可将上述结果拆分为 \hfill \\
res = base^{b_n0...000} + base^{0b_{n - 1}...000} + base^{00...b_200} + base^{00...0b_10} + base^{00...00b_0} \\ 
我们发现从左到右每个数的计算可以在O(log_2^n)的时间复杂度内递推，同时如果二进位b_i为1则表示对结果res有贡献 \hfill \\
综上即可将时间复杂度O(n)的指数运算在O(log_2^n)的时间复杂度内计算出来 \hfill
$$




+ 中国剩余定理：
  $$
  x = y^d \ mod \ n = y^d \ mod \ p * q \\
  如果 \hfill \\ 
  x_1 = y^d \ mod \ p \\ 
  x_2 = y^d \ mod \ q \\
  $$

  $$
  \begin{align}
  x &= y^d * sam + y^d * sam \hfill \\
    &= y^d * sam * sam^{-1} + y^d * sam * sam^{-1} \hfill \\
    &= y^d * q * q^{-1}(mod \ p意义下的) + y^d * p * p^1(mod \ q意义下的)
  \end{align}
  $$

### 大素数

+ 素数的普遍性：$P(p为质数)\approx \frac{1}{ln(p)}$

#### 大素数判定

> 精确的$O(\sqrt{n})$算法在n非常大的时候仍然无法使用，下面提供一种$O(log_2n)$的**概率**算法

+ 费马小定理：$如果p是素数，1 \le a \le p - 1, 则 \hfill \\ a^{p - 1} \equiv 1 \ (mod \ p)$，那么对于其逆定理，是否是真命题呢？不成立，但大概率符合

  + 如果一个数符合费马小定理中的行为，那么它有概率（大于1/2）是素数

  + 卡迈尔克数$C$：这些合数在费马定理中的行为和素数一样，又称为**伪素数**（在前10亿个自然数出错的可能性是0.011）

    > 对于特定的a，有一些合数可以通过测试，又称它们为以a为底的伪素数

+ 二次检测定理：$如果p是素数，0 < x < p，则 \\ 如果x^2 = 1(mod \ p)成立，则x = 1或x = p - 1$，那么找一些x其取方模p都不是1，p是不是素数呢？不一定

+ Miller-Rabin素性判定：运用费马小定理和二次检测定理的概率算法

#### 大素数生成

### 攻击

#### 填充

> RSA的问题：
>
> 1. 加密函数是**确定**的——规律性
> 2. x = 0, x = 1, x = -1的产生的密文分别是0、1或-1
>
> + RSA具有一个不可取的属性：malleable延展性
>
>   > 延展性：攻击者可将密文转换为另一个密文，而新密文会导致对明文进行的变换变得可知
>
>   虽然攻击者不能破解，但能定向修改，比如扩大倍数

+ 填充padding：

------

1. 协议攻击：对RSA算法本身的攻击

2. 数学分析攻击：

   + 对数模进行因式分解

     > 情报机构可能已经实现了对1024位模数的数字进行因式分解，所以建议选择长度2048~4096位的RSA参数

3. 旁道攻击：

   1. 功率分析SPA：观察微处理器，RSA快速幂的负载特点是均匀乘方，遇1乘法，所以可以通过观察得知指数的01分布
      + 解决：遇到0执行一个虚拟变量的乘法

## Diffie-Hellman

> RSA基于大整数因式分解——一个单项函数
>
> Diffie-Hellman密钥交换基于**求解离散对数问题**(Discrete Logarithm Problem, DLP)

+ Diffie-Hellman密钥交换(DHKE)

  > + 公开文献中发布的第一个非对称方案
  > + 应用技术：安全外壳SSH、传输层安全TLS、Internet协议安全IPSec

+ DHKE协议：

  1. 握手协议：

     1. 选择一个大素数$p$
     2. 选择一个整数$\alpha \in \{2, 3, \dots, p - 2\}$
     3. 公开p和a

     域参数p和a

  2. 密钥交换：

     1. a：选择$a = k_{pr, A} \in \{2, \dots, p - 2\}$

        b：选择$b = k_{pr, B} \in \{2, \dots, p - 2\}$

     2. 计算：$A = k_{pub, A} \equiv \alpha^a mpd \ p$

        计算：$B = k_{pub, B} \equiv \alpha^b mpd \ p$

     3. 交换

     4. 计算：$k_{AB} = k_{pub, b}^{k_{pr}, A} = B^a mod \ p$

        计算：$k_{AB} = k_{pub, A}^{k_{pr}, B} = A^b mod \ p$

  密钥是两个互不知的两个数做指数，得到一个共知的密钥

  + 密钥选择为什么不选1和p-1
    1. 为什么不选1：幂不变，只需要知道另一个人的密钥即可破解
    2. 为什么不选p-1：由费马小定理$\alpha^{p - 1} \equiv 1 \ mod \ p$，效果同选1
  + 注意：$\alpha^{a \ b} \neq \alpha^a \times \alpha^b = \alpha^{a + b}$

### 数学基础

+ $\mathbb{Z}^{*}_p$内的指数运算（$p$是素数）是单项函数，并且该指数运算时可交换的：$k = (a^x)^y\equiv (a^y)^x mod \ p$


#### 群

+ 定义：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Math/Cryptology/群.jpg)
  + 操作符为乘法即为乘法群，操作符为加法即为加法群

+ 重要的群：乘法群==？==：$\mathbb{Z}^{*}_n$：

  ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Math/Cryptology/重要的群.jpg)

+ 有限群：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Math/Cryptology/有限群.jpg)

+ 元素的阶：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Math/Cryptology/元素的阶.jpg)

> 给一（乘法）群 求所有元素 的阶：
>
> 1. 求出所有元素：在0~n - 1中和n互素的数
> 2. 每个元素的阶：对算法递增**取幂模n**，阶 为 出现过的不同的数的个数（注意因为是取模，所以和循环）
>
> ```c++
> int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
> void get(int n) {
> 	printf("%d : \n", n);
> 	for (int i = 0; i < n; ++ i) if (gcd(n, i) == 1) {
> 		vector<int> vis(n, 0);
> 		int res = 0;
> 		for (int t = i; ! vis[t]; t = (t * i) % n) ++ res, vis[t] = 1;
> 		printf("\tord(%d) = %d\n", i, res);
> 	}
> }
> ```

+ $\alpha^x \equiv \beta \ mod \ p$：给定alpha，选x，做beta——快

  $x \equiv log_{\alpha}{\beta} \ mod \ p$：知道alpha，找到beta，求x不容易


## secp256k1椭圆曲线算法



ECDSA

secp256k1曲线

## NTR
