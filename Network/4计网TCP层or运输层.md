# 概述

![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/逻辑通信.png)  
从这张图我们可以看到
+ 只有主机的协议栈有运输层，而网络核心的路由器只有IP层以下
+ 网络层实现主机之间的逻辑通信，运输层为应用进程之间提供端到端的逻辑通信

+ 进程才是通信的真正主体：复用(multiplesing)：发送方不同应用进程都可使用同一个运输层协议传送数据，分用(demultiplexing)：接收方运输层在剥去报文首部后能够把数据正确交付目的的应用进程。

+ 两个对等传输实体在通信时传送的数据单位：
	+ OSI：运输协议数据单元TPDU(Transport Protocol Data Unit)
	+ TCP/IP：TCP报文段(segment)/UDP用户数据报

## 协议
>运输层新增第三种协议：流控制传输协议SCTP(Stream Control Transmission Protcol)\[RFC 4960\]

+ 用户数据报协议UDP(User Datagram Protocol)\[RFC 768\]
+ 传输控制协议TCP(Transmission Control Protoocol)\[RFC 793\]，面向连接、可靠全双工

![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/应用及其协议.png)

## 端口号

协议端口号(protocol prot number)，简称端口(port)：

+ 需求：
	+ 复用和分用的过程需要标志

	>计算机操作系统中使用进程标识符区分进程  
	>但是这个方法在计算机网络中是不可以的，因为操作系统类型多，这种标识符就多

	+ 进程的创建和撤销是动态的

	所以端口的作用就是消息交付到对应端口，然后再交付到对应进程

>这里是软件端口，不是硬件端口，是应用层的各个协议进程与运输实体进程层间交互的地址。

+ 格式：16位二进制（65535个）
+ 类型：
	1. 服务端使用的端口号：
		1. [wellknown port number熟知端口号/系统端口号](www.iana.org)：0~1023  
			![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/常用的熟知端口号.png)
			可在[这里](www.iana.org)查到，是IANA指派给TCP/IP最重要的应用程序的

		2. 登记端口号/短暂端口号：1024~49151  
			需要在IANA上登记避免重复

# 用户数据报协议UDP

+ 特点：
	1. UDP是**无连接的**，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延
	2. UDP使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表
	3. UDP的**面向报文**的：UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界  
		![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/UDP面向报文.png)

		因为不进行拆分，所以需要应用层控制报文大小平衡IP层性能

	4. UDP**没有拥塞控制**：对于要求恒定发送速率，允许丢失一些数据的应用
		>但也可能让网络拥塞

	5. UDP**支持一对一、一对多、多对一和多对多的交互通信**
	6. UDP的**首部开销小**：只有8个字节，比TCP的20个字节的首部要短

	>有些程序会对UDP的不可靠通信进行改进：前向纠错或重传丢失

+ 格式：（伪首部字段12字节） + 首部字段8字节 + 数据字段  
	![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/UDP数据报格式.png)

	+ 首部：
		1. 源端口：源端口号。在需要对方回信时选用。不需要时可全0
		2. 目的端口：目的端口号。这在终点交付报文时必须使用
		3. 长度：UDP用户数据报的长度，其最小值是8（仅有首部）
		4. 检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃

	+ 如果接收方UDP发现收到的报文中的目的端口号不正确就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方
	+ 检验和：把首部和数据部分一起都检验
		>伪首部的意义是其长度算上首部正好是一个16位
		1. 把UDP数据报看作多个16位的字串，检验和部分为0，不足位置为0
		2. 以二进制反码计算所有16位字串的和，写入UDP检验和部分
		3. 接收方再次求和，为1则无差错
		+ 同时能检验端口号

# 传输控制协议TCP

+ 特点：
	1. TCP是**面向连接**的运输层协议：通信前建立连接，后释放连接
	2. 每一条TCP连接只能有两个**端点**(endpoint)，每一条TCP连接只能是**点对点**的（一对一）
	3. TCP提供**可靠交付**的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达
	4. TCP提供**全双工通信**。利用缓存，是进程在任何时候都发送或读取数据，TCP负责在合适的时候发送，TCP提供缓存
	5. **面向字节流**：TCP将应用进程交下来的**数据块**看成一连串无结构的**字节流**，在传输时不关心数据块的大小，TCP不关心数据何时/多大放到缓存里，只根据网络情况发送。其内容由上层的应用程序进行解码

+ 连接：TCP把==连接==作为**最基本的抽象**：TCP连接两个**端点**——套接字(socket)
	+ 套接字：端口号*拼接到*(concatenated with)IP地址$套接字socket = (IP地址:端口号)$[RFC 793]
	+ 每一条TCP连接唯一地被通信两端地两个端点（即两个套接字）所确定$TCP连接::={socket_1, socket_2}={(IP_1:port_1), (IP_2:port_2)}$
	>socket的其他含义：  
	>![socket的其他含义](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/socket其他含义.png)

+ 格式：  
	![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/TCP首部.png)
	
	+ 序号（32位）：是循环的，针对的是内容字节
	+ 确认号（32位）：表示希望下一个收到的序号
	+ 控制位：
		+ 确认ACK(ACKnowledgement)
		+ 终止FIN(FINis)
	+ 窗口（16位）：这个窗口不是下面的分组（发送窗口）的个数，而且窗口内的字节个数（滑动窗口）
 
+ 停止等待协议：每发送一个分组就停止等待，等待接受方发送确认消息，接收方如果在一定时间内没有收到，则超时重传
	+ 需要对分组进行编号
	+ 发送方必须保留已发送的分组的副本，也要实现超时计数器
	+ 对于这样的情况：发送的分组很迟才到接收方，接收方还没来得及发送确认，此时发送方已经超时重传了。所以接收方会收到重复分组，怎么处理呢？丢弃重复分组，那对重复的分组还确认么？确认，发送方也会丢弃重复确认。

+ 重传：
	+ 超时重传：要么数据包丢失、要么确认包丢失，

+ RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。
	+ RTO （Retransmission Timeout 超时重传时间
		+ 应该略大于RTT

	这里RTT是一个动态的值，在Linux中这个是变化的，有专门的计算方法

单纯的停止等待的信道利用率很低的，因为信道里是空空的，所以实际上采用流水线传输，比如下面这样  

![停等和流水线](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/停止等待和流水线运输.png)

而为了实现这个就需要更多的技术

+ 连续ARQ协议：设置发送窗口，位于发送窗口的分组不需要确认，当窗口的前缀分组被确认后即可移动窗口
+ 滑动窗口（不是上面的发送窗口）
