# Linux常识

+ ping
+ `df /`磁盘分区

```bash
fdisk /dev/sdb对磁盘进行分区
poweroff关机
find . -name "*.[ch]"查找当前目录下的.c和.h文件
grep "\bint i\b" a.c 查看文件中定义变量i的位置
wc a.c统计文件的行数/单词数/字符数
apt-get install gcc
wget url下载
iconv -f gbk -t
```





```c
int main(int argc, char *argv[], char *envp[]);  // 环境变量
```









+ 文件：
  + Linux程序运行时默认打开3个文件，通过文件描述符
    + 0号文件：默认输入（默认当前终端
    + 1号文件：默认输出（默认当前终端
    + 2号文件：默认错误（默认当前终端
  + `lsof -p 进程号`查看打开的文件



+ 根目录`\`
  + `home`：所有用户”家“目录
  + `bin`：常用可执行文件命令
  + `lib`：安装包和头文件
  + `etc`：配置文件
    + `nginx`：nginx的配置文件
  + `var`：
    + `log`：日志
  + `proc`：硬件配置信息
+ 文件路径：
  + 绝对路径：从根目录开始描述，以`/`分隔
    + `~/`：家目录（区别根目录）
  + 相对路径：
    + `.`表示当前目录
    + `..`表示当前目录的上一个目录

+ `ls -l -a`（`-l`全部信息，`-a`隐藏文件）打印的文件信息含义：一共10位，第一位表示当前是目录`d`还是普通文件`-`，剩下9位3位一组。三个组分别是当前用户权限、组内用户权限和其他用户权限。每组内分别是读写运行

  ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/Linux/Linux文件信息.png)

## 环境变量

记录配置信息，可被各个进程访问到

+ 查看方法：

  1. `env`：显示当前用户的变量
  2. `set`：显示当前shell的变量，包含当前用户的变量
  3. `export`：显示当前导出成用户环境变量的shell变量

  + 输出某环境变量的值：`echo $PATH`

+ 修改：将对环境变量的修改放在`~/.bashrc`文件中（末尾），然后执行`source ~/.bashrc`

+ 常用环境变量：

  + `HOME`：用户的家目录。

  + `PATH`：可执行文件（命令）的存储路径。路径与路径之间用`:`分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。

    + 如果想让自己的命令可以在任何一个目录下直接类似普通命令那样运行

      在`~/.bashrc`中末尾添加`export PATH=命令目录（从根目录开始：/home...）:$PATH`：相当于将PATH本来的字符串前接一个新的串然后保存在PATH中

  + `LD_LIBRARY_PATH`：用于指定动态链接库(`.so`文件)的路径，其内容是以冒号分隔的路径列表。

  ---

  + `C_INCLUDE_PATH`：C语言的头文件路径，内容是以冒号分隔的路径列表。
    `CPLUS_INCLUDE_PATH`：CPP的头文件路径，内容是以冒号分隔的路径列表。
  + `PYTHONPATH`：Python导入包的路径，内容是以冒号分隔的路径列表。
  + `JAVA_HOME`：jdk的安装目录。
    `CLASSPATH`：存放Java导入类的路径，内容是以冒号分隔的路径列表。

# 最基本命令

+ 命令格式：`命令 [选项] [参数]`
  + 选项：`-`加什么，顺序不关键
    + `-help/--help/-h/--h`：提供该命令手册
  + 参数：部分命令对参数个数不强制，支持正则表达式，对于参数名称中的空格使用转移字符`'\ '`

[一个入门网站](https://linux.cn/article-6160-1.html)

0. `man -ls`：提供命令手册

     + `man 命令名称`：查看某个命令

       > 进入了类似vim命令模式的状态

     + `man man`how RTFM
     + `man 3 库函数`
     + `man -k 关键字`

1. `strace 命令`：检查命令是使用什么系统调用进行的。

   + `strace -f bash -c "命令名"`：查看bash是如何调用对应命令的

   + ```bash
     strace -o strace.log -f man ls
     tail -f strace.log  # 在另一个创建
     ```

     来查看在使用man时发生了什么

2. `ctrl c`：取消命令，并且换行：向当前进程传递终止信号

3. `ctrl u`：清空本行命令

4. `tab`键：可以补全命令或文件名，如果补全不了快速按两下tab键，可以显示备选选项

5. 方向键上键：上一条命令

6. `ls`：列出当前目录下所有文件，（ac terminal中）蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件

   + `ls -l`：提供详细信息

     > 每个文明名前是二进制表示的文件权限：分别是作者的权限、同组的权限、其他用户权限。每个权限占三位，分别是读`r`、写`w`、执行`x`

   + `ls -a`：显示隐藏文件

     > 如果一个文件名以`.`开头，则其是一个隐藏文件

   + `ls -h`：”人性化“（也使用于其他命令）

   + `ll`：相当于`ls -al`

7. `pwd`：显示当前路径

8. `cd XXX`：进入XXX目录下，`cd ..`返回上层目录，`cd -`返回上一个所在的目录，只有`cd`返回家目录

9. `cp XXX YYY`：将XXX文件复制成YYY，相当于复制+粘贴+（重命名），如果是移动文件夹则是`cp 文件夹 路径 -r`

10. `mkdir XXX`：创建目录XXX，`mkdir 参数 -p`：如果一系列路径有部分目录没有，则递归创建

11. `rm XXX`：删除普通文件；

    `rm XXX -r`：删除文件夹

    + 支持正则表达式：`rm a\*`：删除文件夹a下的所有文件而不删除文件夹

12. `mv XXX YYY`：将XXX文件移动到YYY，和`cp`命令一样，XXX和YYY可以是一个路径，相当于拖拽

13. `touch XXX`：创建一个文件

14. `cat XXX`：展示文件XXX中的内容

15. 虚拟机和主体机器之间的信息交换

    复制文本：windows/Linux下，`Ctrl + insert`，Mac下，`command + c`

    粘贴文本：windows/Linux下，`Shift + insert`，Mac下，`command + v`

16. `history`查看历史命令

17. `clear`和`Ctrl + l`：终端显示页后翻=刷新屏幕$\approx$清屏

+ `type 其他命令`：查看命令类型

# 重定向和管道

+ 每个进程默认打开3个文件描述符：

  + `stdin`标准输入，从命令行读取数据，文件描述符为`0`
  + `stdout`标准输出，向命令行输出数据，文件描述符为`1`
  + `stderr`标准错误输出，向命令行输出数据，文件描述符为`2`

  可以用文件重定向将这三个文件重定向到其他文件中。

+ 重定向命令列表

  | 命令               | 说明                                          |
  | ------------------ | --------------------------------------------- |
  | `command > file`   | 将stdout重定向到file中                        |
  | `command < file`   | 将stdin重定向到file中                         |
  | `command >> file`  | 将stdout以追加方式重定向到file中              |
  | `command n> file`  | 将文件描述符n重定向到file中<br>> `2>`错误输出 |
  | `command n>> file` | 将文件描述符n以追加方式重定向到file中         |

+ 管道：将前一个命令的`stdout`重定向给下一个命令的`stdin`
  + 只能处理`stdout`，会忽略`stderr`
  + 要求管道右边的命令必须能接受`stdin`
  + 可串联
  
+ `xargs`命令：将stdin中的数据用空格或回车分割成命令行参数：因为有的参数不从stdin读入，不能用管道

  

# 其他常用命令

+ 系统状况

  + `top`：查看所有进程的信息（Linux的任务管理器）

    + 打开后，输入`M`：按使用内存排序
    + 打开后，输入`P`：按使用CPU排序
    + 打开后，输入`q`：退出

  + `df -h`：查看硬盘使用情况

    `free -h`：查看内存使用情况

    `du -sh`：查看当前目录占用的硬盘空间

  + `ps aux`：查看所有进程

  + `kill -9 pid`：杀死编号为pid的进程

    > 其中9是一个kill设定的参数，还有其他参数，用数字表示

    + 传递某个具体的信号：`kill -s SIGTERM pid`

      > 9就是其中一个信号

  + `netstat -nt`：查看所有网络连接

  + `w`：列出当前登陆的用户

  + `ping`：

+ 文件权限：`chmod`：修改文件权限

  每个文件由10个二进制表示文件权限：其中分成四组，分别是1、3、3、3，其中第一个表示文件类型（是文件还是目录），后面三个表示权限，每组都是同样的三位，分别表示是否可读、是否可写、是否可执行，由数字0~7表示，而这三组分别表示自己权限、同组权限和。。。权限。

  + `chmod +x XXX`：给XXX添加可执行权限
  + `chmod -x XXX`：去掉XXX的可执行权限
  + `chmod 777 XXX`：将XXX的权限改成777
  + `chmod 777 XXX -R`：递归修改整个文件夹的权限

+ 文件检索：

  + `find 路径 -name "正则表达式"`：搜索路径下是否有名称符合正则表达式的文件
  + `grep xxx`：从`stdin`中读入若干行数据，如果某行中包含`xxx`，则输入该行；否则忽略
  + `wc`：统计行数、单词书、字节数：既可以从`stdin中`直接读入内容；也可以在命令行参数中传入文件名列表
    + 参数：`-l`：统计行数；`-w`：统计单词数；`-c`：统计字节数

  ```bash
  find 文件目录/ -name "要查的文件或文件名正则表达式" | xargs cat | grep "要查的内容"
  # 找到这些文件                      # 输入内容（cat应该是参数而不是stdin，用xargs转换）
  find 文件目录/ -name "要查的文件或文件名正则表达式" | xargs cat | wc
  # 确定这些文件的内容的多少信息
  ```

  + `ag "要查的内容"`：在当前目录下的文件中查找内容（较于grep输入更人性化）
  + `tree`：展示当前目录的文件结构：可添加参数展示某个目录的文件结果
    + `-a`：显示隐藏文件
  + `cut`：
    从stdin中读入多行数据
    `echo \$PATH | cut -d ':' -f 3,5`：输出PATH用:分割后第3、5列数据
    `echo \$PATH | cut -d ':' -f 3-5`：输出PATH用:分割后第3-5列数据
    `echo \$PATH | cut -c 3,5`：输出PATH的第3、5个字符
    `echo \$PATH | cut -c 3-5`：输出PATH的第3-5个字符
  + `sort`：将每行内容按字典序排序，可从`stdin`内读取多行，可从参数读取文件名列表

  + `alias ls="ls --color"`设置别名，或者写入到`~/.bashrc`文件中

+ 查看文件内容：
  + `more`：浏览文件内容：
    + `回车`：下一行
    + `空格`：下一页
    + `b`：上一页
    + `q`：退出
  + `less`：与more类似，功能更全
    + `回车`：下一行
    + `y`：上一行
    + `Page Down`：下一页
      `Page Up`：上一页
    + `q`：退出
  + `head -3 xxx`：展示xxx的前3行内容
    同时支持从stdin读入内容
    `tail -3 xxx`：展示xxx末尾3行内容
    同时支持从stdin读入内容

+ 用户相关
  + `history`：展示当前用户的历史操作。内容存放在`~/.bash_history`中

+ 工具：
  + `md5sum`：计算md5哈希值：
    + 可从`stdin`读入内容：执行命令 -> 输入内容 -> `Ctrl + z`
    + 可从命令行参数传入文件名列表
  + `time command`：统计`command`命令的执行时间
  + `ipython`：ipython的相关特点
  + `watch -n 0.1 command`：每0.1秒执行一次`command`命令
    + 怎么关：`Ctrl + c`
  + `tar`：压缩文件
    + `tar -zcvf xxx.tar.gz /path/to/file/*`：压缩
      `tar -zxvf xxx.tar.gz`：解压缩
  + `diff XXX YYY`： 查找文件XXX与YYY的不同点

+ 安装软件
  + `sudo command`：以`root`身份执行`command`命令
  + `apt-get install xxx`：安装软件
  + `pip install xxx --user --upgrade`：安装python包

## ssh

+ 登录：

  + 登录格式：`ssh user@hostname`
    + `user`：用户名
    + `hostname`：IP地址或域名

  0. 第一次登录会有提示，忽略即可

     > 之后服务器信息记录本机在`~/.ssh/known_hosts`

  1. 输入密码

  2. 默认登陆端口号为22

     登录特定端口：`ssh user@hostname -p 端口号`

+ 本机配置文件：

  + 创建文件：`~/.ssh/config`

  + 文件输入：

    ```bash
    Host 别名
    	HostName IP地址或域名
    	User 用户名
    	Port 端口
    	IdentityFile 不知道
    ```

    > 在该文件下维护多个云服务器

  + 之后即可直接通过别名`ssh 别名`直接登入

  + 密钥登录：

    1. 创建密钥：命令`ssh-keygen`，之后一路回车

       结果：`~/.ssh/`目录下多两个文件

       + `id_rsa`私钥
       + `id_rsa.pub`公钥

    2. 将公钥传给服务器

       1. 方法1：将公钥中的内容复制到对应服务器中的`~/.ssh/authorized_keys`文件中

          > 服务器多个公钥回车隔开

       2. 方法2：本机使用命令添加公钥：`ssh-copy-id 服务器别名`

+ 本地在服务器执行命令（自动登录、执行、退出）：`ssh user@hostname commad`/`ssh 服务器别名 commad`

### scp传文件

命令格式：`scp source destination`：将`source`路径下的文件复制到`destination`中

+ 多文件：`scp source1 source2 destination`
+ 复制文件夹：`scp -r ... ...`
+ 指定端口：`scp -P 端口号 ... ...`

> 其中参数`-r`和`-P`尽可能放在两组地址之前

+ source和destination是逻辑关系，不是本机和服务器的关系

  + 本机：正常使用
  + 服务器：`服务器别名:...`
    + `服务器别名:/home/acs/...`
    + `服务器别名:家目录下的文件`：服务器的家目录不用起始`~`

+ 配置`tmux`和`vim`

  ```bash
  scp ~/.vimrc ~/.tmux.conf myserver:
  ```

# Shell编程

+ shell功能：

  + `Tab`补全

  + 上下键检索历史命令

  + `Alt+f`、`Atl+b`按单词移动光标

    > `man readline`

  + `history`查看历史命令

    + `!历史命令编号`
    + `!字符串`做前缀匹配最近使用的命令并运行

  + 符号扩展：`echo Hello-{a, bb, ccc}-{1,2}!`

+ 任务管理：

  + `Ctrl + z`最小化
    + `bg`最小化
  + `jobs`任务栏
  + `fg`最大化

> 关于空格，如果表达式加上”美观“的空格，可能导致这样的问题，空格在linux中有含义，分隔参数

> linux下的Shell语言种类很多，一般默认bash

+ 文件后缀名：`.sh`

  脚本需要在文件开头`#! /bin/bash`来指明bash为脚本解释器

+ 运行方式：

  1. `chmod +x test.sh`：把脚本`test.sh`具有可执行权限

     可以把`test.sh`作为可执行文件运行（当前路径、绝对路径、家目录路径）

  2. 解释器运行：`bash test.sh`

+ 注释：

  1. 单行注释：`#`：注释每行之后的内容

  2. 多行注释：

     ```bash
     :<<EOF
     这里面是一个注释
     EOF
     ```

     这里的`EOF`可以换成其他任意字符串

+ 引入外部脚本：

  ```bash
  . filename  # 空格隔开
  
  #或者
  
  source filename
  ```

### 变量

+ 定义变量：

  ```bash
  sam='string'
  sam="string"
  sam=string
  ```

  上面这三种方法都是定义字符串

  + 字符串：

    + 单引号：内容原样输出、不会执行、不会取变量——真文本
    + 双引号：内容                   可以执行、可以去变量——代码

    > ssh中的`ssh ... commond`相反

  + 获取字符串长度：`${#字符串变量名}`

  + 提取子串：`${字符串变量名:第一个索引（从0开始）:子串长度}`

+ 使用变量：在变量名前加上`$`或者使用`${}`符号

  + 在后续的使用中，可能还要把取变量后的结果在用引号括起来，因为比如变量是字符串变量且中间有空格，同时取变量后作为参数，这时空格导致这是多个参数

+ 只读变量：

  ```bash
  sam=string
  readonly sam
  declare -r name
  ```

  以上两种方式均可

+ 删除变量：

  ```bash
  sam=string
  unset sam
  ```

  删除之后其内容为一个空字符串

+ 变量类型：

  > 子进程：命令bash会开一个新进程，原进程睡眠，exit/Ctrl + d退出当前bash

  1. 自定义变量/局部变量：子进程不能访问的变量
  2. 环境变量/全局变量：子进程可以访问的变量

  + 自定义变量改成环境变量：

    ```bash
    sam=string  # 定义自定义变量
    export name
    declare -x name
    ```

    以上两种方法均可

  + 环境变量改为自定义变量：

    ```bash
    export sam=string  # 定义环境变量
    declare +x name
    ```

+ 文件参数变量（默认变量）：执行shell脚本时，可向脚本传递参数

  | 参数         | 说明                                                         |
  | ------------ | ------------------------------------------------------------ |
  | `$数字`      | `$0`是文件名<br>对应参数从1开始                              |
  | `$#`         | 代表文件传入的参数个数                                       |
  | `$*`         | 由所有参数构成的用空格隔开的字符串                           |
  | `$@`         | 每个参数分别用双引号括起来的字符串                           |
  | `$$`         | 脚本当前运行的进程ID                                         |
  | `$?`         | 上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误 |
  | `$(command)` | 返回command这条命令的stdout（可嵌套）                        |
  | \`command\`  | 返回command这条命令的stdout（不可嵌套）这里的点是有效的      |

  + 后两个比如：

    ```bash
    #! /bin/bash
    echo $(ls)
    echo 'ls'
    ```


### 数组

shell的数组可以存放**不同类型的值**，只支持一维数组，**下标从0开始**

+ 定义：

  1. 用小括号表示，元素用空格隔开：`array=(sam1 sam2 sam3...)`

  2. 直接定义数组中某个元素的值：`array[索引]=值`

     > 这里显然可以在一个较大的位置赋值，但是其中没有用到的索引是空的，没有空间

+ 读取：

  + 某个元素：`${array[index]}`
  + 整个数组：
    1. `${array[@]}`
    2. `${array[*]}`
  + 取数组长度：`${#array}`

### 命令

#### `expr`

用于求表达式的值：`expr 表达式`

+ 表达式说明：

  + 用空格隔开每一项

  + 用反斜杠放在shell特定的字符前面

  + 对于包含空格和其他特殊字符的字符串要用引号括起来

  + `stdout`      ：expr的返回值，则需要文件参数变量获得结果

    `exit code`：如果表达式是逻辑表达式则和其统一：0/1

+ 字符串表达式：

  + `length STRING`：返回STRING的长度
  + `index STRING CHARSET`：返回set中任意单个字符在string中最前面的字符的位置，**索引从1开始**，如果set中一个都不存在则返回0
  + `substr STRING POSITION LENGTH`：同上，如果后两个参数不合法则返回空字符串

+ 整数表达式：算术表达式优先级低于字符串表达式，高于逻辑表达式

  + `+ - * / % ( )`：参数会转换成整数
    + `* ( )`需要转义，除了转义之外还可以用单引号把特殊符号括起来
    + 只能处理整数

+ 逻辑关系表达式：下列符号都需要转义

  + `| &`：是关系不是位运算：返回对应的值（非空且非0） + 短路原则
  + `< <= = == != >= >`：返回真假，`=`和`==`同义，优先转换成整数，不能则转换成字符集
    + `( )`：改变优先级，需要反斜杠转义

#### `read`

+ 用于从标准输入中读取单行数据

  当读到文件结束符时，`exit code`为1，否则为0

+ 参数：

  + `read 变量名`：向变量名读入
  + `-p`：后接提示信息
  + `-t`：后接秒数：输入字符的等待时间，超过则忽略该命令

#### `echo`

标准输出stdout

+ 用于输出字符串。命令格式：`echo STRING`

+ 显示普通字符串：`echo "普通字符串"`其中引号可以省略

+ 显示转义字符：只能使用双引号或者不使用引号

+ 显示变量：

+ 显示换行    ：`echo -e "字符串\n"  # -e 开启转义`

  显示不换行：`echo -e "字符串\c"  # -e 开启转义`

+ 显示结果定向至文件：`>`

+ 不进行转义或取变量：用单引号

+ 显示命令执行的结果： 用波浪线下边的点

#### `printf`

格式化输出

格式：`printf format-string [arrguments...]`

#### `test`和`[]`

+ 逻辑运算符：`&& ||`：具有短路原则：`exit code`为0是真，非0是假

  > 之前的单与单或是expr内部的，这里的双与和双或是Shell内的

  + 短路原则可用于分支：`判断的语句 && 如果是真要运行的 || 否则要运行的`：如果是假则 &&后边的没有必要运行了，但是还要看看||后的，而如果是真的则相反

+ `test`：用于判断文件类型和文件比较

  + 用`exit code`返回结果，而不使用`stdout`：0真、非0假

    `echo $?`：来得到上条语句的`exit code`

+ 文件类型判断：`test -e filename`

  | 测试参数 | 含义                               |
  | -------- | ---------------------------------- |
  | `-e`     | 文件是否存在                       |
  | `-f`     | 是否为文件                         |
  | `-d`     | 是否为目录，也能判断文件夹是否存在 |

+ 文件权限判断：`test -r filename`

  | 测试参数 | 含义           |
  | -------- | -------------- |
  | `-r`     | 文件是否可读   |
  | `-w`     | 文件是否可写   |
  | `-x`     | 文件是否可执行 |
  | `-s`     | 是否为非空文件 |

+ 整数间的比较：`test 操作数1 操作符参数 操作数2`

  | 测试参数 | 代表意义                 |
  | -------- | ------------------------ |
  | `-eq`    | 是否等于                 |
  | `-ne`    | 不等于                   |
  | `-gt`    | 左操作数是否大于右操作数 |
  | `-lt`    | 小于                     |
  | `-ge`    | 大于等于                 |
  | `le`     | 小于等于                 |

+ 字符串比较：

  | 测试参数            | 代表意义                         |
  | ------------------- | -------------------------------- |
  | `test -z STRING`    | 判断是否为空，空为真             |
  | `test -n STRING`    | 是否为非空，非空为真，`-n`可省略 |
  | `test str1 == str2` |                                  |
  | `test str1 != str2` |                                  |

+ 多重条件判定：和逻辑运算符等效：`test -r filename -a -x filename`

  | 测试参数 | 代表意义           |
  | -------- | ------------------ |
  | `-a`     | 同时               |
  | `-o`     | 至少一             |
  | `!`      | 取反（后面的结果） |

---

+ 判断符号`[]`：`[]`与test用法几乎一模一样，更常用于`if`语句中。另外`[[]]`是`[]`的加强版，支持的特性更多。
  + `[]`内的每一项都要用空格隔开
  + 中括号内的变量，最好用双引号括起来
  + 中括号内的常数，最好用单或双引号括起来

#### `exit`

exit命令用来退出当前shell进程，并返回一个退出状态；使用$?可以接收这个退出状态。

exit命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。

exit退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。

### 循环分支

+ `if`

  1. ```bash
     if codition
     then
     	语句
     fi
     ```

  2. ```bash
     if condtion
     then
     	语句
     else
     	语句
     fi
     ```

  3. ```bash
     if codition
     then
     	语句
     elif condition
     then
     	语句
     elif condition
     then
     	语句
     else
     	语句
     fi
     ```

+ `case`

  ```bash
  case ${变量名称} in
  	值1)
  		语句
  		...
  		;;  # 类似break
  	值2)
  		...
  		;;
  	*)  # 其他情况
  		...
  		;;  # 可选
  esac
  ```

  +  `;;`除了最后一个是必须的，一般建议都不删

+ `for each`

  ```bash
  for var in val1 val2 val3...
  do
  	语句
  done
  ```

  + 参数：
    1. 一系列值
    2. 其他命令结果
    3. `$(sep 起 止)`：输出一系列数
    4. `{起..止}`：其中`...`是关键字，可以是数字或者是字母

+ `for()`

  ```bash
  for ((expression; condition; expression))
  do
  	语句
  done
  ```

+ `while`：为假弹出

  ```bash
  while condition
  do
  	语句
  done
  ```

+ `until`：为真结束

  ```bash
  until condition
  do
  	语句
  done
  ```

+ `break`：跳出当层循环，不能跳出case

+ `continue`：跳过当前循环

+ 对于死循环的处理方法：

  1. `Ctrl + c`
  2. 1. `top`找到进程PID
     2. `kill -9 对应的id`关掉进程

### 函数

+ 函数的return是exit code：0-255的值，0表示正常结束

  > 不写return，默认`return 0`

  1. `$(function_name)`/使用单引号：获得stdout
  2. `$?`：获得return的exit code

+ 格式：

  ```bash
  [function] func_name() {
  	语句
  	...
  }
  ```

+ 函数参数：不需要在格式中的括号中写，在函数内直接通过`$数字`对应使用

  > 注意`$0`仍是文件名，不是函数名

+ 局部变量：`local 变量名=变量值`
