<!--https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/-->
+ 该笔记部分插图来自各种书籍、课程或其他资料，如果涉及到任何版权行为，请联系我，我将删除内容。
+ 文中所有内容，与本人现在，之前或者将来的雇佣公司无关，本人保留自省的权力，即你看到的内容不一定代表本人最新的认知和观点。
+ 对于课程笔记，我严格遵循[Academic Integrity](http://integrity.mit.edu/)，如果有不合适的地方，请提醒我。
+ 该项目是我个人的笔记，部分文章会从如何让别人读懂出发，但大部分仍然是我个人的记录，除非特殊声明，否则不建议作为学习资料。


### 精华

四年功力于一：[win开发机配置指南](https://github.com/zweix123/CS-notes/blob/master/Missing-Semester/WindowsConfigGuide.md)

### 笔记的意义

1. 在初学时
   + 在学习时记下笔记有助于记忆  
   + 在整理时重构笔记有助于搭建知识体系  
     随着进一步学习，我们对同一知识的理解发生变化，会动态的调整笔记（重构知识体系的过程）

2. 在实践时  
   通过笔记快速的回忆起学习时的理解或者查找对应的知识点

但随着时间的推移，笔记的作用减少了

+ 常用的、重要的知识点内化于心
+ 零碎的、细节性的知识现用现查

此时笔记更像是”当年攻城略地时的纪念品“

### 几个原则

1. 熵增定律：  
	不必去追求极致的秩序，因为那意味着巨大的成本和不稳定性
2. 奥卡姆剃刀：如无必要，勿增实体
3. 抽象与平衡：过低的抽象带来了思维负担，过高的抽象意味着不自由。

### CS Prime
>下面的讨论是我个人认为一个计算机领域的学习者不可或缺的实践部分，脱胎于[CS自学指南](https://csdiy.wiki/)，对于相对基础（语法、数据结构、专业基础知识）没有涉及，需要其他学习路线作为补充。
>>对于更加进阶的内容（人工智能、系统、图形学、新兴领域和交叉学科）可能会在后续更新

我个人也将这里作为我的生活实验，会记录自己的进度，看我能做到哪种程度。

![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/word%20of%20cs.png)
>下面的部分描述我个人也觉得可以作为CS专业和其他相近专业的核心区别

1. 让我们有一个我们的机器：**[PA（C）](https://nju-projectn.github.io/ics-pa-gitbook/)**  

	在计算机底层，其实是以ISA（指令集架构）为中心的，向下芯片厂商按照ISA规定的指令设计和制造电路，向上软件开发者按照指令集提供的指令设计程序。在指令集层面有树大根深的x86、精简指令集ARM以及开源新贵RISC-V等等。  
	其中围绕RISV-V指令集的相关生态欣欣向荣，[一生一芯](https://ysyx.oscc.cc/) 就是这样的一个项目，它试图让我们体验一个RISC-V指令集芯片从设计到流片的全过程，这里有很多知识更偏向电子信息专业，我们需要找到一个切面作为学习的分界线避免过度递归学习。  
	[NJU PA](https://nju-projectn.github.io/ics-pa-gitbook/)可以作为一生一芯的子集，它是编写这样的一个x86程序：一个模拟RISC-V指令集机器运行的程序。在这个实验中，我们不需要了解芯片设计的知识，只需要按照RISC-V的指令集想办法编写一个C工程，它可以接受一个RISC-V指令代码作为输入，然后输出的就是这段RISC-V指令代码的逻辑。  

到这里我们相当于有了一个“实体的机器”，我们可以把编写的（机器代码）程序放在里面运行

2. 在我们的机器上搭建一个操作系统：**[THU rCore](http://rcore-os.cn/rCore-Tutorial-Book-v3/)（Rust）**
	>这里其实有其他选择，比如有两本经典的带读者从头制造一个mini OS的书籍，但是粗略接触觉得有点过时（其实也没过几年，计算机领域实在是发展太快了）；或者是MIT的xv6、清华的uCore也是非常好的选择，不过我突然意识到“目前流行的语言能够在市场占领一定的生态位确实有其独特的地方”，所以想趁机学习一下Rust。

	这个课程是使用Rust语言编写一个运行在一个基于RISC-V的机器的操作系统

至此我们已经有了一个完备的机器。

>在体系结构方面的学习肯定还要提到《CSAPP》，无论是它的作者、授课老师还是Lab都享誉全球。

3. 编写一个C语言编译器：**chibicc（C）**

	 想象一下，我们已经有了一个具有操作系统的机器，如果我们有编译器可以将我们写的代码编译成可以运行在我们机器上的RISC-V指令集程序，是一件多么激动人心的事情啊。  
	 [B站视频](https://space.bilibili.com/296494084/channel/collectiondetail?sid=571708)，录制这个视频的佬是基于Rui的chibicc，Rui把原本x86架构的改为RISC-V架构，并配有大量注释和316个commit，这个视频相当于一个跟随学习的视频

至此我们已经有了一个相当于RISC-V架构的机器，上面运行有一个操作系统，并且我们自制了一个C编译器使我们编写程序并编译成可运行在这个机器的程序，计算机三大浪漫已完成其二。

4. 带我们的机器走进互联网：**standford CS144（Modern C++）**
	
	上面的机器只能编写运行单机的程序，尝试将它们连接起来，当多个机器可以通信，我们设计程序就可以有更多的想象空间了。这门课的Lab就是用现代C++实现TCP/IP模型协议栈
	>实际上模型中还有网络接入层，这里其实也有很多知识，不过感觉更偏向网络工程这个专业

5. 更好的管理数据以制作更好的程序：数据库**CMU15-445（Modern C++）**

	随着程序规模的扩张，对数据的管理提出了新的要求，比如数据的结构还有当多用户对同一数据进行读写的一致性问题，于是数据库理论应运而生，这门课就是带我们用现在C++实现一个关系型数据库

至此，相当于我们制作了一个计算机，并编写了基本但并不简单的系统程序（OS、Complier、DB），以及完成了计算机互联的基础设施。  
下一阶段就是如果在这些基础设施上编写更好的程序，我们进入了软件工程专业的领域

#### Distributed
互联网中的数据是海量的，要处理这样的数据仅靠单机是无法在一个可以接受的时间内完成的，而且有些场景（诸如转账）天然就是分布式的。所以编写部署在集群的程序是很有必要的。但是天然具有分布式的算法（比如用于路由器表更新的距离向量算法，本质是最短路Bellman-Ford算法）是稀有的，而统筹集群的算力和存储空间是一个复杂问题。

+ <del>入门</del>网红课程[MIT 6.824](http://nil.csail.mit.edu/6.824/2022/schedule.html)（Golang）
	>2023年：好像改名了。
	
	以论文解读的形式带我们学习分布式的方方面面
	+ [我的学习笔记](https://github.com/zweix123/CS-notes/tree/master/Distributed-System)，包括对知识点的总结和论文精读后的梳理
		+ 除了课程中的论文，我个人也在做分布式存储相关的实习，所以也加入了这方面的论文
	还在学、回头细聊

#### Web3

+ [MIT 15.S12](https://ocw.mit.edu/courses/15-s12-blockchain-and-money-fall-2018/)：讲师Gary Gensler（美国证券交易委员会主席）  
	还在看，回头细聊