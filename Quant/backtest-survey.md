### 交易库支持的编程范式
>交易库包含实盘交易、模拟盘交易和回测功能  
>最好的方式肯定是“一套代码、处处运行”

+ pre：
	+ 网关gateway，所有交易最终都是通过网站的API，各个系统有各自的封装，不同系统中的称呼不同，这里统称网关

其他系统的优势在于“自研网关”，那么完全可以把网关做成“阴阳壶”，在实盘的时候连接网站，在回测的时候连接自己的东西。

没有自研网关的回测系统，比如backtrader都是需要实盘策略和交易策略两份代码的。

#### 基于事件驱动
>这里的事件驱动既是指内部事件，又是使用方式。

+ 事件驱动引擎event engine：把它黑盒魔法，它的功能是如果发生什么**事件**、会调用什么**函数**。这里的事件检测、调用都是自动的。

这样的系统的策略编程范式通常都是继承它提供的基类。这样在语法层面就限制了用户必须要实现什么方法，从而保证事件驱动引擎一定会有哪些函数

**这些被基类“限制”的方法，就是系统给到用户的权利，同时用户也只有这些权利**，用户的代码是有限制的，必须实现某些方法，也只能实现这些方法，这些方法只能在对应的时间被调用。

所以这类平台的实盘交易模型是这样的，网关不断的监控一旦发生的某些事件，就把这些事件给到事件驱动引擎，引擎自动运行策略中的代码，而代码中的逻辑也通过统一的网关和市场交互。

![model](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Quant/model.png)  

这样的模型的好处是实现的代码的复用，回测部分不需要修改用户策略代码，网关作为阴阳壶，在回测时不对接市场，而且对接自己的“市场模拟程序”，其他的什么都不要变，因为策略的推进由引擎自动调用。

大量的项目都是这样的方式：vnpy、backtrader

#### 发明者模式

发明者的模式对于上面的模式既包含优点，又弥补缺点。

网关，发明者也是自研的。

在用户使用上，发明者的策略就像普通的命令式、面向过程的程序一样（而不是上面那种必须要继承某个类）。这样的形式能够实现更灵活的策略。

同时它也实现了