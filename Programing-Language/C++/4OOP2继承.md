# 类的关系-继承

+ C++定义了类的关系范式并提供语法实现

  | 关系模型  | 属性           | 语法                                 |
  | --------- | -------------- | ------------------------------------ |
  | is-a关系  | 是：香蕉是水果 | 公有继承                             |
  | has-a关系 | 有：律师有大脑 | 包含组合层次化<br />私有继承保护继承 |

  其他比较

  | 说明         | is-a关系                           | has-a关系                                |
  | ------------ | ---------------------------------- | ---------------------------------------- |
  | 基类方法归属 | 外界可以通过派生类对象调用基类方法 | 类内可以通过基类调用基类方法，类外不可以 |

  has-a关系不用语言体现的比较

  | 说明                   | 包含组合层次化       | 私有继承     | 公有继承 |
  | ---------------------- | -------------------- | ------------ | -------- |
  | 对于基类数据成员的操纵 | 通过基类对象调用方法 | 可以直接操纵 |          |

  has-a关系继承中两种继承方式的比较

  | 说明 | 私有继承 | 公有继承 |
  | ---- | -------- | -------- |
  |      |          |          |

+ 一些名词：

  + 继承(inheritance)
    + 公有继承：is-a关系
    + 保护继承：has-a关系
    + 私有继承：has-a关系
  + 继承链：嵌套继承
  + 包含(composition)、组合(composition)或层次化(layering)：has-a关系
  + 子对象（subobject）通过继承或包含添加的对象

+ 关键字`final`，表示该类不能继承

  ```c++
  class ClassName final {
  	...
  };
  ```

## 继承:公有继承

+ 概念：(类)继承（派生）(inheritance)：扩展和修改类：从已有的类（**原始类：*基类base class***）派生出新的类（**继承类：*派生类derived class***），派生类继承了基类的特征，并添加功能、数据、方法。

> 面向对象的特性之一：**继承**。 -> 面向对象的目的之一：**可重用**
>
> C：通过标准C库预定义、预编译的函数和厂商提供的专用C库来提供可重用性，但如果想拓展则需要库函数的源代码进行修改（一方面不易获得，另一方面修改有风险）
>
> C++：一方面，标准和厂商提供类库——类包含数据表示和类方法，所以是比函数更完整的程序包；另一方面，C++具有*继承*特性，仅需要接口便可以拓展，只需要编译后代码，便可以实现。即可以在不公开源码的情况下允许它人使用和添加新特性。

------

+ 声明：`class derivedClass : 访问控制关键字 baseClass {};`

  ​			其中访问控制关键字（**`public`**/**`protected`**/**`pricate`**）表示（公有/保护/私有）派生。

  ​            其中**`pricate`**是默认值，因此省略访问限定符也将导致私有继承

  + class derivation list类派生列表

+ 数据成员和成员函数访问控制变化：

  | 特征             | 公有继承             | 保护继承                 | 私有继承                                 |
  | ---------------- | -------------------- | ------------------------ | ---------------------------------------- |
  | 公有成员变成     | 派生类的公有成员     | 派生类的保护成员         | 派生类的私有成员(基类接口不是派生类接口) |
  | 保护成员变成     | 派生类的保护成员     | 派生类的保护成员         | 派生类的私有成员                         |
  | 私有成员变成     | 只能通过基类接口访问 | 只能通过基类接口访问     | 只能通过基类接口访问                     |
  | 能否隐式向上转换 | 是                   | 是（但只能在派生类类中） | 否                                       |
  
+ 友元函数：

  + 友元不能是虚函数，因为友元不是类成员，只有成员函数才能使用虚函数。
  + 派生类的友元通过基类的友元使用基类数据：友元不是类成员，不能使用作用域解析运算符，应该是强制类型转换

+ 画示意图观察成员经继承后变为何成员，线要分为不同的继承方式

  ```mermaid
  flowchart LR
  	公 ----公有----> 公_
  	保 ----公有----> 保_
  	保 ----保护----> 保_
  	公 ----保护----> 私_
  	公 ----私有----> 私_
  	保 ----私有----> 保_
  ```

  会发现

  私有成员无法传递

  公有继承不影响

  保护继承归为保护成员类内无影响，类为无影响（本来也不能访问）

  私有继承将公有和保护成员归为私有，截断在继承链上的传递

### 继承基础

+ 标准函数：如果没有特殊的设计，**派生类**在调用标准函数时对基类数据成员部分的处理是通过**调用基类的标准函数**

  派生类无动态内存：派生类标准函数自动调用基类标准函数（来处理基类的动态内存）

  派生类有动态内存：派生类标准函数显式调用基类标准函数

  + 构造函数：派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问——派生类构造函数必须使用基类构造函数。

    派生类对象时，程序必须先创建基类对象，从概念上说，这意味着基类对象应当在程序进入派生类构造函数之间被创建——而这时基类对象已经使用了默认构造函数——使用新语法：成员初始化列表语法

    ```cpp
    class baseClass{
        int num;
    public:
        baseClass(int num_) { num = num_; }
    }
    class drivedClass : public baseClass {
        int num;
        baseClass sam;
    public:
        drivedClass(int a, int b) : baseClass(b) { num = a; }				//调用基类的构造函数
        drivedClass(int a, const baseClass & b) : baseClass(b) { num = a;} 	   //调用基类的复制构造函数
    }
    ```

    + 创建对象时，**先调用基类构造函数**（初始化继承的数据成员），**再调用派生类构造函数**（初始化新增的数据成员）
    + 派生类的构造函数总是调用基类的构造函数，如果不使用成员初始化器列表，则调用其默认构造函数
    + 在继承链中，相邻的类通过调用关联的构造函数实现传递。
    + C++11新增几个构造函数的方式，默认不继承

  + 析构函数：

    + 派生类对象过期时，程序**首先调用派生类析构函数，然后再调用基类析构函数**。

  + 复制构造函数：

    + 派生类有动态内存：派生类复制构造函数可通过成员初始化处理基类数据

  + 赋值运算符：

    1. 派生类赋值基类，调用基类赋值运算符，参数为基类引用可指向派生类，可实现，派生类多余部分被忽略
    2. 基类赋值派生类，调用派生类赋值运算符，参数引用是派生类不能指向基类
       1. 派生类设计转换构造函数，将基类转换为派生类
       2. 派生类重载运算符，参数是基类

    + 派生类有动态内存：派生类赋值运算符需显式调用基类赋值运算符

      ```cpp
      drivedClass & operator=(drivedClass & t) {
          ...
          baseClass::operator(t);  //1
          *this = t; 				 //2
          ...
      }
      ```

      两种方式选一个。

+ 派生类和基类之间的**特殊关系**（引用兼容性属性）：

  + 派生类可以使用基类的方法，条件是方法不是私有的。

  + 基类指针/引用可以在不进行显式类型转换的情况下指向/引用派生类对象，但这样的基类只能使用派生类中的基类方法

    这个特性是单向，反过来不可以（派生类指向基类调用基类中的派生方法是滑稽的（基类有个屁的派生方法），而调用基类中的基类方法也是没必要的（本来就可以用））

    + 基类引用定义的函数或指针参数可以用于基类对象或派生类对象。
    + 将基类对象初始化为派生类对象（基类没有参数为派生类的构造函数，但有参数为基类的复制构造函数，其基类引用参数可以指向派生类，这样派生类作为参数然后被复制为基类（而复制的过程丢弃多余的数据成员））
    + 可以将派生类赋值给基类对象（使用隐式重载赋值运算符，基类引用参数，返回基类对象）
    + 基类指针数组，其指向的可能是多种类，这也是多态的一种。

  + + 派生类引用或指针转换为基类的引用或指针被称为*向上强制转换*（upcasting），规则是is-a关系的一部分，使得共有继承不需要进行显式类型转换。可在继承链上传递。因为对基类的任何操作对派生类也可以。
    + 基类指针或引用转换为派生类的指针或引用被称为*向下强制转换*（downcasting）， is-a关系是不可逆的，所以需要显式转换是有风险的，相当于派生类放弃对多余特性的控制权。因为派生类有基类没有的操作。
    + 隐式向上转换（implicit upcasting）

### 其他继承方式

***保护继承***

+ 对于保护部分，类外保护成员的行为与私有成员相似，对于派生类来说，保护成员的行为与公有成员相似

  即基类外边不能访问的，派生类可以当自己人访问

  但是有问题，如果这个保护类在基类中被设有只能通过公有方法修改方法，但是派生类可以直接修改，就违背的基类的意思。

***私有继承***

### 多态继承:虚

> 派生类可以使用基类的方法，如果想同一个方法在基类和派生类的行为不同呢？公有继承的多态——**虚方法/虚函数**

+ 使用：关键字**`virtual`**

  + 关键字添加在基类方法声明前(定义不需要)，该方法被定义为*虚方法*，派生类同名方法不需要关键字(但是建议使用)。

  + 通过引用类型或指针类型而不是对象调用方法（）

    + 非虚方法：根据引用类型或指针类型选择方法——可静态联编，通过类型确定调用类型。
    + 虚方法    ：根据引用或指针指向的对对象的类型选择方法——对象指针数组一个for过去可能使用不同方法—多态。

    > (函数名)联编/绑定（binding）：将源代码中的函数调用解释为执行特定的函数代码块地址
    >
    > 静态联编(static binding ）  (早期联编early finding)：在编译工程中进行联编（函数重载通过名称修饰或名称矫正确定）
    >
    > 动态联编(dynamic binding)(晚期联编late finding)  ：在运行时进行联编（虚函数不知道具体使用的哪个）（run-time binding运行时绑定）
    >
    > **虚函数的动态联编**：
    >
    > 编译器处理虚函数的方法是给每个对象添加一个隐藏成员，其保存指向函数地址数组(虚函数表(virtual function, vtbl)：存储类的虚函数的地址，派生类重定义则添加新地址，否则添加基类函数地址)的指针。
    >
    > 使用虚函数时：对象-隐藏指针-表-函数地址-运行函数。
    >
    > 虚函数的**开销更大**：
    >
    > 1. 对象存储空间变大：存储指针。
    > 2. 为每个类多提供一个表。
    > 3. 函数调用时间花销更多。

    通过对象调用则以调用对象为准。

    + 基类中的虚函数在派生类中隐含得也是一个虚函数

  + 虚函数可重定义。

    + 类中想使用关联的类的同名方法需要类名+作用域解析运算符+函数名。

    + 类外重定义继承虚函数不是重载，它会隐藏老版本—重定义继承方法特征标要一样；基类方法被重载，派生类要重定义所有

      **除非基类版本是隐藏的。**

      *返回类型协变*(covariance of return type)：如果返回类型是基类的指针或引用，则可以变为派生类的指针或引用.

    ----

    + 如果不需要修改`type derivedClass::fName() { （return） baseClass::fName(); }`
    + 如果没有重定义则使用基类版本，如果派生类在派生链中，使用最新版本（最近基类）。

    如果不需要修改则不用管，如果重载的基类函数修改部分，则在不需要修改的方法调用基类方法

+ 构造函数：构造函数比较特殊，不可变为虚函数

+ 析构函数：由于多态性，有动态内存的类，在使用指针或引用调用时需要析构函数正确选择基类或派生类的析构函数

  所以在设计类是将析构函数使用关键字是一种惯例，除非保证不做基类，否则即使有更多的花销，也值得。

  而虚析构函数将阻止合成移动操作

+ 友元函数：友元不能是虚函数，因为友元不是类成员，只有成员函数才能使用虚函数。

+ C++11中的`override`，放在派生类重载虚函数的定义的*最后*，表达要覆盖基类中的虚函数，用于由编译器发现错误。

### 抽象基类

> is-a关系中由椭圆继承出圆会有很多信息冗余，直接定义圆比继承更容易，但分别定义又忽略的两者的共同点

+ 在考虑继承时，抽象出类的共性，将共性放在一个类中，这个类就是***抽象基类***(（abstract base class, **ABC**）：**至少有一个纯虚函数的类**)，然后从抽象基类中派生出其他类（具体（concrete）类）。这样就可以使用ABC的指针数组管理两个类实现多态。

+ ***纯虚函数***（pure virtual function）：未实现的函数

  + 声明：在方法声明的末尾添加`=0`

    `virtual type fName() = 0;` `virtual type fName() const = 0;`

  + 含纯虚函数的类（抽象基类）不能创建其对象，只能作为基类。

  + 纯虚函数没有定义，C++11允许为其定义，不过必须在类的外部

### 类作用域继承

+ 先找当前类，再往基类找

  > 即如果名称在派生链的下方，则往上找可能找不到

+ 同名名称由继承链上的下覆盖上的，可以通过作用域运算符来使用隐藏的成员

### 标准函数继承

+ 构造函数：通过作用域运算符继承基类的所有构造函数

  ```c++
  class D : public B {
      using::B;
  }
  ```

  + 如果基类的构造函数有多个默认实参，则会被自动拆解成多个构造函数

## has-a关系

### 包含组合

+ 概念：直接在派生类声明中创建基类对象/将对象作为一个命名的成员对象添加到类中

+ 使用：

  + 构造：成员初始化列表显式调用（通过基类对象）基类构造函数

    > 如果不适用成员初始化列表，基类对象成员会自动调用其默认构造函数（如果基类有的话），然后再被派生类初始化

  + 类内使用：通过基类对象调用基类方法

  + 类外使用：类外不可使用基类方法。

### 私有继承

+ 初始化基类组件：构造函数使用列表初始化法初始化，使用类名。
+ 访问基类组件：
  + 使用类名和作用域解析运算符
  + 使用using声明基类方法，可在类内直接使用 没有圆括号、函数特征标、返回类型。
+ 访问基类数据成员（包含不具有的能力）：强制类型转换`(基类类型) *this`
+ 访问基类友元：强制类型转换（否则可能调用派生类友元—错误递归）

#### 保护继承

+ 概念：基类的公有成员和保护成员都将称为派生类的保护成员，
+ 在派生类中和私有继承一样。
+ 区别：当以派生类为基类时
  + 私有继承第三代类不能再使用基类的接口，因为公有变私有
  + 公有继承第三代类可以，因为基类进保护。

## 多重继承

多重继承(multiple inheritance, MI)：多个基类由逗号分隔，访问限定符限定每一个基类（当然，私有为默认）

> 不同基类具有同名成员
>
> > 将基类指针或引用指向派生类时，需强制转换确定使用哪个基类的(常规继承是隐式的）—— 这就使继承多态性复杂化——为此C++引入新技术：***虚基类(virtual base class)***。

+ 虚基类：使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象

  ​				使用关键字**`virtual`**（其次序与访问限定符无关紧要）

  ```cpp
  class BASE;
  class base1 : virtual public BASE;
  class base2 : public virtual BASE;  //两种形式都可
  class drived : public base1, public base2;
  对于base1，和base2由BASE中继承的成员在drived中只有一个。
  //本质是base1和base2共享同一个基类中的成员。
  同时对于dirved来说base是在继承后才作为基类的，所以base的声明中的virtual需要额外添加
  ```

  + 构造：

    > 常规继承中，构造函数在继承链中是相邻的类调用，信息在继承链中传递
    >
    > 多重继承中，构造函数在继承链中的传递有了多种途径

    多重继承中C++在基类是虚的时，禁止信息通过中间类自动传递给基类。要显式直接调用基类（隔层调用，这在常规继承是非法的）

    + 调用基类构造函数顺序是按派生类声明时的从左到右的顺序

  + 方法
  
    > 如果派生类**没有重定义方法**，类外通过类对象调用类方法时
    >
    > 常规继承中，派生类使用最近祖先中的定义
    >
    > 多重继承中，每个直接祖先都有，会有**二义性**。

    + 需要在方法中使用限定名(全称)`drived_dvxd.base1::fName();` `drived_dvxd.base2::fName();`

    + 或在派生类中重定义

      如果不想修改，则在方法定义中调用某一个方法（也是限定名）

  + 组件：
  
    1. 123
    2. 123

  + 混合使用虚基类和非虚基类：虚基类获得一个副本，非虚基类获得每个的副本。

  + 虚基类和支配

    新的C++解析二义性的方法：如果某个名称优先于（deminates）其他所有名称，则可以使用
  
    派生类中的名称优先于直接或间接祖先类中的相同名称



## 嵌套类

> 与包含的区别：包含是类对象作为另一个类的成员；嵌套是新类型，不创建对象。

+ 嵌套类(nested class)：在另一个类声明的类。  提供新的作用域避免名称混乱

  包含类						：包含嵌套类的类。

+ 当嵌套类位于公有部分，可以在包含类外通过作用域解析运算符使用嵌套类。

  > 老版C++不允许

+ 访问权限：类声明的位置决定类的作用域或可见性；类可见后，访问控制规则（公有、保护、私有、友元）将决定程序对嵌套类成员的访问权限。

  + 作用域

  + 嵌套类、结构和枚举的作用域特征

    | 声明位置 | 包含它的类是否可以使用它 | 从包含它的类派生而来的类是否可以使用它 | 在外部是否可以使用     |
    | -------- | ------------------------ | -------------------------------------- | ---------------------- |
    | 私有部分 | 是                       | 否                                     | 否                     |
    | 保护部分 | 是                       | 是                                     | 否                     |
    | 公有部分 | 是                       | 是                                     | 是，通过类限定符是使用 |

  + 访问控制

+ 模板嵌套：嵌套类可以使用包含类的模板，这时对于每个包含类的实例，嵌套类都有对应的实例。

+ 修改基类的访问权限，在派生类中使用`using::基类中的”可访问“的名称`，即调整了基类中的名称的访问权限，由其在派生类的哪些位置决定，比如将基类中的保护成员在派生类的public中using，则这个名称在派生类中成了共有成员

## 类型转换

+ 从派生类向基类的类型转换只对指针或引用类型有效

+ 从派生类直接向基类赋值时（不是指针和引用），由于基类的标准函数中肯定有一个以基类的引用为参数的函数，这个函数会接受派生类对象，但是函数内部只能处理基类的数据成员，则属于派生类的部分被切掉sliced down了
