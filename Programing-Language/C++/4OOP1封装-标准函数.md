## 类标准函数

+ 标准函数的存在是为了自定义的类有类似内置类型的行为，故如果不显式的定义，某些场景下一些标准函数会由编译器synthesized合成，成为合成什么什么函数或者默认什么什么函数。

| 函数       | 能否继承 | 成员还是友元 | 默认能否生成 | 能否为虚函数 | 是否可以有返回类型 |
| ---------- | -------- | ------------ | ------------ | ------------ | ------------------ |
| 构造函数   | 否       | 成员         | 能           | 否           | 否                 |
| 析构函数   | 否       | 成员         | 能           | 能           | 否                 |
| =          | 否       | 成员         | 能           | 能           | 能                 |
| &          | 能       | 任意         | 能           | 能           | 能                 |
| 转换函数   | 能       | 成员         | 否           | 能           | 否                 |
| ()         | 能       | 成员         | 否           | 能           | 能                 |
| []         | 能       | 成员         | 否           | 能           | 能                 |
| ->         | 能       | 成员         | 否           | 能           | 能                 |
| op=        | 能       | 任意         | 否           | 能           | 能                 |
| new        | 能       | 静态成员     | 否           | 否           | void*              |
| delete     | 能       | 静态成员     | 否           | 否           | void*              |
| 其他运算符 | 能       | 任意         | 否           | 能           | 能                 |
| 其他成员   | 能       | 成员         | 否           | 能           | 能                 |
| 友元       | 否       | 友元         | 否           | 否           | 能                 |

+ 显式要求编译器    合成构造和拷贝控制函数：        在声明或定义方法后添加`=default`
+ ​        要求编译器不合成构造和拷贝控制函数：必须在声明方法后            添加`=delete`
  + 析构函数：不能销毁（不能创建）和delete（能new）
  + 如果类的数据成员有该声明，则认为该类也对应有该声明

## 构造函数

+ 合成构造函数：

+ 构造函数：

  + 声明/定义：函数名与类名相同，没有返回值（声明类型）。

    + 是没有返回值，而不是返回值为void

    + 参数不是成员数据，而是赋给成员的值

      > 一种常见的做法是在数据成员名中使用`m_`前缀；另一种常见的做法是在成员名中使用后缀`_` 。

  + 调用：对象的初始化，每次创建类对象，都使用构造函数。

    1. 显式的调用：等号赋值`ClassName sam = ClassName(参数);`

    2. 隐式的使用：括号没等号`ClassName sam(参数);`

       ​						C++11列表初始化：`ClassName dvxdName = {参数}`等号可选

       ​						new运算符：`ClassName *dvxdName = new ClassName(参数);`

       ​						若构造函数只有一个参数，可以将对象初始化为一个与参数类型相同的值`ClassName dvxdName=value;`

  + member initializer list成员初始化器列表：用于各种构造函数

    对const数据成员、引用类型数据成员只能使用成员初始化。

    对于类对象成员，成员初始化可减少步骤。

    > const限定和引用类型要求只能在定义时初始化一次，但是对象在调用构造函数前已经被创建，初始化列表为特殊的语法。

    + 格式：由逗号分隔的初始化列表组成（前面带冒号），位于参数列表的右括号之后，函数体左括号之前，表示法为`成员(value)`；内置类型会调用其构造函数。

      ```cpp
      class ClassName {
      	int a;
          string str;
          int &b;
          const int c;
      public:
          ClassName(int a_, string s,int b_, int c_) : str(s), b(b_), c(c) { a = a_; }
      }
      ```


    这种方法并不限于初始化常量，普通成员数据也可以使用

    C++11允许类内声明初始化，与成员初始化列表等价，但列表可覆盖默认初始值。

    > 底层效率：初始化是直接初始化数据成员，赋值是先初始化再赋值
    >
    > 同时const、引用、无初始化的类必须初始化

    + 顺序：成员初始化的顺序与它们在类定义中的出现顺序一致，与初始化列表的顺序无关

+ 委托构造函数(delegating constructor)：使用其他构造函数执行自己初始化：初始化列表是自己的构造函数

+ 转换构造函数(converting constructor)：通过一个实参调用的构造函数定义一个从构造函数的参数类型向类类型隐式转换的规则

# 拷贝控制

C++定义类时，需要知道这种类型的**拷贝、赋值与销毁**时的行为，如果没有显式定义，C++会隐式的提供synthesized合成

+ constructor function构造函数
  + copy constructor function拷贝构造函数
  + move constructor function移动构造函数
+ destructor function析构函数
+ 
  + copy-assignment operator拷贝赋值运算符
  + move-assignment operator移动赋值运算符

+ 一个类的拷贝控制充分定义后，可区分左值右值来调用函数

## 拷贝构造函数

+ 定义：
+ 原型：`Class_name(const Class_name &);`第一个参数是自身类型的引用且任何额外参数都有默认值

+ 调用：新建一个对象并将其初始化为同类现有对象（**生成对象副本**）

  ​			ege：初始化（赋值、列表）（具体取决于实现），显式调用，按值传递参数，函数返回。

+ 功能：逐个赋值非静态成员（浅赋值）

  > 潜复制：复制成员值
  >
  > 深复制：复制成员值，并复制指针成员引用的结构

  想实现深复制可自定义默认复制构造函数。

  + 对于`char *`类型的字符串成员，如果使用浅复制，则新老对象的成员指向同一块内存，如果旧对象被释放，则新对象会发生危险。所以重载复制构造函数，开辟新空间拷贝字符串，然会新对象指向新内存。

## 拷贝赋值运算符

> 赋值运算符较于拷贝构造函数要考虑自己给自己赋值

+ 原型：`Class_name & Class_name::operator=(const Class_name &);` 

  ​		   接收并返回一个指向类对象的引用，在定义内改变this，返回this(是为了连续赋值)，改变的副作用。

  ​		  `a = b = c;`会转变为`a operator=(b operator=(c));`这时内层b改变后返回b的引用，a继续根据已经改变的b修改

  使用时还要考虑左值和右值是否是同一对象，`if (this == &st) return *this;`

+ 调用：将已有的对象赋给另一个对象。

+ 功能：浅复制非静态成员

  > 复制构造函数：初始化新对象**一定**调用复制构造函数 创建一个新的实例
  >
  > 赋值运算符：使用复制运算符**可能**调用复制运算符     执行某种运算赋值对象的值

+ 深度复制时：对于左值对象，指针不仅是开辟新空间指向新内存就可以了，还有处理好老的内存，需要专门释放它。

  ​                       释放左值this，开辟新空间容纳右值，将左值this成员指向新空间。

  > 为的就是模拟内置类型赋值表达式的效果

+ 在将对象初始化为内置类型时，内置类型会调用构造函数变为对象，复制构造函数复制这个对象生成一个临时对象，然后再由赋值运算符复制这个临时对象——费时费力——重载复制运算符：`string & string::operator=(const char *s)`

## 移动

> 考虑这样的场景，一个类中有大量的数据，对这样的类，将一个对象拷贝给另一个对象，同时作为右值的对象”立刻“就不用了，我们发现预期”创建大量的空间，将原本的对象一个一个创建在新空间，并将新空间给一个新对象，同时旧对象里的数据不用了“，不如直接将旧对象中的大量数据”移动“到新对象中，虽然移动过程中同样花费时间，但是较于普通的拷贝省去了初始化的时间

+ 右值引用

  > C++11提出右值引用rvalue reference，较于普通的引用（左值引用lvalue reference）性质相反

  + 语法：较于左值引用符号为`&&`
  + 定义：必须绑定到右值（暂时量）、即将销毁的对象

+ move函数

  > 如果一定要将一个右值引用绑定到一个”非暂时量“呢

  + 函数`move`，头文件`<utility>`，名称空间`std`：显式调用一个类型的移动构造函数

    + 语法：`...&& ... = std::move(moved-from移动源)`

    > 本质是一种承诺，参数量之后只能被销毁或者重新赋值

----

+ move iterator移动迭代器适配器：通过改变给定迭代器的解引用运算符的行为来适配，比如本来是返回左值，其令其返回右值

+ reference qualifier引用限定符：在参数列表后放置`&`或`&&`，来表明该函数必须被什么对象使用
  + 关于参数列表限制`this`的const，引用限定符必须在其后面

## 移动构造函数

```c++
ClassName::ClassName(ClassName &&t) noexcept
    : 初始化列表 {
	...        
}
```

## 移动赋值运算符

```c++
ClassName &ClassName::operator=(ClassName &&rhs) noexcept {
    if (this != &rhs) {
        
    }
    ...
	return *this;
}
```

+ `noexcept`：通知标准库，其他用户可通过move调用该类的移动构造函数

  > 拷贝构造函数是不怕抛出异常的，因为即使程序终止这只影响被赋值的对象，被拷贝的对象没有受损。但是移动构造函数如果在移动构成中抛出异常，则被移动的对象中的数据是破损的

+ 通过移后源的性质设计两个函数：
  + 移后源可能被赋新值：即该对象仍然是有意义的，虽然值被移动，但是该量仍是可用的，所以将内部的数据初始化或设为空
  + 移后源可以被销毁：
    + 有析构函数
    + 数据成员可以被析构

+ 移动函数的合成：
  + 只有类没有定义拷贝控制成员，并且没有非static数据成员都是可移动的，才合成
  + 如果只定义移动而没有定义拷贝，则认为拷贝非删除了
  + 如果一个类只有拷贝而没有移动时，`move`会调用拷贝函数来移动（逻辑上这样肯定安全）

## 析构函数

> new创建的对象可以用delete清理，那么构造函数的对象使用定义的析构函数。

+ 声明：函数名：类名前加上`~`。没有返回值和声明类型。

  格式：`~classNmae();` 必须这样。

+ 定义：由于析构函数不承担任何重要的工作，因此可以将它编写为不执行任何操作的函数

  ```cpp
  className::~className() { }
  ```

+ 使用：

  + 隐式调用：由编译器决定，不在代码中显式的调用析构函数。

    + 静态存储类对象：程序结束时自动调用析构函数
    + 自动存储类对象：程序执行完代码块自动调用析构函数
    + new创建的对象：使用delete时自动调用析构函数
    + 临时对象：结束使用后自动调用析构函数

    由于类对象过期时析构函数自动被调用，所有必须有析构函数，如果程序员没有提供，编译器隐式的声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。

  + 显式调用：

    + 由定位new运算符开辟空间创建的对象，由于不一定在delete的管辖范围，这种对象主要手动释放

      ```cpp
      ClassName * pt = new (定位) ClassName(初始化);
      pt -> ~ClassName();
      ```

## 其他说明

+ `swap`函数

  ```c++
  class ClassName {
      friend void swap(ClassName &, ClassName &);
  };
  inline void swap(ClassName &lhs, ClassName &rhs) {
      using::swap();  // 细节: 将std的swap暴露在当前名称空间下, 这时的swap就能通过最优匹配找到适合的swap
      swap...;  // 对应类的行为
  }
  ```

+ 拷贝并交换：

  ```c++
  ClassName& ClassName::operator=(ClassName rhs) {
      swap(*this, rhs);
      return *this;
  }
  ```

  注意这里的参数是非引用，即在调用时就对对象进行了拷贝，这样的写法可正确处理自赋值
