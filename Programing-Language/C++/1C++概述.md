# C++的历史

+ 前身：1979年C++之父Bjarne Stroustrup因准备博士论文而接触Simula语言，其变种Simula 67是公认的首款支持面向对象的语言，之后Stroustrup开发“C with Classes”语言并制作其编译器Cfront（将C with Classes代码转换成C代码，本身由C with Classes编写）

  > C with Classes具备类、简单继承、内联机制、函数默认参数和强类型检查

+ 1985年Stoustrup出版《C++ Programming Language》作为C++早期的标准

+ 1990年Borland公司发布《annotated C++ Rederence Manual》，同年发布Turbo C++编译器，附带大量函数库，影响深远

| 年份 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 1983 | 更名为C++，引入虚函数、函数重载、引用、const关键字和`//`注释 |
| 1989 | 再次更新，引入多重继承、保护成员以及静态成员                 |
| 1998 | C++98，获得国际统一，纳入1979年开始研发的标准库，并于C++03修订 |
| 2011 | C++11（05年计划引入新特性并非正式命名的C++0x），引入新的for语法、正则表达式、标准线程库等 |

# C++的运行

## 单文件

+ 编译过程：

  ```mermaid
  graph LR; a["源代码文件(source file)"] --编译--> 可链接文件 --链接--> 可执行文件
  ```

  + 链接器一般包含于编译器中

  + 后缀名问题：

    | 文件       | linux系统 | windows系统 | 苹果os |
    | ---------- | --------- | ----------- | ------ |
    | 源代码文件 |           | `.cpp`      |        |
    | 可链接文件 |           | `.o`        |        |
    | 可执行文件 | `.out`    | `.exe`      |        |

## 多文件

+ 分离式编译(separate compilation)：将组件放在独立的文件中，分别编译，在链接时组成一套。

  > 这**组**源代码文件为==一个==程序**文件**，每个单独的源代码文件称为***翻译单元***(translation unit)
  >
  > 所以上述的”独立的文件“中文件应该称为翻译单元。  //不同教材翻译问题

  + 目的：如果修改其一，只需要对它单独编译，然后与其他可链接文件链接。

+ 程序设计：将组件与主函数分开放在独立的文件，对于两者都使用的结构声明（实际上是一个声明，一个定义），放在头文件（标准头文件和自定义头文件）中；

  对于常用的结构，C++提供丰富的标准头文件，对于用户（程序员）定义的结构，在独立的文件中实现（方便实现）。

  1. 头文件（`.h`文件）：  //声明文件

     + 包含：函数原型、使用#define和const定义的符号常量、结构声明、类声明、模板声明、内联函数。  //声明不创建实体变量，只为源代码中定义时提供方案。

       > 标准头文件中老版ANSI C的头文件有后缀`.h`，C++标准库兼容C语言标准库，去掉后缀，添加前缀`c`，其内容从属于名称空间`std`。
       >
       > 自定义头文件使用后缀`.h`。

     + 管理：文件对同一头文件只能包含一次，但头文件可能包含使用者不知道的头文件。可利用编译指令解决
  
       > 防护(guarding)方案/防御式声明：
       >
       > 1. `#define`定义宏。
       >
       >    `#ifndef 宏 ... #endif` 判断宏是否被定义过，如果未定义则运行，否则跳过此部分。
       >
       >    ```cpp
       >    #ifndef NAME_H
       >    #define NAME_H  //在进入后立刻定义即可防止再次进入
       >    // place inclue file contents here
       >    #endif
       >    ```
       >
       >    编译器首次遇到该文件，名称没有被定义，则查看两者之间的内容，并定义名称，这时其他文件遇到名称时已被定义，则跳过。
       >
       > 2. `#pragma once`
       >
       >    可代替方案一的头文件保护功能，即保证文件只被include一次，但是有些编译器不能识别。
       >
       > **系统头文件使用这种技巧，同时也建议自定义的头文件也使用这种方法**

  2. 源代码文件（`.cpp`文件，与实现的头文件名称相同，include该头文件）：包含组件的定义代码。  //定义文件

  3. 源代码文件（`.cpp`文件，包含主函数，为一组源代码的入口，include需要的头文件）：包含使用结构和调用函数的代码。
  
  + 头文件因为有宏保护，所有头文件的引用上无需顾忌；但使用标准名称空间尽量使用作用域解析运算符(`::`)，**不要使用using编译指令**，避免在被使用时与使用文件的操作发生冲突。（因为#include是文本拷贝）
  
    而定义文件中头文件的引用和名称空间的编译不用担心，主函数只会在其中找寻对应组件的实现方式，而不会拷贝整个文件。
  
  + **系统头文件使用`<>`括起来；自定义头文件使用`""`括起来**，这是在提示编译器去哪里寻找头文件。

+ 使用类时通常多文件使用，并且类声明在一个`.h`文件，类方法定义在一个同名的`.cpp`文件，还有一个含主函数的文件。

  + 原型文件：`ClassName.h`

    ```cpp
    #ifndef CLASSNAME_H
    #define CLASSNAME_H
    
    class ClassName {
        ...
    }
    
    #endif
    ```

  + 定义文件：`ClassName.cpp`

    ```cpp
    #include "ClassName.h"
    #include <iostream>
    {
        std::cout << ...;
    }
    
    ClassName::fName
    ```

  + 使用文件：

    ```cpp
    #include "ClassName.h"  //双引号指出同文件下。
    ```

# 杂项

+ 系统时钟：

  C和C++库在`ctime`头文件（老版为`time.h`）提供函数`clock()`，返回程序开始执行后所用的系统时间。

  1. 返回单位不一定是秒，头文件定义符号常量`CLOCKS_PER_ESC`，该常量等于每秒钟包含的系统时间单位数。
  2. 返回类型在不同系统的类型不同，头文件将`clock_t`作为其返回类型的别名，即把变量声明为`clock_t`类型，编译器将它转换成其他适合系统的类型

+ 抽象数据类型(abstract data type，ADT)：通过定义类表示更通用的概念；以通用的方式描述数据类型，没有引入语言或实现细节。

  将描述转换成类说明，公有成员函数提供表示操作的接口（隐藏数据表示），私有数据成员负责存储数据，必须表明数据存储方式。

  > 使用typedef语句用于数据类型并起新的名称，如果需要其他类型的ADT，只需修改typedef，而类声明和方法定义保持不变。
  >
  > 类模板更加强大，将存储的数据类型与类设计隔离开来。

+ 随机数：ANSI C库提供`rand()`函数（头文件`cstdlib`）：返回0到某个值（取决于实现）之间的随机整数，他将一种算法用于一个初始中种子值来获得随机数（默认为0），并将随机值用于下一次函数调用的种子。因为随机算法是固定的，如果起始值是一样的，则生成的随机数是一样的（伪随机数），所以初始化种子要“随机化”，我们使用`time(0)`（头文件`ctime`）初始化种子，使随机更随机`srand(time(0));`  `int x = rand();`

+ C++关键字：<img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/Programing-Language/C++/C++关键字.png" style="zoom:80%;" />

+ 可调用对象：

  + 函数
  + 函数指针

  > 函数名即为函数指针
  >
  > 函数指针的定义：`返回类型(*函数指针名)(参数列表)`即为一个定义

  + lambda表达式
  + bind创建的对象
  + 重载了函数调用运算符的类

  如果将它们视为一种类型，则是`function`

  ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/Programing-Language/C++/function.png)
