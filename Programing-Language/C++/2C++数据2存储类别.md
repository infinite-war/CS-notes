# 存储类别

+ C++管理数据内存的方式：

  1. 存储持续性：描述了数据保留在内存中的时间长度

     1. 自动存储持续性：在程序开始执行所属的函数或代码块时被创建，执行完后释放。

        C++有两种，下面介绍。

        > 自动变量管理方式：栈内存（遵循数构中栈的规则——内存连续）：栈顶、栈底指针：新内存进入时放在栈顶指针并调整栈顶指针，执行完毕后，栈顶指针回到初始位置，这部分信息不再管理（覆盖）

     2. 静态存储持续性：在整个程序执行期间都存在的存储方式

        C++有三种，下面介绍。

        > 在程序执行开始开辟的空间，没有显示初始化则赋为0（这个空间没有值）

     3. 动态存储持续性（也称自由存储空间(free store)或堆(heap)）：new和delete运算符管理的内存池。

     4. 线程存储持续性（C++11新增）：变量存在周期与所属的线程一样长。

        + 关键字`thread_loacl `声明

  2. 作用域(scope)：描述了名称在文件（翻译单元）的可见的范围。

     1. 全局（文件作用域）：
     2. 局部（块作用域）：

  3. 链接性(linkage)：描述了名称在不同单元间如何共享。

| 存储描述         | 持续性 | 作用域 | 链接性 | 如何声明                           |
| ---------------- | ------ | ------ | ------ | ---------------------------------- |
| 自动             | 自动   | 代码块 | 无     | 在代码块中                         |
| 寄存器           | 自动   | 代码块 | 无     | 在代码块中，使用关键字`register`   |
| 静态，无链接性   | 静态   | 代码块 | 无     | 在代码块，使用关键字`static`       |
| 静态，外部链接性 | 静态   | 文件   | 外部   | 不在任何函数内                     |
| 静态，内部链接性 | 静态   | 文件   | 内部   | 不在任何函数内，使用关键字`static` |

1. 自动变量：（默认情况）函数中声明的函数参数和变量，存储持续性为自动，作用域为局部，没有链接性。

   + 嵌套代码块不同层次代码块中的同名变量会：内层hide外层

   + 寄存器变量：关键字`register`，向编译器**申请**该变量使用CPU寄存器存储自动变量，旨在提供访问变量速度

     > register关键在在C++11中失去作用，只是显示的指出变量是自动变量

2. 静态变量：

   1. 外部变量/全局变量外部链接性（可在其他文件访问）：必须在代码块外声明。
   2. 内部链接性（只能在当前文件中访问）：必须在代码块外声明，并使用`static`限定符。
   3. 无链接性（只能在当前函数或代码块中访问）：必须在代码块内声明，并使用`static`限定符。

   下面做具体的描述

3. 外部变量/全局变量（相对于局部的自动变量）：链接性为外部，存储持续性为静态，作用域为整个翻译单元。

   + 引用声明：关键字`extern`，且不进行初始化（如果使用关键字依然初始化则exrern失效）

     > 声明：
     >
     > 1. 定义声明：
     > 2. 引用声明：

     + 多文件，只需一个定义，其他地方使用引用声明
     + 引用的变量遵循自动变量的同名下处理规则
     + 在函数中使用该关键字强调函数使用外部变量

4. 静态存储持续性、内部链接性、作用域整个翻译单元，关键字`static`

   + 不在代码块内声明的变量天然外部链接，使用关键字限定为内部

   + 在多文件程序中，此种变量只能在所属的翻译单元内使用

     **不**会与其他翻译单元的全局变量**冲突**，但会**覆盖**

5. 静态局部变量：静态存储持续性、无链接性，作用域局部，关键字`static`用于局部变量

   + 局部变量存储持续性为自动，使用关键字限定为静态
   + 静态局部变量在程序执行期间一直存在，但名称只在该作用域可见
   + 再生：在其他代码块使用static再次声明同名变量，则使用同一块地址
   + 初始化：初始化语句只在申请空间时执行一次

## 关键字汇总

+ 存储说明符(storage class specifier)：同一个声明不能使用多个说明符，但thread_local可与static或extern结合

  1. **`auto`**（C++11中不在是存储说明符）
  2. **`register`**
  3. **`static`**
  4. **`extern`**
  5. `thread_local`（C++11新增的）
  6. **`mutable`**：限定在数据对象前，当其被传递是被const限定时，可“免疫”const的限定
  
+ cv-限定符(cv-qualifier)：指的const和volatile

  1. **`const`**：内存被初始化后，程序便不能再对内存单元进行修改
     1. 默认全部变量为外部链接性，const设置之为链接性内部
     2. const限定局部变量，使该常量只在代码中有==用？==
  2. **`volatile`**：指出该内存单元即使没有修改，也可能发生变化，ege：与关于时间的硬件有关

  2. **`volatile`**：表明：即使程序代码没有对单元进行修改，其值也可能发生变化：
  + 作用：改善编译器的优化能力（编译器发现连续的语句连续使用某个变量值，则不访问该值两次，而将其放在存储器，这种优化建立在变量的值在这些连续中不会变化，该关键字明确告知不要这种优化。

## 特殊链接性

+ 函数链接性：
  + 默认：静态存储持续性，外部连接
  + `extern`：用在函数声明，指出函数在另外文件中定义
  + `static`：用在函数声明和定义，将函数链接性设为内部
  
+ 语言链接性(language linkage)：


# 名称空间

> 1. 实体：变量、函数、结构、枚举、类以及类和结构的成员。
> 2. 名称：实体的标识符。

+ 传统的C++名称空间：

  1. 声明区域(declaration region)：可以进行声明的区域。

  2. 潜在作用域(potential scope)：从声明点开始，到其声明区域结尾。

     ​        作用域(scope)                 ：数据对象对程序可见的区域

     > 潜在作用域中并非全都是作用域，ege：同名变量隐藏

  C++关于局部变量和全局变量的规则定义了一种名称空间层次、不同声明区域声明名称相互独立。
  
+ 新的C++名称空间特性：定义并命名一个声明空间——名称空间：提供声明名称的区域，不同区域的同名名称不冲突，允许其他部分使用该名称空间的对象

+ 名称空间分类：
  1. 全局名称空间(global namespace)：文件级声明区域，所有名称默认的作用域
  2. 自定义名称空间：
     + 类作用域

----

+ 定义：

  ```c++
  namespace 名称空间名 {
      该名称空间内的实体
  };
  ```

  + 名称空间内的声明和定义规则同全局的相同
  + 名称空间可定义嵌套，但不能定义于代码块（默认名称空间为链接性外部，块内名称不能是外链接性）
  + 名称空间是open的

+ 访问：

  1. 作用域解析运算符`::`格式：`名称空间名::实体标识符`，作为总体使用

     > 未限定的名称(unquealified name)：未被装饰的名称
     >
     > 限定的名称(qualified name)           ：包含名称空间的名称

  2. `using`声明：格式：`using 名称空间名::实体名;` ：将实体名暴露在当前的名称空间中，即可使用未被限定的名称使用

     + 冲突和覆盖：无法导入

  3. `using`编译指令：格式：`using namespace 名称空间名;`：将名称空间内的所有实体名暴露在当前名称空间中

     + 冲突和覆盖：单独使用::强调

+ 其他特性：
  + 定义可嵌套，对应的访问是嵌套使用作用域解析运算符，在内嵌的名称空间也可以使用using，而其作用可在内外层传递
  + 为名称空间创建别名：`namespaces 新名 = 旧名;`
  + 匿名名称空间
  + C++标准库放在名称空间std中
