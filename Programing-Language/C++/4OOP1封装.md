# 类和对象-封装

+ 编译过程：先编译成员的生命，在编译成员和成员函数 -> 成员函数可以调用成员函数而无需关注成员出现次序
+ mutable data member：即使是const对象成员，依然可变

***类***：一种将抽象转换为用户定义类型的C++工具，它将数据标识和操纵数据的方法组合成一个“整洁的包”。

+ 定义类规范：

  1. 类声明：以*数据成员*的方式描述数据部分，以*成员函数*（被称为***方法***）的方式描述公有**接口**。
  
     只描述类对象的存储方案，没有创建实体对象（即开辟用于存储值的空间）。
  
  2. 类方法定义：描述如何实现类成员函数。
  
  通常C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在同名源代码文件中
  

> 接口：一个共享框架，供两个系统交互时使用。
>
> 使用者无需打开类，只需要了解接口便可以使用；更新者无需修改接口，只需更新实现。
>
> 类的公共接口，公众（public）是使用类的程序；要使用某个类，必须了解其公共接口；要编写类，必须创建其公共接口。
>

+ 类声明（接口），类描述的第一部分：

  ```cpp
  class Name {
  private:
      类数据成员
      date member declarations
  /*
  protected:
      ...
  */
  public:
      类函数成员
      member function prototypes
  }
  ```

  1. 类设计关键字**`class`**，后接新类的类型名  //此处的c`lass` 与`typename`不是同义词

     >  一个常见但不通用的约定：类名首字母大写。
     
  2. 访问控制：访问说明符(access specifiers)：指定接下来的成员的访问级别，有效范围到下次访问说明和类的结尾

     > 第一个说明符前，struct是公有，cl是私（区别默认访问权限）

     1. **`private`**    （私有）：只能通过共有成员函数访问

        ​    									类对象的默认访问控制，可省略。

     2. **`public`**      （共有）：使用类对象的程序可以直接访问共有部分。

     3. **`protected`**（保护）（C++11）：用于（保护）继承特性

     共有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。
     
     > 防止程序直接访问数据被称为**数据隐藏**
     >
     > 类设计尽可能将共有接口于实现细节分开。共有接口表示设计的抽象组件。
     >
     > 将实现细节放在一起并将它们与抽象分开被称为**封装**
     >
     > 数据隐藏（将数据放在类的私有部分中）是一种封装。
     >
     > ==OOP是一种思想==。

     无论类成员是数据成员还是成员函数，都可以在类的共有部分或私有部分中声明它。但由于隐藏数据是OOP的主要目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分；（如果成员函数私有，就只能类内用）。
     
     > 类是结构的拓展：
     >
     > 结构：默认访问类型public ，只表述数据。  普通老式数据（POD,Plain Old Data）结构
     >
     > 类	：默认访问类型private，可实现描述。

    + 内联方法：

      1. 定义位于类声明中的函数都将自动成为内联函数

         ```cpp
         class ClassName {
         
         public :
             int maxx(int a, int b) { return a > b ? a : b; }
         }
         ```

      2. 也可以在类声明之外定义成员函数，并使之称为内联函数——使用关键字`inline`。

         ```cpp
         class ClassName {
             
         public :
             int maxx(int a, int b);
         }
         inline int ClassName::max(int a, int b) { return a > b ? a : b; }
         ```

      两种方式等价

  + *静态类数据成员*： 功能：所有对象共享同一个静态成员；存储：静态内存。

    + 声明：关键字**`static`**

    + 初始化：不使用关键字，在类声明外单独初始化`typeName ClassName::ClassName = value;` （一般在定义文件，避免头文件多次声明出现错误）

      ​				const整型和const枚举型可以在类声明中初始化

    C++98只能用于整型或枚举型，C++11可以存储double类型。
    
    + 使用：既可以用过类名引用（::），又可以通过对象名引用（.）
    + 前向声明(forward declaration)：class ClassName； 在定义之前是一个不完全类型(incomplete type     ),用于声明，根本不知道内容耶不知道存储空间（所以类的成员不能是类自己，因为套娃不知道空间，但是可以是指针，这个不需要空间的嘛）
    + 类外无需staties
    + 作为方式静态实参
  
+ 类方法（实现），类描述的第二部分：为类声明中的原型表示的成员函数提供代码

  + 类成员函数的定义与常规函数定义类似。

  特殊的特征：

  1. 定义成员函数时，使用作用域解析运算符（`::`）来表示函数所属的类

     **成员函数所在类作用域**，所以定义或者使用需要特殊的措施。

     > 类方法的完整名称中包括类名，“类名::函数名”是函数的限定名（qualified name）；简单的函数名时全程的缩写（非限定名：unqualified name），只能在类作用域使用。

  2. 类方法可以访问类的`private`组件。

  + `const`成员函数（常量成员函数(const member function)）：被`const`限定的对象，编译器会拒绝调用可能会修改成员数据的成员函数。

    1. 新语法：保证函数不会修改对象：将`const`关键字放在函数的括号后面。const限定的其实是*this指针*。

       声明：`typeName fName() const;`

       定义：`typeName ClassName::fName() const {}`

    只要类方法不修改调用对象，就应将其声明为const

    + 重载：同名同参的常规函数和const成员函数

      > 重载是特征标不同，那这是哪种重载呢？this指针不同，函数名后的const本质上指的是this指针的可修改情况。

      const对象只能调用const成员函数，因为this形参是const的，函数接收的实参也是const的限定的
      
      非const对象优先调用非const成员函数，这是按照重载解析的规则。

  + *静态类成员函数*：声明包含关键字`static`，定义不包含。

    + **没有this指针，不能通过对象调用，不与特定的对象关键，只能使用静态数据成员**
    + 如果声明在共有部分，可在类外使用类名和作用域解析运算符来定义和调用`ClassName::fName();`
    + 可使用静态成员函数设计*类级*（classwide）标记，以控制某些接口的行为。
    
  + 状态成员（state member）函数：描述对象所属的状态。


-----

***对象***：按照类的定义创建的实体存储空间：存储类数据成员的一个副本，同一个类的所有对象共享同一组方法。

​			类可以通过对象调用自己的成员函数，对象也通过成员函数改变自己的状态。

> OOP中，调用成员函数被称为发送消息，因此将同样的消息发送给不同的对象调用同个方法，但该方法被用于两个不同的对象。

+ 创建对象：

  1. 声明类变量：`ClassName sam;`
  2. new运算符：`new ClassName;`

+ 初始化：

  未被初始化的对象，编译器将使用默认构造函数来创建，类似自动变量，值时未知的。

  对已经初始化的对象进行构造函数初始化是重新赋值，刷新成员数据状态。

  1. 构造函数：创建临时对象赋值`dvxdName = ClassName(参数);`——调用构造函数，然后使用赋值运算符更新变量状态。
  2. 初始化工具：`className dvxdName(参数);`——调用构造函数，直接修改变量状态.
  3. 类对象赋值：`dvxdName = dvxdName_已有;`——使用默认复制构造函数构造新对象并且利用赋值运算符的副作用。

  4. C++11列表初始化：`ClassName dvxdName = {参数}`等号可选——调用构造函数。
  5. 内置类型直接赋值：若构造函数只有一个参数，可以将对象初始化为一个与参数类型相同的值`ClassName dvxdName = value;`——调用构造函数
  6. new新对象也可以初始化：`ClassName *dvxdName = new ClassName(参数);`——调用构造函数

+ 使用对象成员：成员运算符（`.`）

+ 对象指针：跟内置变量一样

+ ***对象数组***：跟内置变量一样

  + 初始化：列表初始化（括号括起，逗号分隔的值列表）：其中的每个值可以是各种方式调用的构造函数

    ​				如果没有显式初始化，调用默认构造函数；列表中为未初始化的对象调用默认构造函数。

    > C++对对象数组的处理方案是，使用默认构造函数创建数组元素，然后用花括号中的构造函数创建临时对象，在讲临时对象的内容复制到相应的元素中——所以创建对象数组一定要有默认构造函数。

## this指针

> 如果想在成员函数中访问多个类
>
> ege:`const className & cmp(const className & dvxdName) const;`
>
> 该函数隐式的访问一个对象（调用方法的对象），显式的访问另一个对象（方法中的类参数）；返回一个对象引用。
>
> 其中函数的const保证返回无法修改的引用，参数的const保证不修改显式参数，函数后的const保证不修改隐式参数this
>
> **当需要返回隐式的对象的引用时，可`return *this;`**

C++使用称为this的特殊指针，指向用来调用成员函数的对象（this被作为**隐藏参数**传递给方法）

一般所有类方法都将this指针设置为调用它的对象的地址，所以方法定义中使用成员数据都省略的this（`this -> 成员数据`）。

可以将`*this`作为对使用对象的别名。

> C++处理的方法转换成C-风格：将className::dvxd转换成函数参数（指向className的指针），然后用这个指针（声明为this）来访问类成员。调用改变对象位置即可。

+ 对象的this指针是常量指针，即`classname *const`类型的
  + 常量对象不能调用普通成员函数

## 类作用域

> 类方法的完整名称中包括类名，“类名::函数名”是函数的限定名（qualified name）；简单的函数名时全程的缩写（非限定名：unqualified name），只能在类作用域使用。

类作用域也是一个名称空间：在类中定义的名称的作用域都为整个类，只在该类中是已知的，在类外是不可知的。

​												  名称空间具有开放性，所以类作用域可与其他名称空间嵌套。

所以访问需要通过类对象或作用域解析运算符

```cpp
namespace zweix{
	class ClaaName{
		...
    public:
        int sam;
        void show() {cout << "123"; }
    }
    void show() {cout << "456"}
}

int main() {
	zweix::ClassName::sam = 123;
    zweix::ClassName.a;
    a.show();  //123
    zweix::show();  //456
}
```

+ 类中定义名称作用域为整个类；类内可以，类外不可知；

  1. 不同类可有同名名称。
  2. 不能从外部直接访问类的成员，公有成员函数也是。
     + 调用公有成员函数必须通过对象。
     + 定义成员函数必须使用作用域解析运算符。

  类声明中可以只用名称访问，构造函数名称在被调用时才能被识别，其他情况下必须”根据上下文“使用直接成员运算符（`.`）、间接成员运算符（`->`）、作用域解析运算符（`::`）。

+ 作用域为类的常量

  > 直接在类声明中定义不可行，因为声明没有开辟用于存储值的空间

  1. 在类中声明一个枚举（枚举的作用域是整个类）：`enum {常量 = num};`

     这种方式声明枚举不会创建类数据成员——所有对象中都不包含枚举。

     这个的常量只是一个名称，编译器遇到它是用num代替。

     由于不打算创建枚举类型的变量，所以不需要提供枚举名。

     > ios_base类在其公有部分完成了类似的工作

     类外也可使用类内的枚举`ClassName::常量`(从类作用域考虑)
  
  2. 静态类数据成员与const限定符结合，同时C++11允许声明内初始化（虽然编译器不是在声明时初始化）
  
     `static const int N = 2e5 + 7;`类内使用直接使用`N`，类外使用限定名`ClassName::N`

## 类标准函数

## 运算符重载

> overloaded operator

C++允许将运算符重载扩展都用户定义的类型，即将重载的概念扩展到运算符上，这是OOP中**多态**的一种形式

+ 语法：

  1. 声明：`type operator op (argument-list)`
  2. 定义：`type ClassName::operator op (argument-list) {}`

  其中op为C++有效运算符，参数列表和运算符有关

  + 其中`this`被隐式的作为参数列表的第一项

  + 调用时，编译器会将`Object1 op Object2`转换为`Object1.operator op(Object2)`，当然也能显式的调用

+ 注意：

  + 若将运算符原本的定义视之为一个个函数，则运算符重载函数不应该和这些函数冲突
  + 不能创建新的运算符、不能修改运算符原本的含义、不能修改运算符原本的优先级

  ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/Programing-Language/C++/可重载的运算符列表.png)

+ 选择作为成员和非成员函数

  + 比如string的operator+，既可以`”s“ + s`又可以`s + "s"`

+ 关于递增递减运算符：前置参数为空，后置参数为`int`，合理：因为前置this就是参数，后置才需要占位符

+ 关于`->`运算符的重载

  ```c++
  type* operator->() const {
      return & this->operator*();
  }
  ```

  这样才能符合`p->ege...`等价于`(*p).ege...`

+ 函数调用运算符：使我们像使用函数一样使用该类的对象。我们将重载了函数运算符的类的对象为function object函数对象

  + 函数对象常作为泛型算法的实参

## 类型转换

处理用户定义类型与语言内置类型之间的转换

1. 1. *自动转换（隐式转换）*：只有一个**形参需要实参**的构造函数（**条件**），可直接类似基本类型赋值进行隐式转换。

      ```cpp
      ClassName(double a);
      ClassName sam = 1.0;
      ClassName(int a, double b = 1.0);
      ClassName sam = 1;
      //都是合法的。
      ```

      如果不需要：可使用关键字**`explicit`**放在此构造函数声明前，关闭这项特性，之后仍可使用显式转换。（只对一个实参的构造函数优秀）（声明使用，定义无需重复）

      + 也可用来阻止赋值构造函数，只能构造函数创造对象

   2. *强制转换（显式转换）*：`ClassName dvxdName = (ClassName) num;` **条件与自动转换同**。

   + 场景：初始化、赋值、传参、函数返回。

     > 本质上先进行构造函数，再使用构造函数的返回值。

   + 为构造函数参数匹配的过程中，允许使用构造函数转换其他数值类型：内置类型的转换后再转换为对象（二步转换）

     `ClassName(int a); dvxdName = 1;`可以`dvxdName = 1.0`也可以

     但是如果构造函数重载了多个可以隐式转换的构造函数，且有内置类型转换前的参数，则会产生***二义性***，就报错。

     `ClassName(int a); ClassName(double); dvxdName = 1.0`不可以。

   + 此性质可以扩展，比如对象做参数是传递内置类型，内置类型会转换为对象，在作为参数进行传递。

     > 编译器先寻找自定义类型可否转换，再寻找内置类型。

2. 转换函数（运算符函数）：将自定义类型转换成内置类型，即用户定义的强制类型转换，**条件也与自动转换同**。

   没有返回值，重载的是关键字，没有显式参数

   + 定义：`operator typeName();`转换函数必须是类方法，不能有返回类型，不能有参数。

   + 使用：

     1. 有一个转换函数（隐式转换）：直接使用，由编译器决定（也可以显式转换）

     2. 有多个转换函数（显式转换）：类似内置类型的强制转换：`typeName(对象)`或`(typeName)对象`

        > 多函数不能直接使用将决定权交给编译器，因为会有二义性，编译器不想承担这种责任。
        >
        > 比如`operator int(); operator double();`时，`int a = dvxd;`允许，但是`cout << dvxd;`不允许，因为不知道对象是转换为int还是double。如果只有一个转换函数则可以。同时，对于上边的例子，`long a = dvxd;`也是不允许的。

     > int的转换是四舍五入，不是截断。

     隐式使用还可能出现意想不到的错误：

     1. C++11允许使用**`explicit`**声明转换函数来使其只能显式使用。

     2. 或者将运算符函数转换成等效的成员函数

        ```cpp
        ClassName::operator int() { return int (数据成员 + 0.5); }
        //替换为
        int ClassName::ClassName_to_Int() { return int (数据成员 + 0.5); }
        //那么在使用时
        int sam = dvxd;  //就是非法的
        //只能显式转换
        int sam = dvxd.ClassName_to_Int();
        ```

   + **有一个问题**：在只有符合自动转换的情况下使用友元函数完善运算符重载时，”对象和对象“肯定没问题，其中一个是内置类型在两个函数中也会被自动转换为对象（隐式的调用了构造函数），没有问题，但如果定义了转换函数并且没有关闭自动转换，表达式可能都被转换为内置类型并进行内置类型的计算。——过多的转换函数会产生二义性。

+ **还有一个问题**，在使用友元函数完善运算符重载时，”对象和内置类型“可以运算符重载，”内置类型和对象“可以友元函数。但是如果有了转换函数，表达式可能将对象转换成内置类型，则表达式从对象加法变成了，其中的内置类型可能发生了隐式转换变成了对象使表达式变为”对象和对象“，就不能使用运算符重载了。

  也对运算符重载做了指导：

  1. 把运算符重载换成友元函数																		//程序更简短，易出错，每次使用调用构造函数，费时

  2. 将运算符重载重载为一个显式使用转换函数做参数的函数                      //正好相反

     `ClassName operator+(double x);`

     `friend ClassName operator+(double x, ClassName & t);`
