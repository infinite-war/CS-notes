+ 注释(comments)：是程序员为读者提供的说明，通常标识程序的一部分或解释代码的某个方面。

  1. 单行注释：以双斜杠`\\`开头的，注释单行
  2. 多行注释/界定符对注释：以`/*`和`*/`包裹，不能嵌套

     注释内的每行都以一个星号开头，从而指出整个范围都是多行注释的一部分

+ 标记：不可分隔的元素——关键字、运算符、标识符。

+ 空白：空格、制表符或回车。

-----

+ 表达式(expression)：操作数和运算符的组合，每个表达式都有值

+ 副作用(side effect)：从C++的构造方式这个角度来看，判断表达式才是主要作用，改变了内存中数据的值是副作用。

+ 顺序点(sequence point)：是程序执行过程中的一个点，在这里，进入下一步之前确保对所有的副作用都进行了评估

  > 为讨论多线程执行，C++11文档不再使用术语“顺序点“。

+ 完整表达式：不是一个更大表达式的子表达式的表达式。

+ 语句：

  + 空语句(null statement)：单独的分号（`;`）

  1. 表达式语句(expression statement)：表达式加分号
     + 逗号运算符（`,`）：逗号表达式的值是最右部分表达式的值
       1. 作为一个顺序点将多个表达式合并为一个语句，
  2. 另一部分：声明语句、调用语句、消息语句、流程控制语句、函数相关语句。

+ 复合语句(compound statement)/代码/语句块(block of statements)/块(block)：用*花括号*(curly brece)括起来的语句和声明序列

  + 内容可为空，一个块就是一个作用域，在块内引入的名字只在块内可见，可隐藏外层同名对象

# 预处理

+ 预处理宏由预处理器管理而不是编译器
+ `#include`引用头文件：使用标准库设施必须包含相关头文件（头文件(header file)/包含文件(include file)）
+ `#define`预处理宏：`#define NAME value` 没有等号，没有分号：编译前，在源代码中替换所有的对应文本。
+ `assert(expr)`（`<cassert>`）：表达式为假则输出信息终止程序，否则不做：用于检测不能发生的条件
  + `NDEBUG`预处理变量：默认没有定义NDEBUG，assert执行，如果定义，assert失效
+ **编译器**定义的局部静态变量：
  + `__func__`：函数名称——静态数组
  + `__FILE__`：文件名称——字符串字面值
  + `__LINE__`：存放行号——整数字面值
  + `__TIME__`：文件编译时间——字符串字面值
  + `__DATA__`：文件编译日期——字符串字面值

# 流程控制

+ 控制流(flow-of-control)：

+ 代码风格：在控制语句关键字和括号之间**加上**一个空格并对语句体进行缩进

  > 控制语句类似函数，故**省略**函数名与括号之间的空格来显著。

-----

***循环***(loop)/迭代：

1. 入口循环(entry-condition)：每轮循环前计算测试表达式的值。

   1. **`while`**循环：

      ```c++
      while (condition)  //表达式或带初始化的变量声明
          statement  //
      ```

   2. 计数循环**`for`**循环

      1. 传统for：

         ```c++
         for (init-statement; condition; espression)//可省略
             	statement
         ```

         + init-statement形式：声明语句、表达式语句、空语句

      2. 范围for(range of statement)（C++11）：遍历容器或其他序列的所有元素

         ```c++
         for (declaration : expression)
             statement
         //expression为数组或类
         //declaration自动迭代值
         //declaration是值拷贝，想要修改对象使用‘引用’
         ```
         
         + 修改容器大小问题：

2. 出口循环

   1. **`do while`**循环(do while statement)：

      ```c++
      do                  //
          statement       //
      while (condition);  //有分号
      ```

***分支***：

+ **`if`**语句(if statement)

  1. ```cpp
     if (test-condition)  //表达式结果为true（会转换）则进行
         statement
     ```

  2. **`else`**语句

     ```cpp
   if (test-condition)
         statement1
   else
         statement2
     ```
  
  3. **`if else`**语句：本质是if 和 else 的嵌套 
  
  + 悬垂else(dangling else)：多对if和else而无花括号——else与最近且未匹配的if匹配

+ 条件运算符：

+ **`switch`**语句(switch statement)：

  > 较于if限制多——标签只能整数，char认为整型，枚举量提升为整型；但执行速度快

  ```cpp
  switch (integer-expression) {
      case label1 : statement(s), /*break;*/
      case label2 : statement(s), /*break;*/
      ...
      default 	: statement(s)        //无条件符合则执行，可选
  }
  ```

  + integer-expression必须是一个结果为整数值的表达式，

    每个label（标签）必须是整数常量表达式：int、char、枚举量。且不能相同

  + 只选择一次，匹配后不再选择——其余语句顺序执行

    可接break跳出，由此性质，不需要对每个label加上括号

    default认为是除了所有可能之外的可能，也可如此处理

    同时由此性质，可多标签重叠（依次排开），来进行同一语句

  + 在case中声明变量，如果想多个case使用，则只声明，不初始化，如果只为某个case使用，则这个case应该使用花括号形成一个作用域

+ ***跳转语句***：

  1. **`break`**语句(break statement)：终止最近的控制流代码块，执行之后的语句

  2. **`continue`**语句(continue statement)：终止最近循环中的当前迭代并立刻开始下一次迭代

  3. **`goto`**语句(goto statement)：跳转到**同一**函数内的另一条语句

     ```c++
     goto label;
     ...
     label : 语句;  //带标签语句(labeled statement)
     ```

     + 标签标识符独立于变量或其他标识符名字，同名不会冲突

  4. **`return`**

# 异常处理

+ 异常处理机制：异常检测（throw表达式-引发(raise异常)）+异常处理（try语句块）

1. throw表达式：**`throw`**关键字和紧随其后的表达式

2. try语句块：

   ```c++
   try {
       program-statements
   } catch (exception-declaration) {
       handler-statements
   }  //catch ...
   ```

   + catch子句：**catch**关键字、括号内对象声明(exception declaration)、块
     + 若干，选择其一，完成后跳出整个try语句块
   + try的块和各个catch的块的作用域是独立的
   + 如果没有匹配的catch子句，程序转到名为`terminate`的与系统有关的标准库函数

+ 标准异常类：

  1. 定义`what()`成员函数，没有参数，返回一个指向C风格字符串的const char *

  + `<exception>`头文件：定义通用异常类`exception`

  + `<stdexcept>`头文件：

     ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes-img@master/Programing-Language/C++/stdexcept.png)

  + `<new>`头文件：定义了`bad_alloc`异常类型

  + `<type_info>`头文件：定义了`bad_cast`异常类型

# 函数

+ 函数(function)：例程：命名的计算单元

0. 函数声明——函数原型(function prototype)：语法较于函数定义没有函数体
   + 函数列表可不指出形参名

1. **函数定义**：

   1. 函数头：
      1. 返回类型(return type)      ：无返回值则为`void`
      
      2. 函数名字(function name)：
      
      3. 参数列表(parameter list) ：0个或多个，多个用逗号分隔
      
         + 如果不接受参数，则参数列表为`void`（显式）或空（隐式）
      
           > 在ANSI C中，函数声明中括号为空意味着不指明形参，在定义中确定
      
   2. 函数体(function body/statement) ：

      > 名字有作用域                   ：程序文本中的一部分     ，名字在其中可见
      >
      > 对象有生命周期(lifetime)：程序执行中的一段时间，对象在其中存在
      >
      > + 局部变量(local variable)：仅作用域内可见，且隐藏外外层作用域名称
      >
      > + 自动对象(auyomatic object)：仅在块执行期间存在的对象
      >
      > + 局部静态对象(local static object)：在第一次执行语句时声明定义并初始化，对象在程序期间一直存在
      >
      >   ```c++
      >   static type name = value;
      >   ```

2. **函数调用**：主调函数(calling function)通过调用运算符(call operator)调用被调函数(called function)：

   + 形参(**parameter**)：函数定义中的参数变量

     实参(**argument**) ：函数调用中的值

## 特殊的函数

+ 主函数：被*启动代码*调用，是程序和操作系统的接口。
  + 语法：`int main() {}`：返回是告知OS程序运行情况，常用int，默认返回0（正常），若其他则异常
  + 参数：`int main(int argc, char *argv[]) {}`：其中argc为argv长度（默认设置），argv[0]为程序名（参数从1开始）
+ 递归：函数调用它自己，每层函数有其独有的局部变量。

+ 内联函数：

  > 程序是一组机器语言指令组成，运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后逐步执行这些指令。调用函数：调用后存储该指令的内存地址，将函数参数复制到堆栈。跳到标记函数起点的内存单元，执行函数代码，然后跳回到地址被保存的指令处。
  >
  > 这个跳跃和记录需要开销

  内联函数指编译时直接把函数的机器语言代替调用语言，缺点是需要更大的的内存，优点是”无须跳跃“更快。

  注意跳转时间本就很小，如果函数代码的执行时间很短，确实节省时间，但同时这个过程很短，也省不了多少。

  内联函数不能递归（不然机器码怎么复制）

  + 使用：在函数的原型和定义前加上关键字`inline`

    ​			通常做法是省略原型。

  + inline是一个请求，如果函数过大或者函数调用自己，编译器可能拒绝。
  
+ constexpr函数：用于常量表达式

  + 要求：函数的返回类型及所有形参的类型都是字面值类型。函数体中必须有且只有一条return语句

    > 编译器把对函数的调用转换成其结果值
    >
    > > 为了在编译过程中随时展开，其被隐式的指定为内联函数

  + 允许其返回值不是一个常量——与**实参**对应

## 参数传递

+ 形参引用实参：实参被引用传递(passed by reference)/函数被传引用调用(called bu reference)：获得实参控制权

  形参值拷贝实参：实参被值传递(passed by value)/函数被传值调用(called by value)                    ：获得值拷贝

  + 形参是指针：虽然是值传递，但是可以通过指针间接影响值
  + 传引用较于传值因避免拷贝故花销更少

  + 关于按引用传递：

    + 必须传递对象，不能是表达式

    + 形参实参类型不一致：

      1. 如果实参为常量或表达式，编译器将生成临时匿名变量，并将引用形参指向它，在函数调用期间存在。
      2. 如果函数只使用实参的值，会创造临时变量储存。
      3. 如果参数会修改实参的值，则报错。
      4. 如果引用形参被const限定，则类似于按值传递。使用临时变量存储

      > 匿名变量：实参转换成形参类型，存储在匿名变量，引用形参指向此变量。

+ const形参和实参：

+ 数组形参：

  + `type fName(type arr[], ...) {}`其中arr实际上是指针

    > 语言如此设置是根本是不能拷贝数组——巨大花销：取舍：舍去数组的一些属性化为指针——不能得知边界，不能用sizeof检测

    + 确定长度：

      1. 使用标记：在数组传递进前在末尾设置哨兵——C风格字符串数组

      2. 使用标准库规范：

         ```c++
         type fName(const type *beg, const int *end) {}
         fName(begin(arr), end(arr));
         ```

      3. 使用辅助形参

  + 数组引用形参：`type fName(type (&arr)[size]) {}`其中size是必须的，且构成类型的一部分（不能是其他长度）

  + 高维数组：C++没有高维数组，是数组的数组——仍然传递指针，但要指明类型（即各维度大小）

    ```c++
    type fName(tpye (* arr)[size]) {}
    type fName(type arr[][size]) {}
    //size是必须的
    ```

+ 数量可变形参：

  + 类型相同：`initializer_list`形参：标准库类型，用于表示某种特定类型的值的数组，定义在同名头文件中，是一种模板，较于vector对象元素都是常量值
  + 类型不同：省略符（只用于与C程序交互的接口）：使用vcarargs的C标准库功能，只能在形参列表最后

## 信息返回

+ 返回引用：一定不能是局部变量

+ 返回数组类型：==数组不能拷贝==，故返回数组的指针或引用

+ 声明：
  1. `Type (*function(parameter_list))[dimension]`：其中括号必须
  2. 尾置返回类型：`auto fName(...) -> type(*)[size] {}`
  3. 使用decltype：`decltype(arr) *fName(...) {}`：decltype不负责将数组类型转换成对应的指针
  
  + 比如在函数模板中将返回值设置为迭代器参数指向位置的值
  
    ```c++
    template<typename T>
    auto get_p(T ite) -> decltype(*ite)
    ```
  
    

## 函数重载

*默认参数*使函数的参数列表有了一定的灵活性

*函数重载*不仅使参数列表的长度可以变化（**功能覆盖默认参数**），其数据类型也可以调整；可实现对不同数据使用同一算法。

*函数模板*使参数列表的数据类型可自动适配（**功能交叉函数重载**）；但要警惕算法对不同类型的适用性性（**函数重载可单独定制**）

*模板重载*结合重载和模板的优势，但”灵活则意味着提高警惕“。

同时对于模板中的问题：使用数据类型不具有的运算符（用户负责）；不同模板类型的运算符；未知类型的赋值和函数返回的问题

***默认参数***：

默认参数定义在函数原型，在对应参数在参数列表中进行赋值，并且默认参数必须**从右往左**进行，即默认参数的右边的参数必须都是默认参数，默认参数后，在函数调用时可对默认的参数不提供实参，同时实参必须按**从左往右**的顺序依次赋给相应的形参，而不能跳过任何参数。

+ 在调用时省略的参数被称为*缺省参数*。

+ 默认参数不能是局部变量

+ 默认参数可以是表达式，要求其类型可转换为形参所需的类型，比如函数（声明时解析，调用时求值）

+ 多次声明：每个形参只能设定一个默认参数，

  + 允许这种：

    ```c++
    type f(type a, type b, type c = 0);
    type f(type a, type b = 0, type c);
    type f(type a = 0, type b, type c);
    //实际上等于type f(type a = 0, type b = 0, type c = 0);
    ```


***函数重载***：

+ 重载：概念与多态一致；函数重载和函数多态是一回事，通常用函数重载。

+ 默认参数：不同数目的参数调用同一个函数

  函数重载：使用不同的参数列表完成同样的工作——用于函数执行相同的任务，但使用不同形式的数据时。

+ 原理：*名称修饰*（name decoration）或*名称矫正*（name mangling）

  C++跟踪每一个重载函数，编译器根据每个函数的形参进行加密。

1. 函数的*参数列表*（*函数特征标*）：参数的数目、类型、顺序同，则特征标同；

   名称无关紧要——C++允许同名函数——C++对特征标不同的同名函数进行重载。

+ 调用函数时如果发现所有的同名函数都有参数列表出现类型不匹配的情况：

  C会实行强制转换，但是C++会报错

+ C++函数将类型引用和类型本身视为同一特征标。

+ 对于const的参数，遵循const的兼容规则。

  同时对于多个特征标都可兼容的情况：C++调用最匹配版本。

+ 重载指特征标，而不是返回类型。

> 以上特性可以从编译器的设计角度理解。

***函数模板***：

+ 默认参数：参数可以部分省略，不过自动填充的参数固定。

  函数重载：参数可以多种类型；允许多个同名函数等效替代

  函数模板：按照接受参数生成函数版本，同一函数。

+ 函数模板：C++的函数模板允许以任意类型的方式来定义函数，一种通用的函数表述；

  > 泛型，使用泛型来定义函数，其中的泛型可用具体的类型替换，所以也被称为通用编程

  类型用参数表示，所以模板特性也被称为*参数化类型*。

  较于默认参数和函数重载的进一步智能，源代码的一个函数，编译器生成适合参数列表的函数重载，即，不会缩短可执行文件，最终代码不包含模板，只有生成的实际函数。

+ 操作：

  1. 建立模板：**`template`**` <`**`typename`**` AnyType>` 或者 **`template`**` <`**`class`**` AnyType>` 关键字template是必须的，关键字typename（C++98）可以用class（之前）代替，必须使用尖括号；类型名可以任意选择（遵守C++命名规则）（常用`T`）。
  2. 使用模板：在函数中即可把模板当作数据类型定义和调用，编译器会自动将形参转换成合适的形参。

+ 重载的模板：对不同类型使用同一算法

+ 模板的局限性：**泛型的数据类型有不合适的运算符**。

+ 显性具体化（explicit specialization）：为模板作进一步定义。

  1. C++标准定义（第三代具体化（ISO/ANSI C++标准） （C++））：
     1. 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。
     2. 显式具体化的原型和定义应以`template<>`打头，并通过名称来指定类型。
     3. 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。

  > 背景：函数模板不生成函数定义，它是用于生成函数定义的方案。
  >
  > + *实例*（instantiation）化：按照模板”方案“生成的具体函数。
  >
  >   模板并非函数定义，但是使用一定类型的模板实例时函数定义。
  >
  >   1. *隐式实例化*（implicit instantiation）：编译器利用模板为特定类型生成函数定义
  >
  >   2. 显式实例化*（explicit instantiation）：直接命令编译器创建特定的实例
  >
  >      语法：声明前的关键字**`template`**和声明所需的类型用`<>`符号指示类型（在函数名和后接括号之间）。
  >
  >      `template typeName fName<typeName>() {}`
  >
  >      2. 或者在使用函数时实例化：`fName<typeName>();`
  >
  > + 具体化：不使用模板来生成函数定义，而应专门给一定类型显式的定义函数定义；必须要有函数原型
  >
  >   语法：
  >
  >   `tempate <> tepeName fName<typeName>() {}`
  >
  >   `tempate <> tepeName fName() {}`
  >
  > + 区别：实例化：用模板生成具体类型的函数定义
  >
  >   ​			具体化：不使用模板，专门为类型定义函数定义，必须要有自己的定义。==//?zweix为什么不直接使用常规函数呢？==
  >
  >   ​			**两者冲突**。

  隐式实例化、显式实例化和显式具体化（specialization）

  新语法：在声明前使用前缀`template`和`template<>`

***重载解析***（oveloading resolution）：对于函数重载、函数模板和函数模板重载，C++有一个定义良好的策略，来决定为函数调用使用哪一个函数定义。

1. 创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。

2. 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包含实参类型与相应的形参类型完全匹配的情况。

   1. 完全匹配，但常规函数优先于模板。

      + 完全匹配允许的无关紧要转换

        Type（argument-list）意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的。

        | 从实参              | 到形参                   |
        | ------------------- | ------------------------ |
        | Type                | Type &                   |
        | Type                | Type                     |
        | Type[]              | * Type                   |
        | Type(argument-list) | Type (*) (argument-list) |
        | Type                | const Type               |
        | Type                | volatile Type            |
        | Type *              | const Type               |
        | Type *              | volatile Type *          |

        如果有多个匹配的原型，编译器无法重载解析过程，即二义性（ambiguous）。但还有其他情况：

        + 指向非const数据的指针和引用优先于非const指针和引用参数匹配。

        + 如果两个完全匹配的函数都是函数模板，则较具体的模板函数优先。

          > *最具体*（most specialized）：指表一起推断使用哪种类型时执行的转换最少。

          部分配许规则（partial ordering rules）（C++98新增）：用于找出最具体的模板的规则。

      + 自己选择：即显式实例化

   2. 提升转换

   3. 标准转换

   4. 用户定义的转换

3. 确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。

+ 模板函数的发展：

  低估了模板的强大，在不断开发中，C++98标准添加的标准模板库；C++11根据程序员的反馈作了相应的修改。

  1. 在模板函数中，存储不同模板类型的变量应该是什么类型。

     C++11提供关键字`decltype`：`decltype(expression) var;` 参数可以是数据对象或者表达式。

     作为声明语句关键字可以赋值语句结合。

     > 为确定类型，编译器必须遍历一个核对表。
     >
     > 1. 如果expression是一个没有用括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符。
     >
     > 2. 如果expression是一个函数调用，则var的类型与函数返回类型相同。
     >
     >    > 并不实际调用函数，只是编译器查看函数原型来获悉返回类型。
     >
     > 3. 如果expression是一个左值，则var为指向为指向其类型的引用。因为这是第三步，已经排除了没有用括号括起的标识符。
     >
     > 4. 如果前面的条件都不满足，则var的类型与expression的类型相同。

  2. 在模板函数中，函数返回不同模板类型的变量。

     此时不能使用decltype，因为它们不在作用域。

     C++新增声明和定义函数的语法：`auto fName() -> typeName;` 将返回类型移到参数声明后面，`-> typeName`被称为后置返回类型（trailing return type），其中auto是占位符，表示后置返回类型提供的类型。

     注意到这时参数列表就被定义了。所以后置类型可以使用decltype了。

## 函数解析/匹配

+ 函数匹配(function mathching)/重载确定(overload resolution)
  + 结果：最佳匹配(best match)、无匹配(no match)、二义性调用(ambiguous call)

1. 选定重载函数集：集合中的函数为候选函数(candiadte function)：与调用函数同名，在调用点可见

2. 考察调用实参，选出能被调用的函数：选出的函数为可行函数(viable function)：形参与实参数量相同，类型对应或可转换

3. 选择最佳匹配：如果没有最佳，则编译器报告二义性调用

   1. 函数的每个实参的匹配都不劣于其他可行函数的匹配
   2. 函数的至少一个实参的匹配优于其他可行函数的匹配

   + 优劣等级：

     1. 精确匹配：
        + 实参和形参类型相同
        + 实参从数组类型或函数类型转换成对应的指针类型
        + 实参添删**顶层**const

     2. 通过const转换实现的匹配
     3. 通过类型提升实现的匹配
     4. 通过算术类型转换或指针转换实现的匹配通过类类型转换实现的匹配

     + 精确匹配优于const转换，所以有无const会调用对应的函数

## 函数指针

+ 声明：`type (*pf)(参数列表);`

+ 使用：

  + 赋值：`pf = fname`或`pf = &fname`都可
  + 调用：`pf(参数)`、`(*pf)(参数)`

+ 说明：

  + 函数返回类型和参数数目及其类型需要一致，函数存在重载也应该这样
  + 可将函数指针赋`nullptr`或`0`值

  + 函数指针做形参：`type fname(..., type pf(参数列表))`或`type fname(..., type (*pf)(参数列表))`

    + 调用：对应位置是函数名

  + 类型别名：

    1. 函数类型：
       + `typedef tpye fname(参数列表);`
       + `typede decltype(fname) fname_;`
    2. 函数指针
       + `typedef tpye (*fname)(参数列表);`
       + `typede decltype(fname) *fname_;`

    + C++11：

      ```c++
      using f = type(参数列表);  //函数类型
      using pf = type(*)(参数列表);  //函数指针
      ```

  + 返回指向函数的指针：

    + 使用类型别名：

      ```c++
      pf fname(参数列表);
      (*f) fname(参数列表);
      ```

    + `pf_type (*fname(f_参数列表))(pf_参数列表)`：由内向外看，fname是个函数，后面是形参形参列表，由*号，返回的是指针，指针也有形参列表，故返回的是函数指针，函数指针指向的函数返回类型是type

    + 尾置返回类型：`auto fname(参数列表) -> type (*)(参数列表)`
  
+ 利用decltype：`decltype(fname) * fname_(参数列表)`
