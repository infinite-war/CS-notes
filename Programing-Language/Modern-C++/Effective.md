+ 类型推导，主要指`auto`、`decltype`和模板类型推导
	```cpp
	template<typename T>
	void foo(ParamType param);
	```

	这里的`ParamType`和`T`相关
	+ 如果`ParamType`是引用或者指针，则实参类型中的cv类型限定会被保留，即实参的常量性会被保留；而实参的引用会被忽略，即实参的引用性会被忽略。
	+ 如果`ParamType`是**通用引用**（右值引用），此时左值的实参会被认为是引用，右值的实参会被认为是右值引用
	+ 如果`ParamType`什么也不是，则实参的引用性会被直接忽略，实参的cv类型限定也会被忽略。
		>注意为啥常量性也会被忽略呢？因为引用被限定了，形参不过是实参的拷贝，所以常量性的忽略是没影响到的。

		+ 还有一个情况如果实参是`const char* const`呢？会变成`const char*`，形参可以变化，但是不能通过形参修改字符串。
	+ 数组实参，一般形况下，数组可以退化成指针，对于普通的`T`类型的形参，传递数组确实会转换成指针，因为最后类型变成了`T[]`，这个在C语言中就是指针，但是如果形参类型是`T&`呢？它是为了引用传递进行的数组实参，此时数组的长度信息就应该拿到，比如
		```cpp
		template<typename T, std::size_t N>
		constexpr std::size_t arraySize(T (&)[N]) noexcept {  // 形参没有名字，我们只关注数组长度
		    return N;
		}
		```

	+ 同样的情况也发生在函数指针中

	+ 例外：`auto`中的初始化
