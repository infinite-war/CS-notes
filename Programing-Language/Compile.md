# 编译

##  C/C++

### 预处理
[The C Preprocessor(GNU)](https://gcc.gnu.org/onlinedocs/cpp/)



```bash
gcc -E main.c
gcc -E main.c --verbose
```

+ 预处理的工作
	+ 去掉注释
	+ 连接因断行符而拆分的字符串
	+ 处理宏
	+ 处理条件编译
	+ 字符串化`#`：代码标识符变字符串
	+ 标识符连接`##`：修改源码

---

词法分析

```bash
clang -fsyntax-only -Xclang -dump-tokens xxx.c
```

语法分析

```bash
clang -fsyntax-only -Xclang -ast-dump xxx.c
```

语义分析

clang的语法分析也做了
```bash
clang -fsyntax-only -Xclang -ast-dump xxx.c
```

中间代码生成

```bash
clang -S -emit-llvm xxx.c
```

中间代码优化

```bash
clang -S -foptimization-record-file=- xxx.c
```

目标代码生成

```bash
clang -S xxx.c
```

+ risc-v
	```bash
	clang -S xxx.c --target=riscv64 -march=rv64g
	```

生成二进制代码

```bash
clang -c a.c
```

+ risc-v：同上

链接

执行







1. *源代码*文件（文本文件），拓展名是`.c`

   >  区分：文本文件：		只有文字本身
   >
   >  ​		   字处理器文件： 还有字体和格式等

2. 翻译：

   1. 源代码出现的字符映射到源字符集，处理多字节字符和*三字符序列*（字符扩展）

   2. 定位每个反斜杠后面跟着换行符的实例并删除$\Rightarrow$将*物理行*确定为*逻辑行*

   3. 把文本划分成预处理记号序列、空白序列和注释序列（*记号*是由空格、制表符和换行符分隔的项）

      编译器将注释替换为空格。

3. 预处理：预处理器查找每一行以#号开始的预处理指令

4. *编译*：编译器将源代码转换成*目标代码文件*；

   > 目标代码：缺少*启动代码*、没有链接*库函数*；拓展名为`.obj`
   >
   > > 启动代码：程序与操作系统的接口，不同操作系统不一样
   > >
   > > 库函数：

   > 编译器：
   >
   > + UNIX C编译器（cc）：`.c`文件 -> `.o`文件 -> `.out`文件(  `.exe`文件)
   > + GNU编译器集合（gcc编译器等）：`gcc [options] [filenames]`
   > + LLVM项目（clang编译器等）

   >  不同系统上编译：
   >
   > + Linux：gcc
   >
   > + PC：别处获取C编译器
   >
   > + IDE（集成开发环境）
   >
   >   > 错误与警告
   >
   > + Windows/Linux双系统
   >
   > + Macintosh（Mac）

5. *链接*：将启动代码、目标代码、库函数（只取需要的部分）合并成一个*可执行文件*

   > 可执行文件：拓展名是`.exe`

   部分系统是编译器调用链接器，有的则是需要单独启动。

6. 运行

+ 多文件的运行：

  + 多文件运行时所有文件属于同一组文件，其中每个文件称为*翻译单元*，在此称每个翻译单元为文件。

  + 程序设计：

    1. 头文件（.h文件）：各种声明，做好防护

    2. 定义文件（.c文件）：头文件中声明的定义，include头文件，内部头文件的引用和名称空间的using不影响使用文件

       > 因为使用文件include的是.h文件，编译器只是在此寻找定义，而不是文本替换

    3. 使用文件（.c文件）：含主函数，include头文件。链接时链接定义文件。
    
       > include头文件时不同文件的不同包含方式：
       >
       > + 尖括号`<>`包含系统头文件    ：编译器优先去。
       > + 双引号`""`包含自定义头文件：编译器优先去，然后去。

+ win命令行编译运行C程序：


# C++的运行

## 单文件

+ 编译过程：

  ```mermaid
  graph LR; a["源代码文件(source file)"] --编译--> 可链接文件 --链接--> 可执行文件
  ```

  + 链接器一般包含于编译器中

  + 后缀名问题：

    | 文件       | linux系统 | windows系统 | 苹果os |
    | ---------- | --------- | ----------- | ------ |
    | 源代码文件 |           | `.cpp`      |        |
    | 可链接文件 |           | `.o`        |        |
    | 可执行文件 | `.out`    | `.exe`      |        |

## 多文件

+ 分离式编译(separate compilation)：将组件放在独立的文件中，分别编译，在链接时组成一套。

  > 这**组**源代码文件为==一个==程序**文件**，每个单独的源代码文件称为***翻译单元***(translation unit)
  >
  > 所以上述的”独立的文件“中文件应该称为翻译单元。  //不同教材翻译问题

  + 目的：如果修改其一，只需要对它单独编译，然后与其他可链接文件链接。

+ 程序设计：将组件与主函数分开放在独立的文件，对于两者都使用的结构声明（实际上是一个声明，一个定义），放在头文件（标准头文件和自定义头文件）中；

  对于常用的结构，C++提供丰富的标准头文件，对于用户（程序员）定义的结构，在独立的文件中实现（方便实现）。

  1. 头文件（`.h`文件）：  //声明文件

     + 包含：函数原型、使用#define和const定义的符号常量、结构声明、类声明、模板声明、内联函数。  //声明不创建实体变量，只为源代码中定义时提供方案。

       > 标准头文件中老版ANSI C的头文件有后缀`.h`，C++标准库兼容C语言标准库，去掉后缀，添加前缀`c`，其内容从属于名称空间`std`。
       >
       > 自定义头文件使用后缀`.h`。

     + 管理：文件对同一头文件只能包含一次，但头文件可能包含使用者不知道的头文件。可利用编译指令解决
  
       > 防护(guarding)方案/防御式声明：
       >
       > 1. `#define`定义宏。
       >
       >    `#ifndef 宏 ... #endif` 判断宏是否被定义过，如果未定义则运行，否则跳过此部分。
       >
       >    ```cpp
       >    #ifndef NAME_H
       >    #define NAME_H  //在进入后立刻定义即可防止再次进入
       >    // place inclue file contents here
       >    #endif
       >    ```
       >
       >    编译器首次遇到该文件，名称没有被定义，则查看两者之间的内容，并定义名称，这时其他文件遇到名称时已被定义，则跳过。
       >
       > 2. `#pragma once`
       >
       >    可代替方案一的头文件保护功能，即保证文件只被include一次，但是有些编译器不能识别。
       >
       > **系统头文件使用这种技巧，同时也建议自定义的头文件也使用这种方法**

  2. 源代码文件（`.cpp`文件，与实现的头文件名称相同，include该头文件）：包含组件的定义代码。  //定义文件

  3. 源代码文件（`.cpp`文件，包含主函数，为一组源代码的入口，include需要的头文件）：包含使用结构和调用函数的代码。
  
  + 头文件因为有宏保护，所有头文件的引用上无需顾忌；但使用标准名称空间尽量使用作用域解析运算符(`::`)，**不要使用using编译指令**，避免在被使用时与使用文件的操作发生冲突。（因为#include是文本拷贝）
  
    而定义文件中头文件的引用和名称空间的编译不用担心，主函数只会在其中找寻对应组件的实现方式，而不会拷贝整个文件。
  
  + **系统头文件使用`<>`括起来；自定义头文件使用`""`括起来**，这是在提示编译器去哪里寻找头文件。

+ 使用类时通常多文件使用，并且类声明在一个`.h`文件，类方法定义在一个同名的`.cpp`文件，还有一个含主函数的文件。

  + 原型文件：`ClassName.h`

    ```cpp
    #ifndef CLASSNAME_H
    #define CLASSNAME_H
    
    class ClassName {
        ...
    }
    
    #endif
    ```

  + 定义文件：`ClassName.cpp`

    ```cpp
    #include "ClassName.h"
    #include <iostream>
    {
        std::cout << ...;
    }
    
    ClassName::fName
    ```

  + 使用文件：

    ```cpp
    #include "ClassName.h"  //双引号指出同文件下。
    ```
